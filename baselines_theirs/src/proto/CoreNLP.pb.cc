// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CoreNLP.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CoreNLP.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace edu {
namespace stanford {
namespace nlp {
namespace pipeline {

namespace {

const ::google::protobuf::Descriptor* Document_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Document_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sentence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sentence_reflection_ = NULL;
const ::google::protobuf::Descriptor* Token_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Token_reflection_ = NULL;
const ::google::protobuf::Descriptor* Quote_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Quote_reflection_ = NULL;
const ::google::protobuf::Descriptor* ParseTree_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ParseTree_reflection_ = NULL;
const ::google::protobuf::Descriptor* DependencyGraph_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DependencyGraph_reflection_ = NULL;
const ::google::protobuf::Descriptor* DependencyGraph_Node_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DependencyGraph_Node_reflection_ = NULL;
const ::google::protobuf::Descriptor* DependencyGraph_Edge_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DependencyGraph_Edge_reflection_ = NULL;
const ::google::protobuf::Descriptor* CorefChain_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CorefChain_reflection_ = NULL;
const ::google::protobuf::Descriptor* CorefChain_CorefMention_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CorefChain_CorefMention_reflection_ = NULL;
const ::google::protobuf::Descriptor* Mention_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Mention_reflection_ = NULL;
const ::google::protobuf::Descriptor* IndexedWord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IndexedWord_reflection_ = NULL;
const ::google::protobuf::Descriptor* SpeakerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SpeakerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Span_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Span_reflection_ = NULL;
const ::google::protobuf::Descriptor* Timex_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Timex_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Relation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Relation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Operator_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Operator_reflection_ = NULL;
const ::google::protobuf::Descriptor* Polarity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Polarity_reflection_ = NULL;
const ::google::protobuf::Descriptor* NERMention_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NERMention_reflection_ = NULL;
const ::google::protobuf::Descriptor* SentenceFragment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SentenceFragment_reflection_ = NULL;
const ::google::protobuf::Descriptor* RelationTriple_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RelationTriple_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapStringString_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapStringString_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapIntString_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapIntString_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Language_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Sentiment_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* NaturalLogicRelation_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_CoreNLP_2eproto() {
  protobuf_AddDesc_CoreNLP_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CoreNLP.proto");
  GOOGLE_CHECK(file != NULL);
  Document_descriptor_ = file->message_type(0);
  static const int Document_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, sentence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, corefchain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, docid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, sentencelesstoken_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, quote_),
  };
  Document_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Document_descriptor_,
      Document::default_instance_,
      Document_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, _has_bits_[0]),
      -1,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, _extensions_),
      sizeof(Document),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Document, _internal_metadata_),
      -1);
  Sentence_descriptor_ = file->message_type(1);
  static const int Sentence_offsets_[28] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, tokenoffsetbegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, tokenoffsetend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, sentenceindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, characteroffsetbegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, characteroffsetend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, parsetree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, binarizedparsetree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, annotatedparsetree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, sentiment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, kbestparsetrees_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, basicdependencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, collapseddependencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, collapsedccprocesseddependencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, alternativedependencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, openietriple_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, kbptriple_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, entailedsentence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, paragraph_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, hasrelationannotations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, relation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, hasnumerizedtokensannotation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, mentions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, mentionsforcoref_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, hascorefmentionsannotation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, sentenceid_),
  };
  Sentence_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Sentence_descriptor_,
      Sentence::default_instance_,
      Sentence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, _has_bits_[0]),
      -1,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, _extensions_),
      sizeof(Sentence),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sentence, _internal_metadata_),
      -1);
  Token_descriptor_ = file->message_type(2);
  static const int Token_offsets_[38] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, category_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, before_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, after_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, originaltext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, ner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, normalizedner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, lemma_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, beginchar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, endchar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, utterance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, speaker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, beginindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, endindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, tokenbeginindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, tokenendindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, timexvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, hasxmlcontext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, xmlcontext_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, corefclusterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, answer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, headwordindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, operator__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, polarity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, span_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, sentiment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, quotationindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, conllufeatures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, coarsetag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, conllutokenspan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, conllumisc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, conllusecondarydeps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, wikipediaentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, gender_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, truecase_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, truecasetext_),
  };
  Token_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Token_descriptor_,
      Token::default_instance_,
      Token_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, _has_bits_[0]),
      -1,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, _extensions_),
      sizeof(Token),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Token, _internal_metadata_),
      -1);
  Quote_descriptor_ = file->message_type(3);
  static const int Quote_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, end_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, sentencebegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, sentenceend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, tokenbegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, tokenend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, docid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, index_),
  };
  Quote_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Quote_descriptor_,
      Quote::default_instance_,
      Quote_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, _has_bits_[0]),
      -1,
      -1,
      sizeof(Quote),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Quote, _internal_metadata_),
      -1);
  ParseTree_descriptor_ = file->message_type(4);
  static const int ParseTree_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, child_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, yieldbeginindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, yieldendindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, sentiment_),
  };
  ParseTree_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ParseTree_descriptor_,
      ParseTree::default_instance_,
      ParseTree_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, _has_bits_[0]),
      -1,
      -1,
      sizeof(ParseTree),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParseTree, _internal_metadata_),
      -1);
  DependencyGraph_descriptor_ = file->message_type(5);
  static const int DependencyGraph_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph, edge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph, root_),
  };
  DependencyGraph_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DependencyGraph_descriptor_,
      DependencyGraph::default_instance_,
      DependencyGraph_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph, _has_bits_[0]),
      -1,
      -1,
      sizeof(DependencyGraph),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph, _internal_metadata_),
      -1);
  DependencyGraph_Node_descriptor_ = DependencyGraph_descriptor_->nested_type(0);
  static const int DependencyGraph_Node_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Node, sentenceindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Node, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Node, copyannotation_),
  };
  DependencyGraph_Node_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DependencyGraph_Node_descriptor_,
      DependencyGraph_Node::default_instance_,
      DependencyGraph_Node_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Node, _has_bits_[0]),
      -1,
      -1,
      sizeof(DependencyGraph_Node),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Node, _internal_metadata_),
      -1);
  DependencyGraph_Edge_descriptor_ = DependencyGraph_descriptor_->nested_type(1);
  static const int DependencyGraph_Edge_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, dep_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, isextra_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, sourcecopy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, targetcopy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, language_),
  };
  DependencyGraph_Edge_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DependencyGraph_Edge_descriptor_,
      DependencyGraph_Edge::default_instance_,
      DependencyGraph_Edge_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, _has_bits_[0]),
      -1,
      -1,
      sizeof(DependencyGraph_Edge),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DependencyGraph_Edge, _internal_metadata_),
      -1);
  CorefChain_descriptor_ = file->message_type(6);
  static const int CorefChain_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain, chainid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain, mention_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain, representative_),
  };
  CorefChain_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CorefChain_descriptor_,
      CorefChain::default_instance_,
      CorefChain_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain, _has_bits_[0]),
      -1,
      -1,
      sizeof(CorefChain),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain, _internal_metadata_),
      -1);
  CorefChain_CorefMention_descriptor_ = CorefChain_descriptor_->nested_type(0);
  static const int CorefChain_CorefMention_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, mentionid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, mentiontype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, gender_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, animacy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, beginindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, endindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, headindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, sentenceindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, position_),
  };
  CorefChain_CorefMention_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CorefChain_CorefMention_descriptor_,
      CorefChain_CorefMention::default_instance_,
      CorefChain_CorefMention_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, _has_bits_[0]),
      -1,
      -1,
      sizeof(CorefChain_CorefMention),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorefChain_CorefMention, _internal_metadata_),
      -1);
  Mention_descriptor_ = file->message_type(7);
  static const int Mention_offsets_[41] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, mentionid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, mentiontype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, gender_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, animacy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, person_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, startindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, endindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, headindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, headstring_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, nerstring_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, originalref_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, goldcorefclusterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, corefclusterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, mentionnum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, sentnum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, utter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, paragraph_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, issubject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, isdirectobject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, isindirectobject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, isprepositionobject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, hastwin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, generic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, issingleton_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, hasbasicdependency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, hascollapseddependency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, hascontextparsetree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, headindexedword_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, dependingverb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, headword_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, speakerinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, sentencewords_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, originalspan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, dependents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, preprocessedterms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, appositions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, predicatenominatives_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, relativepronouns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, listmembers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, belongtolists_),
  };
  Mention_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Mention_descriptor_,
      Mention::default_instance_,
      Mention_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, _has_bits_[0]),
      -1,
      -1,
      sizeof(Mention),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Mention, _internal_metadata_),
      -1);
  IndexedWord_descriptor_ = file->message_type(8);
  static const int IndexedWord_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexedWord, sentencenum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexedWord, tokenindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexedWord, docid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexedWord, copycount_),
  };
  IndexedWord_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IndexedWord_descriptor_,
      IndexedWord::default_instance_,
      IndexedWord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexedWord, _has_bits_[0]),
      -1,
      -1,
      sizeof(IndexedWord),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IndexedWord, _internal_metadata_),
      -1);
  SpeakerInfo_descriptor_ = file->message_type(9);
  static const int SpeakerInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeakerInfo, speakername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeakerInfo, mentions_),
  };
  SpeakerInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SpeakerInfo_descriptor_,
      SpeakerInfo::default_instance_,
      SpeakerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeakerInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(SpeakerInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeakerInfo, _internal_metadata_),
      -1);
  Span_descriptor_ = file->message_type(10);
  static const int Span_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Span, begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Span, end_),
  };
  Span_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Span_descriptor_,
      Span::default_instance_,
      Span_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Span, _has_bits_[0]),
      -1,
      -1,
      sizeof(Span),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Span, _internal_metadata_),
      -1);
  Timex_descriptor_ = file->message_type(11);
  static const int Timex_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, altvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, beginpoint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, endpoint_),
  };
  Timex_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Timex_descriptor_,
      Timex::default_instance_,
      Timex_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, _has_bits_[0]),
      -1,
      -1,
      sizeof(Timex),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timex, _internal_metadata_),
      -1);
  Entity_descriptor_ = file->message_type(12);
  static const int Entity_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, headstart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, headend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, mentiontype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, normalizedname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, headtokenindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, corefid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, objectid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, extentstart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, extentend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, subtype_),
  };
  Entity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Entity_descriptor_,
      Entity::default_instance_,
      Entity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _has_bits_[0]),
      -1,
      -1,
      sizeof(Entity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _internal_metadata_),
      -1);
  Relation_descriptor_ = file->message_type(13);
  static const int Relation_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, argname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, arg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, objectid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, extentstart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, extentend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, subtype_),
  };
  Relation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Relation_descriptor_,
      Relation::default_instance_,
      Relation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, _has_bits_[0]),
      -1,
      -1,
      sizeof(Relation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Relation, _internal_metadata_),
      -1);
  Operator_descriptor_ = file->message_type(14);
  static const int Operator_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, quantifierspanbegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, quantifierspanend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, subjectspanbegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, subjectspanend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, objectspanbegin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, objectspanend_),
  };
  Operator_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Operator_descriptor_,
      Operator::default_instance_,
      Operator_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, _has_bits_[0]),
      -1,
      -1,
      sizeof(Operator),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Operator, _internal_metadata_),
      -1);
  Polarity_descriptor_ = file->message_type(15);
  static const int Polarity_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectequivalence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectforwardentailment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectreverseentailment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectnegation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectalternation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectcover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, projectindependence_),
  };
  Polarity_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Polarity_descriptor_,
      Polarity::default_instance_,
      Polarity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, _has_bits_[0]),
      -1,
      -1,
      sizeof(Polarity),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polarity, _internal_metadata_),
      -1);
  NERMention_descriptor_ = file->message_type(16);
  static const int NERMention_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, sentenceindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, tokenstartinsentenceinclusive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, tokenendinsentenceexclusive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, ner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, normalizedner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, entitytype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, timex_),
  };
  NERMention_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NERMention_descriptor_,
      NERMention::default_instance_,
      NERMention_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, _has_bits_[0]),
      -1,
      -1,
      sizeof(NERMention),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NERMention, _internal_metadata_),
      -1);
  SentenceFragment_descriptor_ = file->message_type(17);
  static const int SentenceFragment_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SentenceFragment, tokenindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SentenceFragment, root_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SentenceFragment, assumedtruth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SentenceFragment, score_),
  };
  SentenceFragment_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SentenceFragment_descriptor_,
      SentenceFragment::default_instance_,
      SentenceFragment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SentenceFragment, _has_bits_[0]),
      -1,
      -1,
      sizeof(SentenceFragment),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SentenceFragment, _internal_metadata_),
      -1);
  RelationTriple_descriptor_ = file->message_type(18);
  static const int RelationTriple_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, subject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, relation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, object_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, confidence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, subjecttokens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, relationtokens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, objecttokens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, tree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, istmod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, prefixbe_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, suffixbe_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, suffixof_),
  };
  RelationTriple_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RelationTriple_descriptor_,
      RelationTriple::default_instance_,
      RelationTriple_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, _has_bits_[0]),
      -1,
      -1,
      sizeof(RelationTriple),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RelationTriple, _internal_metadata_),
      -1);
  MapStringString_descriptor_ = file->message_type(19);
  static const int MapStringString_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapStringString, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapStringString, value_),
  };
  MapStringString_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MapStringString_descriptor_,
      MapStringString::default_instance_,
      MapStringString_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapStringString, _has_bits_[0]),
      -1,
      -1,
      sizeof(MapStringString),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapStringString, _internal_metadata_),
      -1);
  MapIntString_descriptor_ = file->message_type(20);
  static const int MapIntString_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapIntString, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapIntString, value_),
  };
  MapIntString_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MapIntString_descriptor_,
      MapIntString::default_instance_,
      MapIntString_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapIntString, _has_bits_[0]),
      -1,
      -1,
      sizeof(MapIntString),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapIntString, _internal_metadata_),
      -1);
  Language_descriptor_ = file->enum_type(0);
  Sentiment_descriptor_ = file->enum_type(1);
  NaturalLogicRelation_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CoreNLP_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Document_descriptor_, &Document::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Sentence_descriptor_, &Sentence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Token_descriptor_, &Token::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Quote_descriptor_, &Quote::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ParseTree_descriptor_, &ParseTree::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DependencyGraph_descriptor_, &DependencyGraph::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DependencyGraph_Node_descriptor_, &DependencyGraph_Node::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DependencyGraph_Edge_descriptor_, &DependencyGraph_Edge::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CorefChain_descriptor_, &CorefChain::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CorefChain_CorefMention_descriptor_, &CorefChain_CorefMention::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Mention_descriptor_, &Mention::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IndexedWord_descriptor_, &IndexedWord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SpeakerInfo_descriptor_, &SpeakerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Span_descriptor_, &Span::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Timex_descriptor_, &Timex::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Entity_descriptor_, &Entity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Relation_descriptor_, &Relation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Operator_descriptor_, &Operator::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Polarity_descriptor_, &Polarity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NERMention_descriptor_, &NERMention::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SentenceFragment_descriptor_, &SentenceFragment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RelationTriple_descriptor_, &RelationTriple::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MapStringString_descriptor_, &MapStringString::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MapIntString_descriptor_, &MapIntString::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CoreNLP_2eproto() {
  delete Document::default_instance_;
  delete Document_reflection_;
  delete Sentence::default_instance_;
  delete Sentence_reflection_;
  delete Token::default_instance_;
  delete Token_reflection_;
  delete Quote::default_instance_;
  delete Quote_reflection_;
  delete ParseTree::default_instance_;
  delete ParseTree_reflection_;
  delete DependencyGraph::default_instance_;
  delete DependencyGraph_reflection_;
  delete DependencyGraph_Node::default_instance_;
  delete DependencyGraph_Node_reflection_;
  delete DependencyGraph_Edge::default_instance_;
  delete DependencyGraph_Edge_reflection_;
  delete CorefChain::default_instance_;
  delete CorefChain_reflection_;
  delete CorefChain_CorefMention::default_instance_;
  delete CorefChain_CorefMention_reflection_;
  delete Mention::default_instance_;
  delete Mention_reflection_;
  delete IndexedWord::default_instance_;
  delete IndexedWord_reflection_;
  delete SpeakerInfo::default_instance_;
  delete SpeakerInfo_reflection_;
  delete Span::default_instance_;
  delete Span_reflection_;
  delete Timex::default_instance_;
  delete Timex_reflection_;
  delete Entity::default_instance_;
  delete Entity_reflection_;
  delete Relation::default_instance_;
  delete Relation_reflection_;
  delete Operator::default_instance_;
  delete Operator_reflection_;
  delete Polarity::default_instance_;
  delete Polarity_reflection_;
  delete NERMention::default_instance_;
  delete NERMention_reflection_;
  delete SentenceFragment::default_instance_;
  delete SentenceFragment_reflection_;
  delete RelationTriple::default_instance_;
  delete RelationTriple_reflection_;
  delete MapStringString::default_instance_;
  delete MapStringString_reflection_;
  delete MapIntString::default_instance_;
  delete MapIntString_reflection_;
}

void protobuf_AddDesc_CoreNLP_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rCoreNLP.proto\022\031edu.stanford.nlp.pipeli"
    "ne\"\216\002\n\010Document\022\014\n\004text\030\001 \002(\t\0225\n\010sentenc"
    "e\030\002 \003(\0132#.edu.stanford.nlp.pipeline.Sent"
    "ence\0229\n\ncorefChain\030\003 \003(\0132%.edu.stanford."
    "nlp.pipeline.CorefChain\022\r\n\005docID\030\004 \001(\t\022;"
    "\n\021sentencelessToken\030\005 \003(\0132 .edu.stanford"
    ".nlp.pipeline.Token\022/\n\005quote\030\006 \003(\0132 .edu"
    ".stanford.nlp.pipeline.Quote*\005\010d\020\200\002\"\317\n\n\010"
    "Sentence\022/\n\005token\030\001 \003(\0132 .edu.stanford.n"
    "lp.pipeline.Token\022\030\n\020tokenOffsetBegin\030\002 "
    "\002(\r\022\026\n\016tokenOffsetEnd\030\003 \002(\r\022\025\n\rsentenceI"
    "ndex\030\004 \001(\r\022\034\n\024characterOffsetBegin\030\005 \001(\r"
    "\022\032\n\022characterOffsetEnd\030\006 \001(\r\0227\n\tparseTre"
    "e\030\007 \001(\0132$.edu.stanford.nlp.pipeline.Pars"
    "eTree\022@\n\022binarizedParseTree\030\037 \001(\0132$.edu."
    "stanford.nlp.pipeline.ParseTree\022@\n\022annot"
    "atedParseTree\030  \001(\0132$.edu.stanford.nlp.p"
    "ipeline.ParseTree\022\021\n\tsentiment\030! \001(\t\022=\n\017"
    "kBestParseTrees\030\" \003(\0132$.edu.stanford.nlp"
    ".pipeline.ParseTree\022E\n\021basicDependencies"
    "\030\010 \001(\0132*.edu.stanford.nlp.pipeline.Depen"
    "dencyGraph\022I\n\025collapsedDependencies\030\t \001("
    "\0132*.edu.stanford.nlp.pipeline.Dependency"
    "Graph\022T\n collapsedCCProcessedDependencie"
    "s\030\n \001(\0132*.edu.stanford.nlp.pipeline.Depe"
    "ndencyGraph\022K\n\027alternativeDependencies\030\r"
    " \001(\0132*.edu.stanford.nlp.pipeline.Depende"
    "ncyGraph\022\?\n\014openieTriple\030\016 \003(\0132).edu.sta"
    "nford.nlp.pipeline.RelationTriple\022<\n\tkbp"
    "Triple\030\020 \003(\0132).edu.stanford.nlp.pipeline"
    ".RelationTriple\022E\n\020entailedSentence\030\017 \003("
    "\0132+.edu.stanford.nlp.pipeline.SentenceFr"
    "agment\022\021\n\tparagraph\030\013 \001(\r\022\014\n\004text\030\014 \001(\t\022"
    "\036\n\026hasRelationAnnotations\0303 \001(\010\0221\n\006entit"
    "y\0304 \003(\0132!.edu.stanford.nlp.pipeline.Enti"
    "ty\0225\n\010relation\0305 \003(\0132#.edu.stanford.nlp."
    "pipeline.Relation\022$\n\034hasNumerizedTokensA"
    "nnotation\0306 \001(\010\0227\n\010mentions\0307 \003(\0132%.edu."
    "stanford.nlp.pipeline.NERMention\022<\n\020ment"
    "ionsForCoref\0308 \003(\0132\".edu.stanford.nlp.pi"
    "peline.Mention\022\"\n\032hasCorefMentionsAnnota"
    "tion\0309 \001(\010\022\022\n\nsentenceID\030: \001(\t*\005\010d\020\200\002\"\364\007"
    "\n\005Token\022\014\n\004word\030\001 \002(\t\022\013\n\003pos\030\002 \001(\t\022\r\n\005va"
    "lue\030\003 \001(\t\022\020\n\010category\030\004 \001(\t\022\016\n\006before\030\005 "
    "\001(\t\022\r\n\005after\030\006 \001(\t\022\024\n\014originalText\030\007 \001(\t"
    "\022\013\n\003ner\030\010 \001(\t\022\025\n\rnormalizedNER\030\t \001(\t\022\r\n\005"
    "lemma\030\n \001(\t\022\021\n\tbeginChar\030\013 \001(\r\022\017\n\007endCha"
    "r\030\014 \001(\r\022\021\n\tutterance\030\r \001(\r\022\017\n\007speaker\030\016 "
    "\001(\t\022\022\n\nbeginIndex\030\017 \001(\r\022\020\n\010endIndex\030\020 \001("
    "\r\022\027\n\017tokenBeginIndex\030\021 \001(\r\022\025\n\rtokenEndIn"
    "dex\030\022 \001(\r\0224\n\ntimexValue\030\023 \001(\0132 .edu.stan"
    "ford.nlp.pipeline.Timex\022\025\n\rhasXmlContext"
    "\030\025 \001(\010\022\022\n\nxmlContext\030\026 \003(\t\022\026\n\016corefClust"
    "erID\030\027 \001(\r\022\016\n\006answer\030\030 \001(\t\022\025\n\rheadWordIn"
    "dex\030\032 \001(\r\0225\n\010operator\030\033 \001(\0132#.edu.stanfo"
    "rd.nlp.pipeline.Operator\0225\n\010polarity\030\034 \001"
    "(\0132#.edu.stanford.nlp.pipeline.Polarity\022"
    "-\n\004span\030\035 \001(\0132\037.edu.stanford.nlp.pipelin"
    "e.Span\022\021\n\tsentiment\030\036 \001(\t\022\026\n\016quotationIn"
    "dex\030\037 \001(\005\022B\n\016conllUFeatures\030  \001(\0132*.edu."
    "stanford.nlp.pipeline.MapStringString\022\021\n"
    "\tcoarseTag\030! \001(\t\0228\n\017conllUTokenSpan\030\" \001("
    "\0132\037.edu.stanford.nlp.pipeline.Span\022\022\n\nco"
    "nllUMisc\030# \001(\t\022D\n\023conllUSecondaryDeps\030$ "
    "\001(\0132\'.edu.stanford.nlp.pipeline.MapIntSt"
    "ring\022\027\n\017wikipediaEntity\030% \001(\t\022\016\n\006gender\030"
    "3 \001(\t\022\020\n\010trueCase\0304 \001(\t\022\024\n\014trueCaseText\030"
    "5 \001(\t*\005\010d\020\200\002\"\241\001\n\005Quote\022\014\n\004text\030\001 \001(\t\022\r\n\005"
    "begin\030\002 \001(\r\022\013\n\003end\030\003 \001(\r\022\025\n\rsentenceBegi"
    "n\030\005 \001(\r\022\023\n\013sentenceEnd\030\006 \001(\r\022\022\n\ntokenBeg"
    "in\030\007 \001(\r\022\020\n\010tokenEnd\030\010 \001(\r\022\r\n\005docid\030\t \001("
    "\t\022\r\n\005index\030\n \001(\r\"\307\001\n\tParseTree\0223\n\005child\030"
    "\001 \003(\0132$.edu.stanford.nlp.pipeline.ParseT"
    "ree\022\r\n\005value\030\002 \001(\t\022\027\n\017yieldBeginIndex\030\003 "
    "\001(\r\022\025\n\ryieldEndIndex\030\004 \001(\r\022\r\n\005score\030\005 \001("
    "\001\0227\n\tsentiment\030\006 \001(\0162$.edu.stanford.nlp."
    "pipeline.Sentiment\"\226\003\n\017DependencyGraph\022="
    "\n\004node\030\001 \003(\0132/.edu.stanford.nlp.pipeline"
    ".DependencyGraph.Node\022=\n\004edge\030\002 \003(\0132/.ed"
    "u.stanford.nlp.pipeline.DependencyGraph."
    "Edge\022\020\n\004root\030\003 \003(\rB\002\020\001\032D\n\004Node\022\025\n\rsenten"
    "ceIndex\030\001 \002(\r\022\r\n\005index\030\002 \002(\r\022\026\n\016copyAnno"
    "tation\030\003 \001(\r\032\254\001\n\004Edge\022\016\n\006source\030\001 \002(\r\022\016\n"
    "\006target\030\002 \002(\r\022\013\n\003dep\030\003 \001(\t\022\017\n\007isExtra\030\004 "
    "\001(\010\022\022\n\nsourceCopy\030\005 \001(\r\022\022\n\ntargetCopy\030\006 "
    "\001(\r\022>\n\010language\030\007 \001(\0162#.edu.stanford.nlp"
    ".pipeline.Language:\007Unknown\"\306\002\n\nCorefCha"
    "in\022\017\n\007chainID\030\001 \002(\005\022C\n\007mention\030\002 \003(\01322.e"
    "du.stanford.nlp.pipeline.CorefChain.Core"
    "fMention\022\026\n\016representative\030\003 \002(\r\032\311\001\n\014Cor"
    "efMention\022\021\n\tmentionID\030\001 \001(\005\022\023\n\013mentionT"
    "ype\030\002 \001(\t\022\016\n\006number\030\003 \001(\t\022\016\n\006gender\030\004 \001("
    "\t\022\017\n\007animacy\030\005 \001(\t\022\022\n\nbeginIndex\030\006 \001(\r\022\020"
    "\n\010endIndex\030\007 \001(\r\022\021\n\theadIndex\030\t \001(\r\022\025\n\rs"
    "entenceIndex\030\n \001(\r\022\020\n\010position\030\013 \001(\r\"\360\010\n"
    "\007Mention\022\021\n\tmentionID\030\001 \001(\005\022\023\n\013mentionTy"
    "pe\030\002 \001(\t\022\016\n\006number\030\003 \001(\t\022\016\n\006gender\030\004 \001(\t"
    "\022\017\n\007animacy\030\005 \001(\t\022\016\n\006person\030\006 \001(\t\022\022\n\nsta"
    "rtIndex\030\007 \001(\r\022\020\n\010endIndex\030\t \001(\r\022\021\n\theadI"
    "ndex\030\n \001(\r\022\022\n\nheadString\030\013 \001(\t\022\021\n\tnerStr"
    "ing\030\014 \001(\t\022\023\n\013originalRef\030\r \001(\r\022\032\n\022goldCo"
    "refClusterID\030\016 \001(\005\022\026\n\016corefClusterID\030\017 \001"
    "(\005\022\022\n\nmentionNum\030\020 \001(\r\022\017\n\007sentNum\030\021 \001(\r\022"
    "\r\n\005utter\030\022 \001(\r\022\021\n\tparagraph\030\023 \001(\r\022\021\n\tisS"
    "ubject\030\024 \001(\010\022\026\n\016isDirectObject\030\025 \001(\010\022\030\n\020"
    "isIndirectObject\030\026 \001(\010\022\033\n\023isPrepositionO"
    "bject\030\027 \001(\010\022\017\n\007hasTwin\030\030 \001(\010\022\017\n\007generic\030"
    "\031 \001(\010\022\023\n\013isSingleton\030\032 \001(\010\022\032\n\022hasBasicDe"
    "pendency\030\033 \001(\010\022\036\n\026hasCollapsedDependency"
    "\030\034 \001(\010\022\033\n\023hasContextParseTree\030\035 \001(\010\022\?\n\017h"
    "eadIndexedWord\030\036 \001(\0132&.edu.stanford.nlp."
    "pipeline.IndexedWord\022=\n\rdependingVerb\030\037 "
    "\001(\0132&.edu.stanford.nlp.pipeline.IndexedW"
    "ord\0228\n\010headWord\030  \001(\0132&.edu.stanford.nlp"
    ".pipeline.IndexedWord\022;\n\013speakerInfo\030! \001"
    "(\0132&.edu.stanford.nlp.pipeline.SpeakerIn"
    "fo\022=\n\rsentenceWords\0302 \003(\0132&.edu.stanford"
    ".nlp.pipeline.IndexedWord\022<\n\014originalSpa"
    "n\0303 \003(\0132&.edu.stanford.nlp.pipeline.Inde"
    "xedWord\022\022\n\ndependents\0304 \003(\t\022\031\n\021preproces"
    "sedTerms\0305 \003(\t\022\023\n\013appositions\0306 \003(\005\022\034\n\024p"
    "redicateNominatives\0307 \003(\005\022\030\n\020relativePro"
    "nouns\0308 \003(\005\022\023\n\013listMembers\0309 \003(\005\022\025\n\rbelo"
    "ngToLists\030: \003(\005\"X\n\013IndexedWord\022\023\n\013senten"
    "ceNum\030\001 \001(\r\022\022\n\ntokenIndex\030\002 \001(\r\022\r\n\005docID"
    "\030\003 \001(\r\022\021\n\tcopyCount\030\004 \001(\r\"4\n\013SpeakerInfo"
    "\022\023\n\013speakerName\030\001 \001(\t\022\020\n\010mentions\030\002 \003(\005\""
    "\"\n\004Span\022\r\n\005begin\030\001 \002(\r\022\013\n\003end\030\002 \002(\r\"w\n\005T"
    "imex\022\r\n\005value\030\001 \001(\t\022\020\n\010altValue\030\002 \001(\t\022\014\n"
    "\004text\030\003 \001(\t\022\014\n\004type\030\004 \001(\t\022\013\n\003tid\030\005 \001(\t\022\022"
    "\n\nbeginPoint\030\006 \001(\r\022\020\n\010endPoint\030\007 \001(\r\"\333\001\n"
    "\006Entity\022\021\n\theadStart\030\006 \001(\r\022\017\n\007headEnd\030\007 "
    "\001(\r\022\023\n\013mentionType\030\010 \001(\t\022\026\n\016normalizedNa"
    "me\030\t \001(\t\022\026\n\016headTokenIndex\030\n \001(\r\022\017\n\007core"
    "fID\030\013 \001(\t\022\020\n\010objectID\030\001 \001(\t\022\023\n\013extentSta"
    "rt\030\002 \001(\r\022\021\n\textentEnd\030\003 \001(\r\022\014\n\004type\030\004 \001("
    "\t\022\017\n\007subtype\030\005 \001(\t\"\267\001\n\010Relation\022\017\n\007argNa"
    "me\030\006 \003(\t\022.\n\003arg\030\007 \003(\0132!.edu.stanford.nlp"
    ".pipeline.Entity\022\021\n\tsignature\030\010 \001(\t\022\020\n\010o"
    "bjectID\030\001 \001(\t\022\023\n\013extentStart\030\002 \001(\r\022\021\n\tex"
    "tentEnd\030\003 \001(\r\022\014\n\004type\030\004 \001(\t\022\017\n\007subtype\030\005"
    " \001(\t\"\262\001\n\010Operator\022\014\n\004name\030\001 \002(\t\022\033\n\023quant"
    "ifierSpanBegin\030\002 \002(\005\022\031\n\021quantifierSpanEn"
    "d\030\003 \002(\005\022\030\n\020subjectSpanBegin\030\004 \002(\005\022\026\n\016sub"
    "jectSpanEnd\030\005 \002(\005\022\027\n\017objectSpanBegin\030\006 \002"
    "(\005\022\025\n\robjectSpanEnd\030\007 \002(\005\"\251\004\n\010Polarity\022K"
    "\n\022projectEquivalence\030\001 \002(\0162/.edu.stanfor"
    "d.nlp.pipeline.NaturalLogicRelation\022Q\n\030p"
    "rojectForwardEntailment\030\002 \002(\0162/.edu.stan"
    "ford.nlp.pipeline.NaturalLogicRelation\022Q"
    "\n\030projectReverseEntailment\030\003 \002(\0162/.edu.s"
    "tanford.nlp.pipeline.NaturalLogicRelatio"
    "n\022H\n\017projectNegation\030\004 \002(\0162/.edu.stanfor"
    "d.nlp.pipeline.NaturalLogicRelation\022K\n\022p"
    "rojectAlternation\030\005 \002(\0162/.edu.stanford.n"
    "lp.pipeline.NaturalLogicRelation\022E\n\014proj"
    "ectCover\030\006 \002(\0162/.edu.stanford.nlp.pipeli"
    "ne.NaturalLogicRelation\022L\n\023projectIndepe"
    "ndence\030\007 \002(\0162/.edu.stanford.nlp.pipeline"
    ".NaturalLogicRelation\"\330\001\n\nNERMention\022\025\n\r"
    "sentenceIndex\030\001 \001(\r\022%\n\035tokenStartInSente"
    "nceInclusive\030\002 \002(\r\022#\n\033tokenEndInSentence"
    "Exclusive\030\003 \002(\r\022\013\n\003ner\030\004 \002(\t\022\025\n\rnormaliz"
    "edNER\030\005 \001(\t\022\022\n\nentityType\030\006 \001(\t\022/\n\005timex"
    "\030\007 \001(\0132 .edu.stanford.nlp.pipeline.Timex"
    "\"Y\n\020SentenceFragment\022\022\n\ntokenIndex\030\001 \003(\r"
    "\022\014\n\004root\030\002 \001(\r\022\024\n\014assumedTruth\030\003 \001(\010\022\r\n\005"
    "score\030\004 \001(\001\"\234\002\n\016RelationTriple\022\017\n\007subjec"
    "t\030\001 \001(\t\022\020\n\010relation\030\002 \001(\t\022\016\n\006object\030\003 \001("
    "\t\022\022\n\nconfidence\030\004 \001(\001\022\025\n\rsubjectTokens\030\005"
    " \003(\r\022\026\n\016relationTokens\030\006 \003(\r\022\024\n\014objectTo"
    "kens\030\007 \003(\r\0228\n\004tree\030\010 \001(\0132*.edu.stanford."
    "nlp.pipeline.DependencyGraph\022\016\n\006istmod\030\t"
    " \001(\010\022\020\n\010prefixBe\030\n \001(\010\022\020\n\010suffixBe\030\013 \001(\010"
    "\022\020\n\010suffixOf\030\014 \001(\010\"-\n\017MapStringString\022\013\n"
    "\003key\030\001 \003(\t\022\r\n\005value\030\002 \003(\t\"*\n\014MapIntStrin"
    "g\022\013\n\003key\030\001 \003(\r\022\r\n\005value\030\002 \003(\t*\215\001\n\010Langua"
    "ge\022\013\n\007Unknown\020\000\022\007\n\003Any\020\001\022\n\n\006Arabic\020\002\022\013\n\007"
    "Chinese\020\003\022\013\n\007English\020\004\022\n\n\006German\020\005\022\n\n\006Fr"
    "ench\020\006\022\n\n\006Hebrew\020\007\022\013\n\007Spanish\020\010\022\024\n\020Unive"
    "rsalEnglish\020\t*h\n\tSentiment\022\023\n\017STRONG_NEG"
    "ATIVE\020\000\022\021\n\rWEAK_NEGATIVE\020\001\022\013\n\007NEUTRAL\020\002\022"
    "\021\n\rWEAK_POSITIVE\020\003\022\023\n\017STRONG_POSITIVE\020\004*"
    "\223\001\n\024NaturalLogicRelation\022\017\n\013EQUIVALENCE\020"
    "\000\022\026\n\022FORWARD_ENTAILMENT\020\001\022\026\n\022REVERSE_ENT"
    "AILMENT\020\002\022\014\n\010NEGATION\020\003\022\017\n\013ALTERNATION\020\004"
    "\022\t\n\005COVER\020\005\022\020\n\014INDEPENDENCE\020\006B*\n\031edu.sta"
    "nford.nlp.pipelineB\rCoreNLPProtos", 7513);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CoreNLP.proto", &protobuf_RegisterTypes);
  Document::default_instance_ = new Document();
  Sentence::default_instance_ = new Sentence();
  Token::default_instance_ = new Token();
  Quote::default_instance_ = new Quote();
  ParseTree::default_instance_ = new ParseTree();
  DependencyGraph::default_instance_ = new DependencyGraph();
  DependencyGraph_Node::default_instance_ = new DependencyGraph_Node();
  DependencyGraph_Edge::default_instance_ = new DependencyGraph_Edge();
  CorefChain::default_instance_ = new CorefChain();
  CorefChain_CorefMention::default_instance_ = new CorefChain_CorefMention();
  Mention::default_instance_ = new Mention();
  IndexedWord::default_instance_ = new IndexedWord();
  SpeakerInfo::default_instance_ = new SpeakerInfo();
  Span::default_instance_ = new Span();
  Timex::default_instance_ = new Timex();
  Entity::default_instance_ = new Entity();
  Relation::default_instance_ = new Relation();
  Operator::default_instance_ = new Operator();
  Polarity::default_instance_ = new Polarity();
  NERMention::default_instance_ = new NERMention();
  SentenceFragment::default_instance_ = new SentenceFragment();
  RelationTriple::default_instance_ = new RelationTriple();
  MapStringString::default_instance_ = new MapStringString();
  MapIntString::default_instance_ = new MapIntString();
  Document::default_instance_->InitAsDefaultInstance();
  Sentence::default_instance_->InitAsDefaultInstance();
  Token::default_instance_->InitAsDefaultInstance();
  Quote::default_instance_->InitAsDefaultInstance();
  ParseTree::default_instance_->InitAsDefaultInstance();
  DependencyGraph::default_instance_->InitAsDefaultInstance();
  DependencyGraph_Node::default_instance_->InitAsDefaultInstance();
  DependencyGraph_Edge::default_instance_->InitAsDefaultInstance();
  CorefChain::default_instance_->InitAsDefaultInstance();
  CorefChain_CorefMention::default_instance_->InitAsDefaultInstance();
  Mention::default_instance_->InitAsDefaultInstance();
  IndexedWord::default_instance_->InitAsDefaultInstance();
  SpeakerInfo::default_instance_->InitAsDefaultInstance();
  Span::default_instance_->InitAsDefaultInstance();
  Timex::default_instance_->InitAsDefaultInstance();
  Entity::default_instance_->InitAsDefaultInstance();
  Relation::default_instance_->InitAsDefaultInstance();
  Operator::default_instance_->InitAsDefaultInstance();
  Polarity::default_instance_->InitAsDefaultInstance();
  NERMention::default_instance_->InitAsDefaultInstance();
  SentenceFragment::default_instance_->InitAsDefaultInstance();
  RelationTriple::default_instance_->InitAsDefaultInstance();
  MapStringString::default_instance_->InitAsDefaultInstance();
  MapIntString::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CoreNLP_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CoreNLP_2eproto {
  StaticDescriptorInitializer_CoreNLP_2eproto() {
    protobuf_AddDesc_CoreNLP_2eproto();
  }
} static_descriptor_initializer_CoreNLP_2eproto_;
const ::google::protobuf::EnumDescriptor* Language_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Language_descriptor_;
}
bool Language_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Sentiment_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sentiment_descriptor_;
}
bool Sentiment_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* NaturalLogicRelation_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NaturalLogicRelation_descriptor_;
}
bool NaturalLogicRelation_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Document::kTextFieldNumber;
const int Document::kSentenceFieldNumber;
const int Document::kCorefChainFieldNumber;
const int Document::kDocIDFieldNumber;
const int Document::kSentencelessTokenFieldNumber;
const int Document::kQuoteFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Document::Document()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Document)
}

void Document::InitAsDefaultInstance() {
}

Document::Document(const Document& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Document)
}

void Document::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  docid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Document::~Document() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Document)
  SharedDtor();
}

void Document::SharedDtor() {
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  docid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Document::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Document::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Document_descriptor_;
}

const Document& Document::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Document* Document::default_instance_ = NULL;

Document* Document::New(::google::protobuf::Arena* arena) const {
  Document* n = new Document;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Document::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & 9u) {
    if (has_text()) {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_docid()) {
      docid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  sentence_.Clear();
  corefchain_.Clear();
  sentencelesstoken_.Clear();
  quote_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Document::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Document)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string text = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Document.text");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sentence;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
      case 2: {
        if (tag == 18) {
         parse_sentence:
          DO_(input->IncrementRecursionDepth());
         parse_loop_sentence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_sentence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_sentence;
        if (input->ExpectTag(26)) goto parse_loop_corefChain;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_corefChain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_corefchain()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_corefChain;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(34)) goto parse_docID;
        break;
      }

      // optional string docID = 4;
      case 4: {
        if (tag == 34) {
         parse_docID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_docid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->docid().data(), this->docid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Document.docID");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_sentencelessToken;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
      case 5: {
        if (tag == 42) {
         parse_sentencelessToken:
          DO_(input->IncrementRecursionDepth());
         parse_loop_sentencelessToken:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_sentencelesstoken()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_sentencelessToken;
        if (input->ExpectTag(50)) goto parse_loop_quote;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_quote:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_quote()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_quote;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        if ((800u <= tag && tag < 2048u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Document)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Document)
  return false;
#undef DO_
}

void Document::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Document)
  // required string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Document.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->text(), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
  for (unsigned int i = 0, n = this->sentence_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->sentence(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
  for (unsigned int i = 0, n = this->corefchain_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->corefchain(i), output);
  }

  // optional string docID = 4;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Document.docID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->docid(), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
  for (unsigned int i = 0, n = this->sentencelesstoken_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->sentencelesstoken(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
  for (unsigned int i = 0, n = this->quote_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->quote(i), output);
  }

  // Extension range [100, 256)
  _extensions_.SerializeWithCachedSizes(
      100, 256, output);

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Document)
}

::google::protobuf::uint8* Document::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Document)
  // required string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Document.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->text(), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
  for (unsigned int i = 0, n = this->sentence_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->sentence(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
  for (unsigned int i = 0, n = this->corefchain_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->corefchain(i), target);
  }

  // optional string docID = 4;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Document.docID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->docid(), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
  for (unsigned int i = 0, n = this->sentencelesstoken_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->sentencelesstoken(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
  for (unsigned int i = 0, n = this->quote_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->quote(i), target);
  }

  // Extension range [100, 256)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 256, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Document)
  return target;
}

int Document::ByteSize() const {
  int total_size = 0;

  // required string text = 1;
  if (has_text()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }
  // optional string docID = 4;
  if (has_docid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->docid());
  }

  // repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
  total_size += 1 * this->sentence_size();
  for (int i = 0; i < this->sentence_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sentence(i));
  }

  // repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
  total_size += 1 * this->corefchain_size();
  for (int i = 0; i < this->corefchain_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->corefchain(i));
  }

  // repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
  total_size += 1 * this->sentencelesstoken_size();
  for (int i = 0; i < this->sentencelesstoken_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sentencelesstoken(i));
  }

  // repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
  total_size += 1 * this->quote_size();
  for (int i = 0; i < this->quote_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->quote(i));
  }

  total_size += _extensions_.ByteSize();

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Document::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Document* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Document>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Document::MergeFrom(const Document& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  sentence_.MergeFrom(from.sentence_);
  corefchain_.MergeFrom(from.corefchain_);
  sentencelesstoken_.MergeFrom(from.sentencelesstoken_);
  quote_.MergeFrom(from.quote_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_text()) {
      set_has_text();
      text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (from.has_docid()) {
      set_has_docid();
      docid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.docid_);
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Document::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Document::CopyFrom(const Document& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Document::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->sentence())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->corefchain())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->sentencelesstoken())) return false;

  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Document::Swap(Document* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Document::InternalSwap(Document* other) {
  text_.Swap(&other->text_);
  sentence_.UnsafeArenaSwap(&other->sentence_);
  corefchain_.UnsafeArenaSwap(&other->corefchain_);
  docid_.Swap(&other->docid_);
  sentencelesstoken_.UnsafeArenaSwap(&other->sentencelesstoken_);
  quote_.UnsafeArenaSwap(&other->quote_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
  _extensions_.Swap(&other->_extensions_);
}

::google::protobuf::Metadata Document::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Document_descriptor_;
  metadata.reflection = Document_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Document

// required string text = 1;
bool Document::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Document::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
void Document::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
void Document::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
 const ::std::string& Document::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Document::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Document.text)
}
 void Document::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Document.text)
}
 void Document::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Document.text)
}
 ::std::string* Document::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Document::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Document::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Document.text)
}

// repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
int Document::sentence_size() const {
  return sentence_.size();
}
void Document::clear_sentence() {
  sentence_.Clear();
}
const ::edu::stanford::nlp::pipeline::Sentence& Document::sentence(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_.Get(index);
}
::edu::stanford::nlp::pipeline::Sentence* Document::mutable_sentence(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Sentence* Document::add_sentence() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence >*
Document::mutable_sentence() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.sentence)
  return &sentence_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence >&
Document::sentence() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_;
}

// repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
int Document::corefchain_size() const {
  return corefchain_.size();
}
void Document::clear_corefchain() {
  corefchain_.Clear();
}
const ::edu::stanford::nlp::pipeline::CorefChain& Document::corefchain(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_.Get(index);
}
::edu::stanford::nlp::pipeline::CorefChain* Document::mutable_corefchain(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_.Mutable(index);
}
::edu::stanford::nlp::pipeline::CorefChain* Document::add_corefchain() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain >*
Document::mutable_corefchain() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.corefChain)
  return &corefchain_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain >&
Document::corefchain() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_;
}

// optional string docID = 4;
bool Document::has_docid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Document::set_has_docid() {
  _has_bits_[0] |= 0x00000008u;
}
void Document::clear_has_docid() {
  _has_bits_[0] &= ~0x00000008u;
}
void Document::clear_docid() {
  docid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docid();
}
 const ::std::string& Document::docid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.docID)
  return docid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Document::set_docid(const ::std::string& value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Document.docID)
}
 void Document::set_docid(const char* value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Document.docID)
}
 void Document::set_docid(const char* value, size_t size) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Document.docID)
}
 ::std::string* Document::mutable_docid() {
  set_has_docid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.docID)
  return docid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Document::release_docid() {
  clear_has_docid();
  return docid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Document::set_allocated_docid(::std::string* docid) {
  if (docid != NULL) {
    set_has_docid();
  } else {
    clear_has_docid();
  }
  docid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Document.docID)
}

// repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
int Document::sentencelesstoken_size() const {
  return sentencelesstoken_.size();
}
void Document::clear_sentencelesstoken() {
  sentencelesstoken_.Clear();
}
const ::edu::stanford::nlp::pipeline::Token& Document::sentencelesstoken(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_.Get(index);
}
::edu::stanford::nlp::pipeline::Token* Document::mutable_sentencelesstoken(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Token* Document::add_sentencelesstoken() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >*
Document::mutable_sentencelesstoken() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return &sentencelesstoken_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >&
Document::sentencelesstoken() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_;
}

// repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
int Document::quote_size() const {
  return quote_.size();
}
void Document::clear_quote() {
  quote_.Clear();
}
const ::edu::stanford::nlp::pipeline::Quote& Document::quote(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.quote)
  return quote_.Get(index);
}
::edu::stanford::nlp::pipeline::Quote* Document::mutable_quote(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.quote)
  return quote_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Quote* Document::add_quote() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.quote)
  return quote_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote >*
Document::mutable_quote() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.quote)
  return &quote_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote >&
Document::quote() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.quote)
  return quote_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Sentence::kTokenFieldNumber;
const int Sentence::kTokenOffsetBeginFieldNumber;
const int Sentence::kTokenOffsetEndFieldNumber;
const int Sentence::kSentenceIndexFieldNumber;
const int Sentence::kCharacterOffsetBeginFieldNumber;
const int Sentence::kCharacterOffsetEndFieldNumber;
const int Sentence::kParseTreeFieldNumber;
const int Sentence::kBinarizedParseTreeFieldNumber;
const int Sentence::kAnnotatedParseTreeFieldNumber;
const int Sentence::kSentimentFieldNumber;
const int Sentence::kKBestParseTreesFieldNumber;
const int Sentence::kBasicDependenciesFieldNumber;
const int Sentence::kCollapsedDependenciesFieldNumber;
const int Sentence::kCollapsedCCProcessedDependenciesFieldNumber;
const int Sentence::kAlternativeDependenciesFieldNumber;
const int Sentence::kOpenieTripleFieldNumber;
const int Sentence::kKbpTripleFieldNumber;
const int Sentence::kEntailedSentenceFieldNumber;
const int Sentence::kParagraphFieldNumber;
const int Sentence::kTextFieldNumber;
const int Sentence::kHasRelationAnnotationsFieldNumber;
const int Sentence::kEntityFieldNumber;
const int Sentence::kRelationFieldNumber;
const int Sentence::kHasNumerizedTokensAnnotationFieldNumber;
const int Sentence::kMentionsFieldNumber;
const int Sentence::kMentionsForCorefFieldNumber;
const int Sentence::kHasCorefMentionsAnnotationFieldNumber;
const int Sentence::kSentenceIDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Sentence::Sentence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Sentence)
}

void Sentence::InitAsDefaultInstance() {
  parsetree_ = const_cast< ::edu::stanford::nlp::pipeline::ParseTree*>(&::edu::stanford::nlp::pipeline::ParseTree::default_instance());
  binarizedparsetree_ = const_cast< ::edu::stanford::nlp::pipeline::ParseTree*>(&::edu::stanford::nlp::pipeline::ParseTree::default_instance());
  annotatedparsetree_ = const_cast< ::edu::stanford::nlp::pipeline::ParseTree*>(&::edu::stanford::nlp::pipeline::ParseTree::default_instance());
  basicdependencies_ = const_cast< ::edu::stanford::nlp::pipeline::DependencyGraph*>(&::edu::stanford::nlp::pipeline::DependencyGraph::default_instance());
  collapseddependencies_ = const_cast< ::edu::stanford::nlp::pipeline::DependencyGraph*>(&::edu::stanford::nlp::pipeline::DependencyGraph::default_instance());
  collapsedccprocesseddependencies_ = const_cast< ::edu::stanford::nlp::pipeline::DependencyGraph*>(&::edu::stanford::nlp::pipeline::DependencyGraph::default_instance());
  alternativedependencies_ = const_cast< ::edu::stanford::nlp::pipeline::DependencyGraph*>(&::edu::stanford::nlp::pipeline::DependencyGraph::default_instance());
}

Sentence::Sentence(const Sentence& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Sentence)
}

void Sentence::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  tokenoffsetbegin_ = 0u;
  tokenoffsetend_ = 0u;
  sentenceindex_ = 0u;
  characteroffsetbegin_ = 0u;
  characteroffsetend_ = 0u;
  parsetree_ = NULL;
  binarizedparsetree_ = NULL;
  annotatedparsetree_ = NULL;
  sentiment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  basicdependencies_ = NULL;
  collapseddependencies_ = NULL;
  collapsedccprocesseddependencies_ = NULL;
  alternativedependencies_ = NULL;
  paragraph_ = 0u;
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hasrelationannotations_ = false;
  hasnumerizedtokensannotation_ = false;
  hascorefmentionsannotation_ = false;
  sentenceid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sentence::~Sentence() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Sentence)
  SharedDtor();
}

void Sentence::SharedDtor() {
  sentiment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sentenceid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete parsetree_;
    delete binarizedparsetree_;
    delete annotatedparsetree_;
    delete basicdependencies_;
    delete collapseddependencies_;
    delete collapsedccprocesseddependencies_;
    delete alternativedependencies_;
  }
}

void Sentence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sentence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sentence_descriptor_;
}

const Sentence& Sentence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Sentence* Sentence::default_instance_ = NULL;

Sentence* Sentence::New(::google::protobuf::Arena* arena) const {
  Sentence* n = new Sentence;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Sentence::Clear() {
  _extensions_.Clear();
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Sentence*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 254u) {
    ZR_(tokenoffsetbegin_, characteroffsetbegin_);
    characteroffsetend_ = 0u;
    if (has_parsetree()) {
      if (parsetree_ != NULL) parsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
    }
    if (has_binarizedparsetree()) {
      if (binarizedparsetree_ != NULL) binarizedparsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 31488u) {
    if (has_annotatedparsetree()) {
      if (annotatedparsetree_ != NULL) annotatedparsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
    }
    if (has_sentiment()) {
      sentiment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_basicdependencies()) {
      if (basicdependencies_ != NULL) basicdependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
    }
    if (has_collapseddependencies()) {
      if (collapseddependencies_ != NULL) collapseddependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
    }
    if (has_collapsedccprocesseddependencies()) {
      if (collapsedccprocesseddependencies_ != NULL) collapsedccprocesseddependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
    }
    if (has_alternativedependencies()) {
      if (alternativedependencies_ != NULL) alternativedependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 10223616u) {
    ZR_(hasrelationannotations_, hasnumerizedtokensannotation_);
    paragraph_ = 0u;
    if (has_text()) {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[24 / 32] & 201326592u) {
    hascorefmentionsannotation_ = false;
    if (has_sentenceid()) {
      sentenceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  token_.Clear();
  kbestparsetrees_.Clear();
  openietriple_.Clear();
  kbptriple_.Clear();
  entailedsentence_.Clear();
  entity_.Clear();
  relation_.Clear();
  mentions_.Clear();
  mentionsforcoref_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Sentence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Sentence)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .edu.stanford.nlp.pipeline.Token token = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_token;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_tokenOffsetBegin;
        break;
      }

      // required uint32 tokenOffsetBegin = 2;
      case 2: {
        if (tag == 16) {
         parse_tokenOffsetBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenoffsetbegin_)));
          set_has_tokenoffsetbegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_tokenOffsetEnd;
        break;
      }

      // required uint32 tokenOffsetEnd = 3;
      case 3: {
        if (tag == 24) {
         parse_tokenOffsetEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenoffsetend_)));
          set_has_tokenoffsetend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_sentenceIndex;
        break;
      }

      // optional uint32 sentenceIndex = 4;
      case 4: {
        if (tag == 32) {
         parse_sentenceIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentenceindex_)));
          set_has_sentenceindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_characterOffsetBegin;
        break;
      }

      // optional uint32 characterOffsetBegin = 5;
      case 5: {
        if (tag == 40) {
         parse_characterOffsetBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &characteroffsetbegin_)));
          set_has_characteroffsetbegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_characterOffsetEnd;
        break;
      }

      // optional uint32 characterOffsetEnd = 6;
      case 6: {
        if (tag == 48) {
         parse_characterOffsetEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &characteroffsetend_)));
          set_has_characteroffsetend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_parseTree;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
      case 7: {
        if (tag == 58) {
         parse_parseTree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parsetree()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_basicDependencies;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
      case 8: {
        if (tag == 66) {
         parse_basicDependencies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_basicdependencies()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_collapsedDependencies;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
      case 9: {
        if (tag == 74) {
         parse_collapsedDependencies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collapseddependencies()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_collapsedCCProcessedDependencies;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
      case 10: {
        if (tag == 82) {
         parse_collapsedCCProcessedDependencies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_collapsedccprocesseddependencies()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_paragraph;
        break;
      }

      // optional uint32 paragraph = 11;
      case 11: {
        if (tag == 88) {
         parse_paragraph:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &paragraph_)));
          set_has_paragraph();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_text;
        break;
      }

      // optional string text = 12;
      case 12: {
        if (tag == 98) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Sentence.text");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_alternativeDependencies;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
      case 13: {
        if (tag == 106) {
         parse_alternativeDependencies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alternativedependencies()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_openieTriple;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
      case 14: {
        if (tag == 114) {
         parse_openieTriple:
          DO_(input->IncrementRecursionDepth());
         parse_loop_openieTriple:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_openietriple()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_loop_openieTriple;
        if (input->ExpectTag(122)) goto parse_loop_entailedSentence;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
      case 15: {
        if (tag == 122) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_entailedSentence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_entailedsentence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_loop_entailedSentence;
        if (input->ExpectTag(130)) goto parse_loop_kbpTriple;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
      case 16: {
        if (tag == 130) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_kbpTriple:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_kbptriple()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_loop_kbpTriple;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(250)) goto parse_binarizedParseTree;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
      case 31: {
        if (tag == 250) {
         parse_binarizedParseTree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_binarizedparsetree()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_annotatedParseTree;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
      case 32: {
        if (tag == 258) {
         parse_annotatedParseTree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_annotatedparsetree()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(266)) goto parse_sentiment;
        break;
      }

      // optional string sentiment = 33;
      case 33: {
        if (tag == 266) {
         parse_sentiment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sentiment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sentiment().data(), this->sentiment().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Sentence.sentiment");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(274)) goto parse_kBestParseTrees;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
      case 34: {
        if (tag == 274) {
         parse_kBestParseTrees:
          DO_(input->IncrementRecursionDepth());
         parse_loop_kBestParseTrees:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_kbestparsetrees()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(274)) goto parse_loop_kBestParseTrees;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(408)) goto parse_hasRelationAnnotations;
        break;
      }

      // optional bool hasRelationAnnotations = 51;
      case 51: {
        if (tag == 408) {
         parse_hasRelationAnnotations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hasrelationannotations_)));
          set_has_hasrelationannotations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(418)) goto parse_entity;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
      case 52: {
        if (tag == 418) {
         parse_entity:
          DO_(input->IncrementRecursionDepth());
         parse_loop_entity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_entity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(418)) goto parse_loop_entity;
        if (input->ExpectTag(426)) goto parse_loop_relation;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
      case 53: {
        if (tag == 426) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_relation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_relation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(426)) goto parse_loop_relation;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(432)) goto parse_hasNumerizedTokensAnnotation;
        break;
      }

      // optional bool hasNumerizedTokensAnnotation = 54;
      case 54: {
        if (tag == 432) {
         parse_hasNumerizedTokensAnnotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hasnumerizedtokensannotation_)));
          set_has_hasnumerizedtokensannotation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(442)) goto parse_mentions;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
      case 55: {
        if (tag == 442) {
         parse_mentions:
          DO_(input->IncrementRecursionDepth());
         parse_loop_mentions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mentions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(442)) goto parse_loop_mentions;
        if (input->ExpectTag(450)) goto parse_loop_mentionsForCoref;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
      case 56: {
        if (tag == 450) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_mentionsForCoref:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mentionsforcoref()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(450)) goto parse_loop_mentionsForCoref;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(456)) goto parse_hasCorefMentionsAnnotation;
        break;
      }

      // optional bool hasCorefMentionsAnnotation = 57;
      case 57: {
        if (tag == 456) {
         parse_hasCorefMentionsAnnotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hascorefmentionsannotation_)));
          set_has_hascorefmentionsannotation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(466)) goto parse_sentenceID;
        break;
      }

      // optional string sentenceID = 58;
      case 58: {
        if (tag == 466) {
         parse_sentenceID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sentenceid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sentenceid().data(), this->sentenceid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Sentence.sentenceID");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        if ((800u <= tag && tag < 2048u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Sentence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Sentence)
  return false;
#undef DO_
}

void Sentence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Sentence)
  // repeated .edu.stanford.nlp.pipeline.Token token = 1;
  for (unsigned int i = 0, n = this->token_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->token(i), output);
  }

  // required uint32 tokenOffsetBegin = 2;
  if (has_tokenoffsetbegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tokenoffsetbegin(), output);
  }

  // required uint32 tokenOffsetEnd = 3;
  if (has_tokenoffsetend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->tokenoffsetend(), output);
  }

  // optional uint32 sentenceIndex = 4;
  if (has_sentenceindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->sentenceindex(), output);
  }

  // optional uint32 characterOffsetBegin = 5;
  if (has_characteroffsetbegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->characteroffsetbegin(), output);
  }

  // optional uint32 characterOffsetEnd = 6;
  if (has_characteroffsetend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->characteroffsetend(), output);
  }

  // optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
  if (has_parsetree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->parsetree_, output);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
  if (has_basicdependencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->basicdependencies_, output);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
  if (has_collapseddependencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->collapseddependencies_, output);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
  if (has_collapsedccprocesseddependencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->collapsedccprocesseddependencies_, output);
  }

  // optional uint32 paragraph = 11;
  if (has_paragraph()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->paragraph(), output);
  }

  // optional string text = 12;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Sentence.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->text(), output);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
  if (has_alternativedependencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->alternativedependencies_, output);
  }

  // repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
  for (unsigned int i = 0, n = this->openietriple_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->openietriple(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
  for (unsigned int i = 0, n = this->entailedsentence_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->entailedsentence(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
  for (unsigned int i = 0, n = this->kbptriple_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->kbptriple(i), output);
  }

  // optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
  if (has_binarizedparsetree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      31, *this->binarizedparsetree_, output);
  }

  // optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
  if (has_annotatedparsetree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, *this->annotatedparsetree_, output);
  }

  // optional string sentiment = 33;
  if (has_sentiment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sentiment().data(), this->sentiment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Sentence.sentiment");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      33, this->sentiment(), output);
  }

  // repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
  for (unsigned int i = 0, n = this->kbestparsetrees_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, this->kbestparsetrees(i), output);
  }

  // optional bool hasRelationAnnotations = 51;
  if (has_hasrelationannotations()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(51, this->hasrelationannotations(), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
  for (unsigned int i = 0, n = this->entity_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      52, this->entity(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
  for (unsigned int i = 0, n = this->relation_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      53, this->relation(i), output);
  }

  // optional bool hasNumerizedTokensAnnotation = 54;
  if (has_hasnumerizedtokensannotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(54, this->hasnumerizedtokensannotation(), output);
  }

  // repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
  for (unsigned int i = 0, n = this->mentions_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      55, this->mentions(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
  for (unsigned int i = 0, n = this->mentionsforcoref_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      56, this->mentionsforcoref(i), output);
  }

  // optional bool hasCorefMentionsAnnotation = 57;
  if (has_hascorefmentionsannotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(57, this->hascorefmentionsannotation(), output);
  }

  // optional string sentenceID = 58;
  if (has_sentenceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sentenceid().data(), this->sentenceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Sentence.sentenceID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      58, this->sentenceid(), output);
  }

  // Extension range [100, 256)
  _extensions_.SerializeWithCachedSizes(
      100, 256, output);

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Sentence)
}

::google::protobuf::uint8* Sentence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Sentence)
  // repeated .edu.stanford.nlp.pipeline.Token token = 1;
  for (unsigned int i = 0, n = this->token_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->token(i), target);
  }

  // required uint32 tokenOffsetBegin = 2;
  if (has_tokenoffsetbegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->tokenoffsetbegin(), target);
  }

  // required uint32 tokenOffsetEnd = 3;
  if (has_tokenoffsetend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->tokenoffsetend(), target);
  }

  // optional uint32 sentenceIndex = 4;
  if (has_sentenceindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->sentenceindex(), target);
  }

  // optional uint32 characterOffsetBegin = 5;
  if (has_characteroffsetbegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->characteroffsetbegin(), target);
  }

  // optional uint32 characterOffsetEnd = 6;
  if (has_characteroffsetend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->characteroffsetend(), target);
  }

  // optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
  if (has_parsetree()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->parsetree_, target);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
  if (has_basicdependencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->basicdependencies_, target);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
  if (has_collapseddependencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->collapseddependencies_, target);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
  if (has_collapsedccprocesseddependencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *this->collapsedccprocesseddependencies_, target);
  }

  // optional uint32 paragraph = 11;
  if (has_paragraph()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->paragraph(), target);
  }

  // optional string text = 12;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Sentence.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->text(), target);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
  if (has_alternativedependencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *this->alternativedependencies_, target);
  }

  // repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
  for (unsigned int i = 0, n = this->openietriple_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->openietriple(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
  for (unsigned int i = 0, n = this->entailedsentence_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->entailedsentence(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
  for (unsigned int i = 0, n = this->kbptriple_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, this->kbptriple(i), target);
  }

  // optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
  if (has_binarizedparsetree()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        31, *this->binarizedparsetree_, target);
  }

  // optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
  if (has_annotatedparsetree()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        32, *this->annotatedparsetree_, target);
  }

  // optional string sentiment = 33;
  if (has_sentiment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sentiment().data(), this->sentiment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Sentence.sentiment");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        33, this->sentiment(), target);
  }

  // repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
  for (unsigned int i = 0, n = this->kbestparsetrees_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        34, this->kbestparsetrees(i), target);
  }

  // optional bool hasRelationAnnotations = 51;
  if (has_hasrelationannotations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(51, this->hasrelationannotations(), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
  for (unsigned int i = 0, n = this->entity_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        52, this->entity(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
  for (unsigned int i = 0, n = this->relation_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        53, this->relation(i), target);
  }

  // optional bool hasNumerizedTokensAnnotation = 54;
  if (has_hasnumerizedtokensannotation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(54, this->hasnumerizedtokensannotation(), target);
  }

  // repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
  for (unsigned int i = 0, n = this->mentions_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        55, this->mentions(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
  for (unsigned int i = 0, n = this->mentionsforcoref_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        56, this->mentionsforcoref(i), target);
  }

  // optional bool hasCorefMentionsAnnotation = 57;
  if (has_hascorefmentionsannotation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(57, this->hascorefmentionsannotation(), target);
  }

  // optional string sentenceID = 58;
  if (has_sentenceid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sentenceid().data(), this->sentenceid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Sentence.sentenceID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        58, this->sentenceid(), target);
  }

  // Extension range [100, 256)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 256, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Sentence)
  return target;
}

int Sentence::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_tokenoffsetbegin()) {
    // required uint32 tokenOffsetBegin = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenoffsetbegin());
  }

  if (has_tokenoffsetend()) {
    // required uint32 tokenOffsetEnd = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenoffsetend());
  }

  return total_size;
}
int Sentence::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 tokenOffsetBegin = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenoffsetbegin());

    // required uint32 tokenOffsetEnd = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenoffsetend());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 248u) {
    // optional uint32 sentenceIndex = 4;
    if (has_sentenceindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentenceindex());
    }

    // optional uint32 characterOffsetBegin = 5;
    if (has_characteroffsetbegin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->characteroffsetbegin());
    }

    // optional uint32 characterOffsetEnd = 6;
    if (has_characteroffsetend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->characteroffsetend());
    }

    // optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
    if (has_parsetree()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->parsetree_);
    }

    // optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
    if (has_binarizedparsetree()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->binarizedparsetree_);
    }

  }
  if (_has_bits_[8 / 32] & 31488u) {
    // optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
    if (has_annotatedparsetree()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->annotatedparsetree_);
    }

    // optional string sentiment = 33;
    if (has_sentiment()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sentiment());
    }

    // optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
    if (has_basicdependencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->basicdependencies_);
    }

    // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
    if (has_collapseddependencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->collapseddependencies_);
    }

    // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
    if (has_collapsedccprocesseddependencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->collapsedccprocesseddependencies_);
    }

    // optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
    if (has_alternativedependencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->alternativedependencies_);
    }

  }
  if (_has_bits_[18 / 32] & 10223616u) {
    // optional uint32 paragraph = 11;
    if (has_paragraph()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->paragraph());
    }

    // optional string text = 12;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional bool hasRelationAnnotations = 51;
    if (has_hasrelationannotations()) {
      total_size += 2 + 1;
    }

    // optional bool hasNumerizedTokensAnnotation = 54;
    if (has_hasnumerizedtokensannotation()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[26 / 32] & 201326592u) {
    // optional bool hasCorefMentionsAnnotation = 57;
    if (has_hascorefmentionsannotation()) {
      total_size += 2 + 1;
    }

    // optional string sentenceID = 58;
    if (has_sentenceid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sentenceid());
    }

  }
  // repeated .edu.stanford.nlp.pipeline.Token token = 1;
  total_size += 1 * this->token_size();
  for (int i = 0; i < this->token_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->token(i));
  }

  // repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
  total_size += 2 * this->kbestparsetrees_size();
  for (int i = 0; i < this->kbestparsetrees_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->kbestparsetrees(i));
  }

  // repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
  total_size += 1 * this->openietriple_size();
  for (int i = 0; i < this->openietriple_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->openietriple(i));
  }

  // repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
  total_size += 2 * this->kbptriple_size();
  for (int i = 0; i < this->kbptriple_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->kbptriple(i));
  }

  // repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
  total_size += 1 * this->entailedsentence_size();
  for (int i = 0; i < this->entailedsentence_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entailedsentence(i));
  }

  // repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
  total_size += 2 * this->entity_size();
  for (int i = 0; i < this->entity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entity(i));
  }

  // repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
  total_size += 2 * this->relation_size();
  for (int i = 0; i < this->relation_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->relation(i));
  }

  // repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
  total_size += 2 * this->mentions_size();
  for (int i = 0; i < this->mentions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mentions(i));
  }

  // repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
  total_size += 2 * this->mentionsforcoref_size();
  for (int i = 0; i < this->mentionsforcoref_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mentionsforcoref(i));
  }

  total_size += _extensions_.ByteSize();

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sentence::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Sentence* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Sentence>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sentence::MergeFrom(const Sentence& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  token_.MergeFrom(from.token_);
  kbestparsetrees_.MergeFrom(from.kbestparsetrees_);
  openietriple_.MergeFrom(from.openietriple_);
  kbptriple_.MergeFrom(from.kbptriple_);
  entailedsentence_.MergeFrom(from.entailedsentence_);
  entity_.MergeFrom(from.entity_);
  relation_.MergeFrom(from.relation_);
  mentions_.MergeFrom(from.mentions_);
  mentionsforcoref_.MergeFrom(from.mentionsforcoref_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_tokenoffsetbegin()) {
      set_tokenoffsetbegin(from.tokenoffsetbegin());
    }
    if (from.has_tokenoffsetend()) {
      set_tokenoffsetend(from.tokenoffsetend());
    }
    if (from.has_sentenceindex()) {
      set_sentenceindex(from.sentenceindex());
    }
    if (from.has_characteroffsetbegin()) {
      set_characteroffsetbegin(from.characteroffsetbegin());
    }
    if (from.has_characteroffsetend()) {
      set_characteroffsetend(from.characteroffsetend());
    }
    if (from.has_parsetree()) {
      mutable_parsetree()->::edu::stanford::nlp::pipeline::ParseTree::MergeFrom(from.parsetree());
    }
    if (from.has_binarizedparsetree()) {
      mutable_binarizedparsetree()->::edu::stanford::nlp::pipeline::ParseTree::MergeFrom(from.binarizedparsetree());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_annotatedparsetree()) {
      mutable_annotatedparsetree()->::edu::stanford::nlp::pipeline::ParseTree::MergeFrom(from.annotatedparsetree());
    }
    if (from.has_sentiment()) {
      set_has_sentiment();
      sentiment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sentiment_);
    }
    if (from.has_basicdependencies()) {
      mutable_basicdependencies()->::edu::stanford::nlp::pipeline::DependencyGraph::MergeFrom(from.basicdependencies());
    }
    if (from.has_collapseddependencies()) {
      mutable_collapseddependencies()->::edu::stanford::nlp::pipeline::DependencyGraph::MergeFrom(from.collapseddependencies());
    }
    if (from.has_collapsedccprocesseddependencies()) {
      mutable_collapsedccprocesseddependencies()->::edu::stanford::nlp::pipeline::DependencyGraph::MergeFrom(from.collapsedccprocesseddependencies());
    }
    if (from.has_alternativedependencies()) {
      mutable_alternativedependencies()->::edu::stanford::nlp::pipeline::DependencyGraph::MergeFrom(from.alternativedependencies());
    }
  }
  if (from._has_bits_[18 / 32] & (0xffu << (18 % 32))) {
    if (from.has_paragraph()) {
      set_paragraph(from.paragraph());
    }
    if (from.has_text()) {
      set_has_text();
      text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (from.has_hasrelationannotations()) {
      set_hasrelationannotations(from.hasrelationannotations());
    }
    if (from.has_hasnumerizedtokensannotation()) {
      set_hasnumerizedtokensannotation(from.hasnumerizedtokensannotation());
    }
  }
  if (from._has_bits_[26 / 32] & (0xffu << (26 % 32))) {
    if (from.has_hascorefmentionsannotation()) {
      set_hascorefmentionsannotation(from.hascorefmentionsannotation());
    }
    if (from.has_sentenceid()) {
      set_has_sentenceid();
      sentenceid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sentenceid_);
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Sentence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sentence::CopyFrom(const Sentence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sentence::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->token())) return false;
  if (has_basicdependencies()) {
    if (!this->basicdependencies_->IsInitialized()) return false;
  }
  if (has_collapseddependencies()) {
    if (!this->collapseddependencies_->IsInitialized()) return false;
  }
  if (has_collapsedccprocesseddependencies()) {
    if (!this->collapsedccprocesseddependencies_->IsInitialized()) return false;
  }
  if (has_alternativedependencies()) {
    if (!this->alternativedependencies_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->openietriple())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->kbptriple())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->mentions())) return false;

  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Sentence::Swap(Sentence* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Sentence::InternalSwap(Sentence* other) {
  token_.UnsafeArenaSwap(&other->token_);
  std::swap(tokenoffsetbegin_, other->tokenoffsetbegin_);
  std::swap(tokenoffsetend_, other->tokenoffsetend_);
  std::swap(sentenceindex_, other->sentenceindex_);
  std::swap(characteroffsetbegin_, other->characteroffsetbegin_);
  std::swap(characteroffsetend_, other->characteroffsetend_);
  std::swap(parsetree_, other->parsetree_);
  std::swap(binarizedparsetree_, other->binarizedparsetree_);
  std::swap(annotatedparsetree_, other->annotatedparsetree_);
  sentiment_.Swap(&other->sentiment_);
  kbestparsetrees_.UnsafeArenaSwap(&other->kbestparsetrees_);
  std::swap(basicdependencies_, other->basicdependencies_);
  std::swap(collapseddependencies_, other->collapseddependencies_);
  std::swap(collapsedccprocesseddependencies_, other->collapsedccprocesseddependencies_);
  std::swap(alternativedependencies_, other->alternativedependencies_);
  openietriple_.UnsafeArenaSwap(&other->openietriple_);
  kbptriple_.UnsafeArenaSwap(&other->kbptriple_);
  entailedsentence_.UnsafeArenaSwap(&other->entailedsentence_);
  std::swap(paragraph_, other->paragraph_);
  text_.Swap(&other->text_);
  std::swap(hasrelationannotations_, other->hasrelationannotations_);
  entity_.UnsafeArenaSwap(&other->entity_);
  relation_.UnsafeArenaSwap(&other->relation_);
  std::swap(hasnumerizedtokensannotation_, other->hasnumerizedtokensannotation_);
  mentions_.UnsafeArenaSwap(&other->mentions_);
  mentionsforcoref_.UnsafeArenaSwap(&other->mentionsforcoref_);
  std::swap(hascorefmentionsannotation_, other->hascorefmentionsannotation_);
  sentenceid_.Swap(&other->sentenceid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
  _extensions_.Swap(&other->_extensions_);
}

::google::protobuf::Metadata Sentence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sentence_descriptor_;
  metadata.reflection = Sentence_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Sentence

// repeated .edu.stanford.nlp.pipeline.Token token = 1;
int Sentence::token_size() const {
  return token_.size();
}
void Sentence::clear_token() {
  token_.Clear();
}
const ::edu::stanford::nlp::pipeline::Token& Sentence::token(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.token)
  return token_.Get(index);
}
::edu::stanford::nlp::pipeline::Token* Sentence::mutable_token(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.token)
  return token_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Token* Sentence::add_token() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.token)
  return token_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >*
Sentence::mutable_token() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.token)
  return &token_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >&
Sentence::token() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.token)
  return token_;
}

// required uint32 tokenOffsetBegin = 2;
bool Sentence::has_tokenoffsetbegin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Sentence::set_has_tokenoffsetbegin() {
  _has_bits_[0] |= 0x00000002u;
}
void Sentence::clear_has_tokenoffsetbegin() {
  _has_bits_[0] &= ~0x00000002u;
}
void Sentence::clear_tokenoffsetbegin() {
  tokenoffsetbegin_ = 0u;
  clear_has_tokenoffsetbegin();
}
 ::google::protobuf::uint32 Sentence::tokenoffsetbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.tokenOffsetBegin)
  return tokenoffsetbegin_;
}
 void Sentence::set_tokenoffsetbegin(::google::protobuf::uint32 value) {
  set_has_tokenoffsetbegin();
  tokenoffsetbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.tokenOffsetBegin)
}

// required uint32 tokenOffsetEnd = 3;
bool Sentence::has_tokenoffsetend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Sentence::set_has_tokenoffsetend() {
  _has_bits_[0] |= 0x00000004u;
}
void Sentence::clear_has_tokenoffsetend() {
  _has_bits_[0] &= ~0x00000004u;
}
void Sentence::clear_tokenoffsetend() {
  tokenoffsetend_ = 0u;
  clear_has_tokenoffsetend();
}
 ::google::protobuf::uint32 Sentence::tokenoffsetend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.tokenOffsetEnd)
  return tokenoffsetend_;
}
 void Sentence::set_tokenoffsetend(::google::protobuf::uint32 value) {
  set_has_tokenoffsetend();
  tokenoffsetend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.tokenOffsetEnd)
}

// optional uint32 sentenceIndex = 4;
bool Sentence::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Sentence::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000008u;
}
void Sentence::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000008u;
}
void Sentence::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
 ::google::protobuf::uint32 Sentence::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.sentenceIndex)
  return sentenceindex_;
}
 void Sentence::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.sentenceIndex)
}

// optional uint32 characterOffsetBegin = 5;
bool Sentence::has_characteroffsetbegin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Sentence::set_has_characteroffsetbegin() {
  _has_bits_[0] |= 0x00000010u;
}
void Sentence::clear_has_characteroffsetbegin() {
  _has_bits_[0] &= ~0x00000010u;
}
void Sentence::clear_characteroffsetbegin() {
  characteroffsetbegin_ = 0u;
  clear_has_characteroffsetbegin();
}
 ::google::protobuf::uint32 Sentence::characteroffsetbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.characterOffsetBegin)
  return characteroffsetbegin_;
}
 void Sentence::set_characteroffsetbegin(::google::protobuf::uint32 value) {
  set_has_characteroffsetbegin();
  characteroffsetbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.characterOffsetBegin)
}

// optional uint32 characterOffsetEnd = 6;
bool Sentence::has_characteroffsetend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Sentence::set_has_characteroffsetend() {
  _has_bits_[0] |= 0x00000020u;
}
void Sentence::clear_has_characteroffsetend() {
  _has_bits_[0] &= ~0x00000020u;
}
void Sentence::clear_characteroffsetend() {
  characteroffsetend_ = 0u;
  clear_has_characteroffsetend();
}
 ::google::protobuf::uint32 Sentence::characteroffsetend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.characterOffsetEnd)
  return characteroffsetend_;
}
 void Sentence::set_characteroffsetend(::google::protobuf::uint32 value) {
  set_has_characteroffsetend();
  characteroffsetend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.characterOffsetEnd)
}

// optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
bool Sentence::has_parsetree() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Sentence::set_has_parsetree() {
  _has_bits_[0] |= 0x00000040u;
}
void Sentence::clear_has_parsetree() {
  _has_bits_[0] &= ~0x00000040u;
}
void Sentence::clear_parsetree() {
  if (parsetree_ != NULL) parsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
  clear_has_parsetree();
}
const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::parsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.parseTree)
  return parsetree_ != NULL ? *parsetree_ : *default_instance_->parsetree_;
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_parsetree() {
  set_has_parsetree();
  if (parsetree_ == NULL) {
    parsetree_ = new ::edu::stanford::nlp::pipeline::ParseTree;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.parseTree)
  return parsetree_;
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::release_parsetree() {
  clear_has_parsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* temp = parsetree_;
  parsetree_ = NULL;
  return temp;
}
void Sentence::set_allocated_parsetree(::edu::stanford::nlp::pipeline::ParseTree* parsetree) {
  delete parsetree_;
  parsetree_ = parsetree;
  if (parsetree) {
    set_has_parsetree();
  } else {
    clear_has_parsetree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.parseTree)
}

// optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
bool Sentence::has_binarizedparsetree() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Sentence::set_has_binarizedparsetree() {
  _has_bits_[0] |= 0x00000080u;
}
void Sentence::clear_has_binarizedparsetree() {
  _has_bits_[0] &= ~0x00000080u;
}
void Sentence::clear_binarizedparsetree() {
  if (binarizedparsetree_ != NULL) binarizedparsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
  clear_has_binarizedparsetree();
}
const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::binarizedparsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.binarizedParseTree)
  return binarizedparsetree_ != NULL ? *binarizedparsetree_ : *default_instance_->binarizedparsetree_;
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_binarizedparsetree() {
  set_has_binarizedparsetree();
  if (binarizedparsetree_ == NULL) {
    binarizedparsetree_ = new ::edu::stanford::nlp::pipeline::ParseTree;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.binarizedParseTree)
  return binarizedparsetree_;
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::release_binarizedparsetree() {
  clear_has_binarizedparsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* temp = binarizedparsetree_;
  binarizedparsetree_ = NULL;
  return temp;
}
void Sentence::set_allocated_binarizedparsetree(::edu::stanford::nlp::pipeline::ParseTree* binarizedparsetree) {
  delete binarizedparsetree_;
  binarizedparsetree_ = binarizedparsetree;
  if (binarizedparsetree) {
    set_has_binarizedparsetree();
  } else {
    clear_has_binarizedparsetree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.binarizedParseTree)
}

// optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
bool Sentence::has_annotatedparsetree() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Sentence::set_has_annotatedparsetree() {
  _has_bits_[0] |= 0x00000100u;
}
void Sentence::clear_has_annotatedparsetree() {
  _has_bits_[0] &= ~0x00000100u;
}
void Sentence::clear_annotatedparsetree() {
  if (annotatedparsetree_ != NULL) annotatedparsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
  clear_has_annotatedparsetree();
}
const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::annotatedparsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.annotatedParseTree)
  return annotatedparsetree_ != NULL ? *annotatedparsetree_ : *default_instance_->annotatedparsetree_;
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_annotatedparsetree() {
  set_has_annotatedparsetree();
  if (annotatedparsetree_ == NULL) {
    annotatedparsetree_ = new ::edu::stanford::nlp::pipeline::ParseTree;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.annotatedParseTree)
  return annotatedparsetree_;
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::release_annotatedparsetree() {
  clear_has_annotatedparsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* temp = annotatedparsetree_;
  annotatedparsetree_ = NULL;
  return temp;
}
void Sentence::set_allocated_annotatedparsetree(::edu::stanford::nlp::pipeline::ParseTree* annotatedparsetree) {
  delete annotatedparsetree_;
  annotatedparsetree_ = annotatedparsetree;
  if (annotatedparsetree) {
    set_has_annotatedparsetree();
  } else {
    clear_has_annotatedparsetree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.annotatedParseTree)
}

// optional string sentiment = 33;
bool Sentence::has_sentiment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Sentence::set_has_sentiment() {
  _has_bits_[0] |= 0x00000200u;
}
void Sentence::clear_has_sentiment() {
  _has_bits_[0] &= ~0x00000200u;
}
void Sentence::clear_sentiment() {
  sentiment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentiment();
}
 const ::std::string& Sentence::sentiment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.sentiment)
  return sentiment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sentence::set_sentiment(const ::std::string& value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.sentiment)
}
 void Sentence::set_sentiment(const char* value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Sentence.sentiment)
}
 void Sentence::set_sentiment(const char* value, size_t size) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Sentence.sentiment)
}
 ::std::string* Sentence::mutable_sentiment() {
  set_has_sentiment();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.sentiment)
  return sentiment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sentence::release_sentiment() {
  clear_has_sentiment();
  return sentiment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sentence::set_allocated_sentiment(::std::string* sentiment) {
  if (sentiment != NULL) {
    set_has_sentiment();
  } else {
    clear_has_sentiment();
  }
  sentiment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentiment);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.sentiment)
}

// repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
int Sentence::kbestparsetrees_size() const {
  return kbestparsetrees_.size();
}
void Sentence::clear_kbestparsetrees() {
  kbestparsetrees_.Clear();
}
const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::kbestparsetrees(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_.Get(index);
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_kbestparsetrees(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_.Mutable(index);
}
::edu::stanford::nlp::pipeline::ParseTree* Sentence::add_kbestparsetrees() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >*
Sentence::mutable_kbestparsetrees() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return &kbestparsetrees_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >&
Sentence::kbestparsetrees() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_;
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
bool Sentence::has_basicdependencies() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Sentence::set_has_basicdependencies() {
  _has_bits_[0] |= 0x00000800u;
}
void Sentence::clear_has_basicdependencies() {
  _has_bits_[0] &= ~0x00000800u;
}
void Sentence::clear_basicdependencies() {
  if (basicdependencies_ != NULL) basicdependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_basicdependencies();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::basicdependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.basicDependencies)
  return basicdependencies_ != NULL ? *basicdependencies_ : *default_instance_->basicdependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_basicdependencies() {
  set_has_basicdependencies();
  if (basicdependencies_ == NULL) {
    basicdependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.basicDependencies)
  return basicdependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_basicdependencies() {
  clear_has_basicdependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = basicdependencies_;
  basicdependencies_ = NULL;
  return temp;
}
void Sentence::set_allocated_basicdependencies(::edu::stanford::nlp::pipeline::DependencyGraph* basicdependencies) {
  delete basicdependencies_;
  basicdependencies_ = basicdependencies;
  if (basicdependencies) {
    set_has_basicdependencies();
  } else {
    clear_has_basicdependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.basicDependencies)
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
bool Sentence::has_collapseddependencies() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Sentence::set_has_collapseddependencies() {
  _has_bits_[0] |= 0x00001000u;
}
void Sentence::clear_has_collapseddependencies() {
  _has_bits_[0] &= ~0x00001000u;
}
void Sentence::clear_collapseddependencies() {
  if (collapseddependencies_ != NULL) collapseddependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_collapseddependencies();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::collapseddependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.collapsedDependencies)
  return collapseddependencies_ != NULL ? *collapseddependencies_ : *default_instance_->collapseddependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_collapseddependencies() {
  set_has_collapseddependencies();
  if (collapseddependencies_ == NULL) {
    collapseddependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.collapsedDependencies)
  return collapseddependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_collapseddependencies() {
  clear_has_collapseddependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = collapseddependencies_;
  collapseddependencies_ = NULL;
  return temp;
}
void Sentence::set_allocated_collapseddependencies(::edu::stanford::nlp::pipeline::DependencyGraph* collapseddependencies) {
  delete collapseddependencies_;
  collapseddependencies_ = collapseddependencies;
  if (collapseddependencies) {
    set_has_collapseddependencies();
  } else {
    clear_has_collapseddependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.collapsedDependencies)
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
bool Sentence::has_collapsedccprocesseddependencies() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Sentence::set_has_collapsedccprocesseddependencies() {
  _has_bits_[0] |= 0x00002000u;
}
void Sentence::clear_has_collapsedccprocesseddependencies() {
  _has_bits_[0] &= ~0x00002000u;
}
void Sentence::clear_collapsedccprocesseddependencies() {
  if (collapsedccprocesseddependencies_ != NULL) collapsedccprocesseddependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_collapsedccprocesseddependencies();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::collapsedccprocesseddependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.collapsedCCProcessedDependencies)
  return collapsedccprocesseddependencies_ != NULL ? *collapsedccprocesseddependencies_ : *default_instance_->collapsedccprocesseddependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_collapsedccprocesseddependencies() {
  set_has_collapsedccprocesseddependencies();
  if (collapsedccprocesseddependencies_ == NULL) {
    collapsedccprocesseddependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.collapsedCCProcessedDependencies)
  return collapsedccprocesseddependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_collapsedccprocesseddependencies() {
  clear_has_collapsedccprocesseddependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = collapsedccprocesseddependencies_;
  collapsedccprocesseddependencies_ = NULL;
  return temp;
}
void Sentence::set_allocated_collapsedccprocesseddependencies(::edu::stanford::nlp::pipeline::DependencyGraph* collapsedccprocesseddependencies) {
  delete collapsedccprocesseddependencies_;
  collapsedccprocesseddependencies_ = collapsedccprocesseddependencies;
  if (collapsedccprocesseddependencies) {
    set_has_collapsedccprocesseddependencies();
  } else {
    clear_has_collapsedccprocesseddependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.collapsedCCProcessedDependencies)
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
bool Sentence::has_alternativedependencies() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Sentence::set_has_alternativedependencies() {
  _has_bits_[0] |= 0x00004000u;
}
void Sentence::clear_has_alternativedependencies() {
  _has_bits_[0] &= ~0x00004000u;
}
void Sentence::clear_alternativedependencies() {
  if (alternativedependencies_ != NULL) alternativedependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_alternativedependencies();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::alternativedependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.alternativeDependencies)
  return alternativedependencies_ != NULL ? *alternativedependencies_ : *default_instance_->alternativedependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_alternativedependencies() {
  set_has_alternativedependencies();
  if (alternativedependencies_ == NULL) {
    alternativedependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.alternativeDependencies)
  return alternativedependencies_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_alternativedependencies() {
  clear_has_alternativedependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = alternativedependencies_;
  alternativedependencies_ = NULL;
  return temp;
}
void Sentence::set_allocated_alternativedependencies(::edu::stanford::nlp::pipeline::DependencyGraph* alternativedependencies) {
  delete alternativedependencies_;
  alternativedependencies_ = alternativedependencies;
  if (alternativedependencies) {
    set_has_alternativedependencies();
  } else {
    clear_has_alternativedependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.alternativeDependencies)
}

// repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
int Sentence::openietriple_size() const {
  return openietriple_.size();
}
void Sentence::clear_openietriple() {
  openietriple_.Clear();
}
const ::edu::stanford::nlp::pipeline::RelationTriple& Sentence::openietriple(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_.Get(index);
}
::edu::stanford::nlp::pipeline::RelationTriple* Sentence::mutable_openietriple(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_.Mutable(index);
}
::edu::stanford::nlp::pipeline::RelationTriple* Sentence::add_openietriple() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >*
Sentence::mutable_openietriple() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return &openietriple_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >&
Sentence::openietriple() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_;
}

// repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
int Sentence::kbptriple_size() const {
  return kbptriple_.size();
}
void Sentence::clear_kbptriple() {
  kbptriple_.Clear();
}
const ::edu::stanford::nlp::pipeline::RelationTriple& Sentence::kbptriple(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_.Get(index);
}
::edu::stanford::nlp::pipeline::RelationTriple* Sentence::mutable_kbptriple(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_.Mutable(index);
}
::edu::stanford::nlp::pipeline::RelationTriple* Sentence::add_kbptriple() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >*
Sentence::mutable_kbptriple() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return &kbptriple_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >&
Sentence::kbptriple() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_;
}

// repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
int Sentence::entailedsentence_size() const {
  return entailedsentence_.size();
}
void Sentence::clear_entailedsentence() {
  entailedsentence_.Clear();
}
const ::edu::stanford::nlp::pipeline::SentenceFragment& Sentence::entailedsentence(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_.Get(index);
}
::edu::stanford::nlp::pipeline::SentenceFragment* Sentence::mutable_entailedsentence(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_.Mutable(index);
}
::edu::stanford::nlp::pipeline::SentenceFragment* Sentence::add_entailedsentence() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment >*
Sentence::mutable_entailedsentence() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return &entailedsentence_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment >&
Sentence::entailedsentence() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_;
}

// optional uint32 paragraph = 11;
bool Sentence::has_paragraph() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void Sentence::set_has_paragraph() {
  _has_bits_[0] |= 0x00040000u;
}
void Sentence::clear_has_paragraph() {
  _has_bits_[0] &= ~0x00040000u;
}
void Sentence::clear_paragraph() {
  paragraph_ = 0u;
  clear_has_paragraph();
}
 ::google::protobuf::uint32 Sentence::paragraph() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.paragraph)
  return paragraph_;
}
 void Sentence::set_paragraph(::google::protobuf::uint32 value) {
  set_has_paragraph();
  paragraph_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.paragraph)
}

// optional string text = 12;
bool Sentence::has_text() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void Sentence::set_has_text() {
  _has_bits_[0] |= 0x00080000u;
}
void Sentence::clear_has_text() {
  _has_bits_[0] &= ~0x00080000u;
}
void Sentence::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
 const ::std::string& Sentence::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sentence::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.text)
}
 void Sentence::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Sentence.text)
}
 void Sentence::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Sentence.text)
}
 ::std::string* Sentence::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sentence::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sentence::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.text)
}

// optional bool hasRelationAnnotations = 51;
bool Sentence::has_hasrelationannotations() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void Sentence::set_has_hasrelationannotations() {
  _has_bits_[0] |= 0x00100000u;
}
void Sentence::clear_has_hasrelationannotations() {
  _has_bits_[0] &= ~0x00100000u;
}
void Sentence::clear_hasrelationannotations() {
  hasrelationannotations_ = false;
  clear_has_hasrelationannotations();
}
 bool Sentence::hasrelationannotations() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.hasRelationAnnotations)
  return hasrelationannotations_;
}
 void Sentence::set_hasrelationannotations(bool value) {
  set_has_hasrelationannotations();
  hasrelationannotations_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.hasRelationAnnotations)
}

// repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
int Sentence::entity_size() const {
  return entity_.size();
}
void Sentence::clear_entity() {
  entity_.Clear();
}
const ::edu::stanford::nlp::pipeline::Entity& Sentence::entity(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_.Get(index);
}
::edu::stanford::nlp::pipeline::Entity* Sentence::mutable_entity(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Entity* Sentence::add_entity() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >*
Sentence::mutable_entity() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.entity)
  return &entity_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >&
Sentence::entity() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_;
}

// repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
int Sentence::relation_size() const {
  return relation_.size();
}
void Sentence::clear_relation() {
  relation_.Clear();
}
const ::edu::stanford::nlp::pipeline::Relation& Sentence::relation(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_.Get(index);
}
::edu::stanford::nlp::pipeline::Relation* Sentence::mutable_relation(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Relation* Sentence::add_relation() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation >*
Sentence::mutable_relation() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.relation)
  return &relation_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation >&
Sentence::relation() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_;
}

// optional bool hasNumerizedTokensAnnotation = 54;
bool Sentence::has_hasnumerizedtokensannotation() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void Sentence::set_has_hasnumerizedtokensannotation() {
  _has_bits_[0] |= 0x00800000u;
}
void Sentence::clear_has_hasnumerizedtokensannotation() {
  _has_bits_[0] &= ~0x00800000u;
}
void Sentence::clear_hasnumerizedtokensannotation() {
  hasnumerizedtokensannotation_ = false;
  clear_has_hasnumerizedtokensannotation();
}
 bool Sentence::hasnumerizedtokensannotation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.hasNumerizedTokensAnnotation)
  return hasnumerizedtokensannotation_;
}
 void Sentence::set_hasnumerizedtokensannotation(bool value) {
  set_has_hasnumerizedtokensannotation();
  hasnumerizedtokensannotation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.hasNumerizedTokensAnnotation)
}

// repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
int Sentence::mentions_size() const {
  return mentions_.size();
}
void Sentence::clear_mentions() {
  mentions_.Clear();
}
const ::edu::stanford::nlp::pipeline::NERMention& Sentence::mentions(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_.Get(index);
}
::edu::stanford::nlp::pipeline::NERMention* Sentence::mutable_mentions(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_.Mutable(index);
}
::edu::stanford::nlp::pipeline::NERMention* Sentence::add_mentions() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention >*
Sentence::mutable_mentions() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.mentions)
  return &mentions_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention >&
Sentence::mentions() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_;
}

// repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
int Sentence::mentionsforcoref_size() const {
  return mentionsforcoref_.size();
}
void Sentence::clear_mentionsforcoref() {
  mentionsforcoref_.Clear();
}
const ::edu::stanford::nlp::pipeline::Mention& Sentence::mentionsforcoref(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_.Get(index);
}
::edu::stanford::nlp::pipeline::Mention* Sentence::mutable_mentionsforcoref(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Mention* Sentence::add_mentionsforcoref() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention >*
Sentence::mutable_mentionsforcoref() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return &mentionsforcoref_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention >&
Sentence::mentionsforcoref() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_;
}

// optional bool hasCorefMentionsAnnotation = 57;
bool Sentence::has_hascorefmentionsannotation() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void Sentence::set_has_hascorefmentionsannotation() {
  _has_bits_[0] |= 0x04000000u;
}
void Sentence::clear_has_hascorefmentionsannotation() {
  _has_bits_[0] &= ~0x04000000u;
}
void Sentence::clear_hascorefmentionsannotation() {
  hascorefmentionsannotation_ = false;
  clear_has_hascorefmentionsannotation();
}
 bool Sentence::hascorefmentionsannotation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.hasCorefMentionsAnnotation)
  return hascorefmentionsannotation_;
}
 void Sentence::set_hascorefmentionsannotation(bool value) {
  set_has_hascorefmentionsannotation();
  hascorefmentionsannotation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.hasCorefMentionsAnnotation)
}

// optional string sentenceID = 58;
bool Sentence::has_sentenceid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void Sentence::set_has_sentenceid() {
  _has_bits_[0] |= 0x08000000u;
}
void Sentence::clear_has_sentenceid() {
  _has_bits_[0] &= ~0x08000000u;
}
void Sentence::clear_sentenceid() {
  sentenceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentenceid();
}
 const ::std::string& Sentence::sentenceid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.sentenceID)
  return sentenceid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sentence::set_sentenceid(const ::std::string& value) {
  set_has_sentenceid();
  sentenceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}
 void Sentence::set_sentenceid(const char* value) {
  set_has_sentenceid();
  sentenceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}
 void Sentence::set_sentenceid(const char* value, size_t size) {
  set_has_sentenceid();
  sentenceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}
 ::std::string* Sentence::mutable_sentenceid() {
  set_has_sentenceid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.sentenceID)
  return sentenceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Sentence::release_sentenceid() {
  clear_has_sentenceid();
  return sentenceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Sentence::set_allocated_sentenceid(::std::string* sentenceid) {
  if (sentenceid != NULL) {
    set_has_sentenceid();
  } else {
    clear_has_sentenceid();
  }
  sentenceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentenceid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Token::kWordFieldNumber;
const int Token::kPosFieldNumber;
const int Token::kValueFieldNumber;
const int Token::kCategoryFieldNumber;
const int Token::kBeforeFieldNumber;
const int Token::kAfterFieldNumber;
const int Token::kOriginalTextFieldNumber;
const int Token::kNerFieldNumber;
const int Token::kNormalizedNERFieldNumber;
const int Token::kLemmaFieldNumber;
const int Token::kBeginCharFieldNumber;
const int Token::kEndCharFieldNumber;
const int Token::kUtteranceFieldNumber;
const int Token::kSpeakerFieldNumber;
const int Token::kBeginIndexFieldNumber;
const int Token::kEndIndexFieldNumber;
const int Token::kTokenBeginIndexFieldNumber;
const int Token::kTokenEndIndexFieldNumber;
const int Token::kTimexValueFieldNumber;
const int Token::kHasXmlContextFieldNumber;
const int Token::kXmlContextFieldNumber;
const int Token::kCorefClusterIDFieldNumber;
const int Token::kAnswerFieldNumber;
const int Token::kHeadWordIndexFieldNumber;
const int Token::kOperatorFieldNumber;
const int Token::kPolarityFieldNumber;
const int Token::kSpanFieldNumber;
const int Token::kSentimentFieldNumber;
const int Token::kQuotationIndexFieldNumber;
const int Token::kConllUFeaturesFieldNumber;
const int Token::kCoarseTagFieldNumber;
const int Token::kConllUTokenSpanFieldNumber;
const int Token::kConllUMiscFieldNumber;
const int Token::kConllUSecondaryDepsFieldNumber;
const int Token::kWikipediaEntityFieldNumber;
const int Token::kGenderFieldNumber;
const int Token::kTrueCaseFieldNumber;
const int Token::kTrueCaseTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Token::Token()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Token)
}

void Token::InitAsDefaultInstance() {
  timexvalue_ = const_cast< ::edu::stanford::nlp::pipeline::Timex*>(&::edu::stanford::nlp::pipeline::Timex::default_instance());
  operator__ = const_cast< ::edu::stanford::nlp::pipeline::Operator*>(&::edu::stanford::nlp::pipeline::Operator::default_instance());
  polarity_ = const_cast< ::edu::stanford::nlp::pipeline::Polarity*>(&::edu::stanford::nlp::pipeline::Polarity::default_instance());
  span_ = const_cast< ::edu::stanford::nlp::pipeline::Span*>(&::edu::stanford::nlp::pipeline::Span::default_instance());
  conllufeatures_ = const_cast< ::edu::stanford::nlp::pipeline::MapStringString*>(&::edu::stanford::nlp::pipeline::MapStringString::default_instance());
  conllutokenspan_ = const_cast< ::edu::stanford::nlp::pipeline::Span*>(&::edu::stanford::nlp::pipeline::Span::default_instance());
  conllusecondarydeps_ = const_cast< ::edu::stanford::nlp::pipeline::MapIntString*>(&::edu::stanford::nlp::pipeline::MapIntString::default_instance());
}

Token::Token(const Token& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Token)
}

void Token::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pos_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  category_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  before_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  after_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  originaltext_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ner_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  normalizedner_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lemma_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  beginchar_ = 0u;
  endchar_ = 0u;
  utterance_ = 0u;
  speaker_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  beginindex_ = 0u;
  endindex_ = 0u;
  tokenbeginindex_ = 0u;
  tokenendindex_ = 0u;
  timexvalue_ = NULL;
  hasxmlcontext_ = false;
  corefclusterid_ = 0u;
  answer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  headwordindex_ = 0u;
  operator__ = NULL;
  polarity_ = NULL;
  span_ = NULL;
  sentiment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quotationindex_ = 0;
  conllufeatures_ = NULL;
  coarsetag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  conllutokenspan_ = NULL;
  conllumisc_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  conllusecondarydeps_ = NULL;
  wikipediaentity_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gender_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  truecase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  truecasetext_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Token::~Token() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Token)
  SharedDtor();
}

void Token::SharedDtor() {
  word_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pos_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  category_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  before_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  after_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  originaltext_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ner_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  normalizedner_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lemma_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  speaker_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  answer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sentiment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coarsetag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  conllumisc_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  wikipediaentity_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gender_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  truecase_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  truecasetext_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete timexvalue_;
    delete operator__;
    delete polarity_;
    delete span_;
    delete conllufeatures_;
    delete conllutokenspan_;
    delete conllusecondarydeps_;
  }
}

void Token::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Token::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Token_descriptor_;
}

const Token& Token::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Token* Token::default_instance_ = NULL;

Token* Token::New(::google::protobuf::Arena* arena) const {
  Token* n = new Token;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Token::Clear() {
  _extensions_.Clear();
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Token*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    if (has_word()) {
      word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pos()) {
      pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_category()) {
      category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_before()) {
      before_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_after()) {
      after_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_originaltext()) {
      originaltext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ner()) {
      ner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(beginchar_, endchar_);
    ZR_(utterance_, endindex_);
    if (has_normalizedner()) {
      normalizedner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_lemma()) {
      lemma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_speaker()) {
      speaker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[16 / 32] & 15663104u) {
    ZR_(tokenendindex_, hasxmlcontext_);
    ZR_(corefclusterid_, headwordindex_);
    tokenbeginindex_ = 0u;
    if (has_timexvalue()) {
      if (timexvalue_ != NULL) timexvalue_->::edu::stanford::nlp::pipeline::Timex::Clear();
    }
    if (has_answer()) {
      answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    if (has_operator_()) {
      if (operator__ != NULL) operator__->::edu::stanford::nlp::pipeline::Operator::Clear();
    }
    if (has_polarity()) {
      if (polarity_ != NULL) polarity_->::edu::stanford::nlp::pipeline::Polarity::Clear();
    }
    if (has_span()) {
      if (span_ != NULL) span_->::edu::stanford::nlp::pipeline::Span::Clear();
    }
    if (has_sentiment()) {
      sentiment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    quotationindex_ = 0;
    if (has_conllufeatures()) {
      if (conllufeatures_ != NULL) conllufeatures_->::edu::stanford::nlp::pipeline::MapStringString::Clear();
    }
    if (has_coarsetag()) {
      coarsetag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_conllutokenspan()) {
      if (conllutokenspan_ != NULL) conllutokenspan_->::edu::stanford::nlp::pipeline::Span::Clear();
    }
  }
  if (_has_bits_[32 / 32] & 63u) {
    if (has_conllumisc()) {
      conllumisc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_conllusecondarydeps()) {
      if (conllusecondarydeps_ != NULL) conllusecondarydeps_->::edu::stanford::nlp::pipeline::MapIntString::Clear();
    }
    if (has_wikipediaentity()) {
      wikipediaentity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_gender()) {
      gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_truecase()) {
      truecase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_truecasetext()) {
      truecasetext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  xmlcontext_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Token::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Token)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string word = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->word().data(), this->word().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.word");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pos;
        break;
      }

      // optional string pos = 2;
      case 2: {
        if (tag == 18) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pos()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pos().data(), this->pos().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.pos");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional string value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_category;
        break;
      }

      // optional string category = 4;
      case 4: {
        if (tag == 34) {
         parse_category:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_category()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->category().data(), this->category().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.category");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_before;
        break;
      }

      // optional string before = 5;
      case 5: {
        if (tag == 42) {
         parse_before:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_before()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->before().data(), this->before().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.before");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_after;
        break;
      }

      // optional string after = 6;
      case 6: {
        if (tag == 50) {
         parse_after:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_after()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->after().data(), this->after().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.after");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_originalText;
        break;
      }

      // optional string originalText = 7;
      case 7: {
        if (tag == 58) {
         parse_originalText:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_originaltext()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->originaltext().data(), this->originaltext().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.originalText");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_ner;
        break;
      }

      // optional string ner = 8;
      case 8: {
        if (tag == 66) {
         parse_ner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ner().data(), this->ner().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.ner");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_normalizedNER;
        break;
      }

      // optional string normalizedNER = 9;
      case 9: {
        if (tag == 74) {
         parse_normalizedNER:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_normalizedner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->normalizedner().data(), this->normalizedner().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.normalizedNER");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_lemma;
        break;
      }

      // optional string lemma = 10;
      case 10: {
        if (tag == 82) {
         parse_lemma:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lemma()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->lemma().data(), this->lemma().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.lemma");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_beginChar;
        break;
      }

      // optional uint32 beginChar = 11;
      case 11: {
        if (tag == 88) {
         parse_beginChar:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &beginchar_)));
          set_has_beginchar();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_endChar;
        break;
      }

      // optional uint32 endChar = 12;
      case 12: {
        if (tag == 96) {
         parse_endChar:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endchar_)));
          set_has_endchar();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_utterance;
        break;
      }

      // optional uint32 utterance = 13;
      case 13: {
        if (tag == 104) {
         parse_utterance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &utterance_)));
          set_has_utterance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_speaker;
        break;
      }

      // optional string speaker = 14;
      case 14: {
        if (tag == 114) {
         parse_speaker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_speaker()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->speaker().data(), this->speaker().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.speaker");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_beginIndex;
        break;
      }

      // optional uint32 beginIndex = 15;
      case 15: {
        if (tag == 120) {
         parse_beginIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &beginindex_)));
          set_has_beginindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_endIndex;
        break;
      }

      // optional uint32 endIndex = 16;
      case 16: {
        if (tag == 128) {
         parse_endIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endindex_)));
          set_has_endindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_tokenBeginIndex;
        break;
      }

      // optional uint32 tokenBeginIndex = 17;
      case 17: {
        if (tag == 136) {
         parse_tokenBeginIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenbeginindex_)));
          set_has_tokenbeginindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_tokenEndIndex;
        break;
      }

      // optional uint32 tokenEndIndex = 18;
      case 18: {
        if (tag == 144) {
         parse_tokenEndIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenendindex_)));
          set_has_tokenendindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_timexValue;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
      case 19: {
        if (tag == 154) {
         parse_timexValue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timexvalue()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_hasXmlContext;
        break;
      }

      // optional bool hasXmlContext = 21;
      case 21: {
        if (tag == 168) {
         parse_hasXmlContext:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hasxmlcontext_)));
          set_has_hasxmlcontext();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_xmlContext;
        break;
      }

      // repeated string xmlContext = 22;
      case 22: {
        if (tag == 178) {
         parse_xmlContext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_xmlcontext()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->xmlcontext(this->xmlcontext_size() - 1).data(),
            this->xmlcontext(this->xmlcontext_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.xmlContext");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_xmlContext;
        if (input->ExpectTag(184)) goto parse_corefClusterID;
        break;
      }

      // optional uint32 corefClusterID = 23;
      case 23: {
        if (tag == 184) {
         parse_corefClusterID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &corefclusterid_)));
          set_has_corefclusterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_answer;
        break;
      }

      // optional string answer = 24;
      case 24: {
        if (tag == 194) {
         parse_answer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_answer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->answer().data(), this->answer().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.answer");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_headWordIndex;
        break;
      }

      // optional uint32 headWordIndex = 26;
      case 26: {
        if (tag == 208) {
         parse_headWordIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &headwordindex_)));
          set_has_headwordindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(218)) goto parse_operator;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Operator operator = 27;
      case 27: {
        if (tag == 218) {
         parse_operator:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_operator_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(226)) goto parse_polarity;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
      case 28: {
        if (tag == 226) {
         parse_polarity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_polarity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(234)) goto parse_span;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Span span = 29;
      case 29: {
        if (tag == 234) {
         parse_span:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_span()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_sentiment;
        break;
      }

      // optional string sentiment = 30;
      case 30: {
        if (tag == 242) {
         parse_sentiment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sentiment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sentiment().data(), this->sentiment().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.sentiment");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_quotationIndex;
        break;
      }

      // optional int32 quotationIndex = 31;
      case 31: {
        if (tag == 248) {
         parse_quotationIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quotationindex_)));
          set_has_quotationindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_conllUFeatures;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
      case 32: {
        if (tag == 258) {
         parse_conllUFeatures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conllufeatures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(266)) goto parse_coarseTag;
        break;
      }

      // optional string coarseTag = 33;
      case 33: {
        if (tag == 266) {
         parse_coarseTag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coarsetag()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coarsetag().data(), this->coarsetag().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.coarseTag");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(274)) goto parse_conllUTokenSpan;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
      case 34: {
        if (tag == 274) {
         parse_conllUTokenSpan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conllutokenspan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_conllUMisc;
        break;
      }

      // optional string conllUMisc = 35;
      case 35: {
        if (tag == 282) {
         parse_conllUMisc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_conllumisc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->conllumisc().data(), this->conllumisc().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.conllUMisc");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(290)) goto parse_conllUSecondaryDeps;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
      case 36: {
        if (tag == 290) {
         parse_conllUSecondaryDeps:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conllusecondarydeps()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(298)) goto parse_wikipediaEntity;
        break;
      }

      // optional string wikipediaEntity = 37;
      case 37: {
        if (tag == 298) {
         parse_wikipediaEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_wikipediaentity()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->wikipediaentity().data(), this->wikipediaentity().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.wikipediaEntity");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(410)) goto parse_gender;
        break;
      }

      // optional string gender = 51;
      case 51: {
        if (tag == 410) {
         parse_gender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gender()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->gender().data(), this->gender().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.gender");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(418)) goto parse_trueCase;
        break;
      }

      // optional string trueCase = 52;
      case 52: {
        if (tag == 418) {
         parse_trueCase:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_truecase()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->truecase().data(), this->truecase().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.trueCase");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(426)) goto parse_trueCaseText;
        break;
      }

      // optional string trueCaseText = 53;
      case 53: {
        if (tag == 426) {
         parse_trueCaseText:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_truecasetext()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->truecasetext().data(), this->truecasetext().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Token.trueCaseText");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        if ((800u <= tag && tag < 2048u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Token)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Token)
  return false;
#undef DO_
}

void Token::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Token)
  // required string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.word");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->word(), output);
  }

  // optional string pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pos().data(), this->pos().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.pos");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pos(), output);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->value(), output);
  }

  // optional string category = 4;
  if (has_category()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->category().data(), this->category().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.category");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->category(), output);
  }

  // optional string before = 5;
  if (has_before()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->before().data(), this->before().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.before");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->before(), output);
  }

  // optional string after = 6;
  if (has_after()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->after().data(), this->after().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.after");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->after(), output);
  }

  // optional string originalText = 7;
  if (has_originaltext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->originaltext().data(), this->originaltext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.originalText");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->originaltext(), output);
  }

  // optional string ner = 8;
  if (has_ner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ner().data(), this->ner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.ner");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->ner(), output);
  }

  // optional string normalizedNER = 9;
  if (has_normalizedner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->normalizedner().data(), this->normalizedner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.normalizedNER");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->normalizedner(), output);
  }

  // optional string lemma = 10;
  if (has_lemma()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->lemma().data(), this->lemma().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.lemma");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->lemma(), output);
  }

  // optional uint32 beginChar = 11;
  if (has_beginchar()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->beginchar(), output);
  }

  // optional uint32 endChar = 12;
  if (has_endchar()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->endchar(), output);
  }

  // optional uint32 utterance = 13;
  if (has_utterance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->utterance(), output);
  }

  // optional string speaker = 14;
  if (has_speaker()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->speaker().data(), this->speaker().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.speaker");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->speaker(), output);
  }

  // optional uint32 beginIndex = 15;
  if (has_beginindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->beginindex(), output);
  }

  // optional uint32 endIndex = 16;
  if (has_endindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->endindex(), output);
  }

  // optional uint32 tokenBeginIndex = 17;
  if (has_tokenbeginindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->tokenbeginindex(), output);
  }

  // optional uint32 tokenEndIndex = 18;
  if (has_tokenendindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(18, this->tokenendindex(), output);
  }

  // optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
  if (has_timexvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *this->timexvalue_, output);
  }

  // optional bool hasXmlContext = 21;
  if (has_hasxmlcontext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->hasxmlcontext(), output);
  }

  // repeated string xmlContext = 22;
  for (int i = 0; i < this->xmlcontext_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xmlcontext(i).data(), this->xmlcontext(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.xmlContext");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      22, this->xmlcontext(i), output);
  }

  // optional uint32 corefClusterID = 23;
  if (has_corefclusterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->corefclusterid(), output);
  }

  // optional string answer = 24;
  if (has_answer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->answer().data(), this->answer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.answer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      24, this->answer(), output);
  }

  // optional uint32 headWordIndex = 26;
  if (has_headwordindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(26, this->headwordindex(), output);
  }

  // optional .edu.stanford.nlp.pipeline.Operator operator = 27;
  if (has_operator_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      27, *this->operator__, output);
  }

  // optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
  if (has_polarity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      28, *this->polarity_, output);
  }

  // optional .edu.stanford.nlp.pipeline.Span span = 29;
  if (has_span()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      29, *this->span_, output);
  }

  // optional string sentiment = 30;
  if (has_sentiment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sentiment().data(), this->sentiment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.sentiment");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      30, this->sentiment(), output);
  }

  // optional int32 quotationIndex = 31;
  if (has_quotationindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(31, this->quotationindex(), output);
  }

  // optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
  if (has_conllufeatures()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, *this->conllufeatures_, output);
  }

  // optional string coarseTag = 33;
  if (has_coarsetag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coarsetag().data(), this->coarsetag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.coarseTag");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      33, this->coarsetag(), output);
  }

  // optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
  if (has_conllutokenspan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, *this->conllutokenspan_, output);
  }

  // optional string conllUMisc = 35;
  if (has_conllumisc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->conllumisc().data(), this->conllumisc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.conllUMisc");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      35, this->conllumisc(), output);
  }

  // optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
  if (has_conllusecondarydeps()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      36, *this->conllusecondarydeps_, output);
  }

  // optional string wikipediaEntity = 37;
  if (has_wikipediaentity()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wikipediaentity().data(), this->wikipediaentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.wikipediaEntity");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      37, this->wikipediaentity(), output);
  }

  // optional string gender = 51;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gender().data(), this->gender().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.gender");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      51, this->gender(), output);
  }

  // optional string trueCase = 52;
  if (has_truecase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->truecase().data(), this->truecase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.trueCase");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      52, this->truecase(), output);
  }

  // optional string trueCaseText = 53;
  if (has_truecasetext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->truecasetext().data(), this->truecasetext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.trueCaseText");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      53, this->truecasetext(), output);
  }

  // Extension range [100, 256)
  _extensions_.SerializeWithCachedSizes(
      100, 256, output);

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Token)
}

::google::protobuf::uint8* Token::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Token)
  // required string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.word");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->word(), target);
  }

  // optional string pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pos().data(), this->pos().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.pos");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pos(), target);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->value(), target);
  }

  // optional string category = 4;
  if (has_category()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->category().data(), this->category().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.category");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->category(), target);
  }

  // optional string before = 5;
  if (has_before()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->before().data(), this->before().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.before");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->before(), target);
  }

  // optional string after = 6;
  if (has_after()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->after().data(), this->after().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.after");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->after(), target);
  }

  // optional string originalText = 7;
  if (has_originaltext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->originaltext().data(), this->originaltext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.originalText");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->originaltext(), target);
  }

  // optional string ner = 8;
  if (has_ner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ner().data(), this->ner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.ner");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->ner(), target);
  }

  // optional string normalizedNER = 9;
  if (has_normalizedner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->normalizedner().data(), this->normalizedner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.normalizedNER");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->normalizedner(), target);
  }

  // optional string lemma = 10;
  if (has_lemma()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->lemma().data(), this->lemma().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.lemma");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->lemma(), target);
  }

  // optional uint32 beginChar = 11;
  if (has_beginchar()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->beginchar(), target);
  }

  // optional uint32 endChar = 12;
  if (has_endchar()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->endchar(), target);
  }

  // optional uint32 utterance = 13;
  if (has_utterance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->utterance(), target);
  }

  // optional string speaker = 14;
  if (has_speaker()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->speaker().data(), this->speaker().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.speaker");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->speaker(), target);
  }

  // optional uint32 beginIndex = 15;
  if (has_beginindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->beginindex(), target);
  }

  // optional uint32 endIndex = 16;
  if (has_endindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->endindex(), target);
  }

  // optional uint32 tokenBeginIndex = 17;
  if (has_tokenbeginindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(17, this->tokenbeginindex(), target);
  }

  // optional uint32 tokenEndIndex = 18;
  if (has_tokenendindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(18, this->tokenendindex(), target);
  }

  // optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
  if (has_timexvalue()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, *this->timexvalue_, target);
  }

  // optional bool hasXmlContext = 21;
  if (has_hasxmlcontext()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(21, this->hasxmlcontext(), target);
  }

  // repeated string xmlContext = 22;
  for (int i = 0; i < this->xmlcontext_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xmlcontext(i).data(), this->xmlcontext(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.xmlContext");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(22, this->xmlcontext(i), target);
  }

  // optional uint32 corefClusterID = 23;
  if (has_corefclusterid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(23, this->corefclusterid(), target);
  }

  // optional string answer = 24;
  if (has_answer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->answer().data(), this->answer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.answer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        24, this->answer(), target);
  }

  // optional uint32 headWordIndex = 26;
  if (has_headwordindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(26, this->headwordindex(), target);
  }

  // optional .edu.stanford.nlp.pipeline.Operator operator = 27;
  if (has_operator_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        27, *this->operator__, target);
  }

  // optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
  if (has_polarity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        28, *this->polarity_, target);
  }

  // optional .edu.stanford.nlp.pipeline.Span span = 29;
  if (has_span()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        29, *this->span_, target);
  }

  // optional string sentiment = 30;
  if (has_sentiment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sentiment().data(), this->sentiment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.sentiment");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->sentiment(), target);
  }

  // optional int32 quotationIndex = 31;
  if (has_quotationindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(31, this->quotationindex(), target);
  }

  // optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
  if (has_conllufeatures()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        32, *this->conllufeatures_, target);
  }

  // optional string coarseTag = 33;
  if (has_coarsetag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coarsetag().data(), this->coarsetag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.coarseTag");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        33, this->coarsetag(), target);
  }

  // optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
  if (has_conllutokenspan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        34, *this->conllutokenspan_, target);
  }

  // optional string conllUMisc = 35;
  if (has_conllumisc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->conllumisc().data(), this->conllumisc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.conllUMisc");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        35, this->conllumisc(), target);
  }

  // optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
  if (has_conllusecondarydeps()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        36, *this->conllusecondarydeps_, target);
  }

  // optional string wikipediaEntity = 37;
  if (has_wikipediaentity()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wikipediaentity().data(), this->wikipediaentity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.wikipediaEntity");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        37, this->wikipediaentity(), target);
  }

  // optional string gender = 51;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gender().data(), this->gender().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.gender");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        51, this->gender(), target);
  }

  // optional string trueCase = 52;
  if (has_truecase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->truecase().data(), this->truecase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.trueCase");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        52, this->truecase(), target);
  }

  // optional string trueCaseText = 53;
  if (has_truecasetext()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->truecasetext().data(), this->truecasetext().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Token.trueCaseText");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        53, this->truecasetext(), target);
  }

  // Extension range [100, 256)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 256, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Token)
  return target;
}

int Token::ByteSize() const {
  int total_size = 0;

  // required string word = 1;
  if (has_word()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->word());
  }
  if (_has_bits_[1 / 32] & 254u) {
    // optional string pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pos());
    }

    // optional string value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional string category = 4;
    if (has_category()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->category());
    }

    // optional string before = 5;
    if (has_before()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->before());
    }

    // optional string after = 6;
    if (has_after()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->after());
    }

    // optional string originalText = 7;
    if (has_originaltext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->originaltext());
    }

    // optional string ner = 8;
    if (has_ner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ner());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional string normalizedNER = 9;
    if (has_normalizedner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->normalizedner());
    }

    // optional string lemma = 10;
    if (has_lemma()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->lemma());
    }

    // optional uint32 beginChar = 11;
    if (has_beginchar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->beginchar());
    }

    // optional uint32 endChar = 12;
    if (has_endchar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endchar());
    }

    // optional uint32 utterance = 13;
    if (has_utterance()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->utterance());
    }

    // optional string speaker = 14;
    if (has_speaker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->speaker());
    }

    // optional uint32 beginIndex = 15;
    if (has_beginindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->beginindex());
    }

    // optional uint32 endIndex = 16;
    if (has_endindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endindex());
    }

  }
  if (_has_bits_[16 / 32] & 15663104u) {
    // optional uint32 tokenBeginIndex = 17;
    if (has_tokenbeginindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tokenbeginindex());
    }

    // optional uint32 tokenEndIndex = 18;
    if (has_tokenendindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tokenendindex());
    }

    // optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
    if (has_timexvalue()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timexvalue_);
    }

    // optional bool hasXmlContext = 21;
    if (has_hasxmlcontext()) {
      total_size += 2 + 1;
    }

    // optional uint32 corefClusterID = 23;
    if (has_corefclusterid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->corefclusterid());
    }

    // optional string answer = 24;
    if (has_answer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->answer());
    }

    // optional uint32 headWordIndex = 26;
    if (has_headwordindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->headwordindex());
    }

  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    // optional .edu.stanford.nlp.pipeline.Operator operator = 27;
    if (has_operator_()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->operator__);
    }

    // optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
    if (has_polarity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->polarity_);
    }

    // optional .edu.stanford.nlp.pipeline.Span span = 29;
    if (has_span()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->span_);
    }

    // optional string sentiment = 30;
    if (has_sentiment()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sentiment());
    }

    // optional int32 quotationIndex = 31;
    if (has_quotationindex()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quotationindex());
    }

    // optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
    if (has_conllufeatures()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conllufeatures_);
    }

    // optional string coarseTag = 33;
    if (has_coarsetag()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coarsetag());
    }

    // optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
    if (has_conllutokenspan()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conllutokenspan_);
    }

  }
  if (_has_bits_[32 / 32] & 63u) {
    // optional string conllUMisc = 35;
    if (has_conllumisc()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->conllumisc());
    }

    // optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
    if (has_conllusecondarydeps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conllusecondarydeps_);
    }

    // optional string wikipediaEntity = 37;
    if (has_wikipediaentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->wikipediaentity());
    }

    // optional string gender = 51;
    if (has_gender()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gender());
    }

    // optional string trueCase = 52;
    if (has_truecase()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->truecase());
    }

    // optional string trueCaseText = 53;
    if (has_truecasetext()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->truecasetext());
    }

  }
  // repeated string xmlContext = 22;
  total_size += 2 * this->xmlcontext_size();
  for (int i = 0; i < this->xmlcontext_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->xmlcontext(i));
  }

  total_size += _extensions_.ByteSize();

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Token::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Token* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Token>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Token::MergeFrom(const Token& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  xmlcontext_.MergeFrom(from.xmlcontext_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word()) {
      set_has_word();
      word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.word_);
    }
    if (from.has_pos()) {
      set_has_pos();
      pos_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pos_);
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_category()) {
      set_has_category();
      category_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.category_);
    }
    if (from.has_before()) {
      set_has_before();
      before_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.before_);
    }
    if (from.has_after()) {
      set_has_after();
      after_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.after_);
    }
    if (from.has_originaltext()) {
      set_has_originaltext();
      originaltext_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.originaltext_);
    }
    if (from.has_ner()) {
      set_has_ner();
      ner_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ner_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_normalizedner()) {
      set_has_normalizedner();
      normalizedner_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.normalizedner_);
    }
    if (from.has_lemma()) {
      set_has_lemma();
      lemma_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.lemma_);
    }
    if (from.has_beginchar()) {
      set_beginchar(from.beginchar());
    }
    if (from.has_endchar()) {
      set_endchar(from.endchar());
    }
    if (from.has_utterance()) {
      set_utterance(from.utterance());
    }
    if (from.has_speaker()) {
      set_has_speaker();
      speaker_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.speaker_);
    }
    if (from.has_beginindex()) {
      set_beginindex(from.beginindex());
    }
    if (from.has_endindex()) {
      set_endindex(from.endindex());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_tokenbeginindex()) {
      set_tokenbeginindex(from.tokenbeginindex());
    }
    if (from.has_tokenendindex()) {
      set_tokenendindex(from.tokenendindex());
    }
    if (from.has_timexvalue()) {
      mutable_timexvalue()->::edu::stanford::nlp::pipeline::Timex::MergeFrom(from.timexvalue());
    }
    if (from.has_hasxmlcontext()) {
      set_hasxmlcontext(from.hasxmlcontext());
    }
    if (from.has_corefclusterid()) {
      set_corefclusterid(from.corefclusterid());
    }
    if (from.has_answer()) {
      set_has_answer();
      answer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.answer_);
    }
    if (from.has_headwordindex()) {
      set_headwordindex(from.headwordindex());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_operator_()) {
      mutable_operator_()->::edu::stanford::nlp::pipeline::Operator::MergeFrom(from.operator_());
    }
    if (from.has_polarity()) {
      mutable_polarity()->::edu::stanford::nlp::pipeline::Polarity::MergeFrom(from.polarity());
    }
    if (from.has_span()) {
      mutable_span()->::edu::stanford::nlp::pipeline::Span::MergeFrom(from.span());
    }
    if (from.has_sentiment()) {
      set_has_sentiment();
      sentiment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sentiment_);
    }
    if (from.has_quotationindex()) {
      set_quotationindex(from.quotationindex());
    }
    if (from.has_conllufeatures()) {
      mutable_conllufeatures()->::edu::stanford::nlp::pipeline::MapStringString::MergeFrom(from.conllufeatures());
    }
    if (from.has_coarsetag()) {
      set_has_coarsetag();
      coarsetag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.coarsetag_);
    }
    if (from.has_conllutokenspan()) {
      mutable_conllutokenspan()->::edu::stanford::nlp::pipeline::Span::MergeFrom(from.conllutokenspan());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_conllumisc()) {
      set_has_conllumisc();
      conllumisc_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.conllumisc_);
    }
    if (from.has_conllusecondarydeps()) {
      mutable_conllusecondarydeps()->::edu::stanford::nlp::pipeline::MapIntString::MergeFrom(from.conllusecondarydeps());
    }
    if (from.has_wikipediaentity()) {
      set_has_wikipediaentity();
      wikipediaentity_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.wikipediaentity_);
    }
    if (from.has_gender()) {
      set_has_gender();
      gender_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gender_);
    }
    if (from.has_truecase()) {
      set_has_truecase();
      truecase_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.truecase_);
    }
    if (from.has_truecasetext()) {
      set_has_truecasetext();
      truecasetext_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.truecasetext_);
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Token::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Token::CopyFrom(const Token& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Token::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_operator_()) {
    if (!this->operator__->IsInitialized()) return false;
  }
  if (has_polarity()) {
    if (!this->polarity_->IsInitialized()) return false;
  }
  if (has_span()) {
    if (!this->span_->IsInitialized()) return false;
  }
  if (has_conllutokenspan()) {
    if (!this->conllutokenspan_->IsInitialized()) return false;
  }

  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Token::Swap(Token* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Token::InternalSwap(Token* other) {
  word_.Swap(&other->word_);
  pos_.Swap(&other->pos_);
  value_.Swap(&other->value_);
  category_.Swap(&other->category_);
  before_.Swap(&other->before_);
  after_.Swap(&other->after_);
  originaltext_.Swap(&other->originaltext_);
  ner_.Swap(&other->ner_);
  normalizedner_.Swap(&other->normalizedner_);
  lemma_.Swap(&other->lemma_);
  std::swap(beginchar_, other->beginchar_);
  std::swap(endchar_, other->endchar_);
  std::swap(utterance_, other->utterance_);
  speaker_.Swap(&other->speaker_);
  std::swap(beginindex_, other->beginindex_);
  std::swap(endindex_, other->endindex_);
  std::swap(tokenbeginindex_, other->tokenbeginindex_);
  std::swap(tokenendindex_, other->tokenendindex_);
  std::swap(timexvalue_, other->timexvalue_);
  std::swap(hasxmlcontext_, other->hasxmlcontext_);
  xmlcontext_.UnsafeArenaSwap(&other->xmlcontext_);
  std::swap(corefclusterid_, other->corefclusterid_);
  answer_.Swap(&other->answer_);
  std::swap(headwordindex_, other->headwordindex_);
  std::swap(operator__, other->operator__);
  std::swap(polarity_, other->polarity_);
  std::swap(span_, other->span_);
  sentiment_.Swap(&other->sentiment_);
  std::swap(quotationindex_, other->quotationindex_);
  std::swap(conllufeatures_, other->conllufeatures_);
  coarsetag_.Swap(&other->coarsetag_);
  std::swap(conllutokenspan_, other->conllutokenspan_);
  conllumisc_.Swap(&other->conllumisc_);
  std::swap(conllusecondarydeps_, other->conllusecondarydeps_);
  wikipediaentity_.Swap(&other->wikipediaentity_);
  gender_.Swap(&other->gender_);
  truecase_.Swap(&other->truecase_);
  truecasetext_.Swap(&other->truecasetext_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  std::swap(_has_bits_[1], other->_has_bits_[1]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
  _extensions_.Swap(&other->_extensions_);
}

::google::protobuf::Metadata Token::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Token_descriptor_;
  metadata.reflection = Token_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Token

// required string word = 1;
bool Token::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Token::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
void Token::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
void Token::clear_word() {
  word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_word();
}
 const ::std::string& Token::word() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.word)
  return word_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_word(const ::std::string& value) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.word)
}
 void Token::set_word(const char* value) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.word)
}
 void Token::set_word(const char* value, size_t size) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.word)
}
 ::std::string* Token::mutable_word() {
  set_has_word();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.word)
  return word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_word() {
  clear_has_word();
  return word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_word(::std::string* word) {
  if (word != NULL) {
    set_has_word();
  } else {
    clear_has_word();
  }
  word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.word)
}

// optional string pos = 2;
bool Token::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Token::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
void Token::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
void Token::clear_pos() {
  pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pos();
}
 const ::std::string& Token::pos() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.pos)
  return pos_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_pos(const ::std::string& value) {
  set_has_pos();
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.pos)
}
 void Token::set_pos(const char* value) {
  set_has_pos();
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.pos)
}
 void Token::set_pos(const char* value, size_t size) {
  set_has_pos();
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.pos)
}
 ::std::string* Token::mutable_pos() {
  set_has_pos();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.pos)
  return pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_pos() {
  clear_has_pos();
  return pos_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_pos(::std::string* pos) {
  if (pos != NULL) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pos);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.pos)
}

// optional string value = 3;
bool Token::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Token::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
void Token::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void Token::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Token::value() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.value)
}
 void Token::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.value)
}
 void Token::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.value)
}
 ::std::string* Token::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.value)
}

// optional string category = 4;
bool Token::has_category() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Token::set_has_category() {
  _has_bits_[0] |= 0x00000008u;
}
void Token::clear_has_category() {
  _has_bits_[0] &= ~0x00000008u;
}
void Token::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
 const ::std::string& Token::category() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.category)
  return category_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.category)
}
 void Token::set_category(const char* value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.category)
}
 void Token::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.category)
}
 ::std::string* Token::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_category() {
  clear_has_category();
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.category)
}

// optional string before = 5;
bool Token::has_before() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Token::set_has_before() {
  _has_bits_[0] |= 0x00000010u;
}
void Token::clear_has_before() {
  _has_bits_[0] &= ~0x00000010u;
}
void Token::clear_before() {
  before_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_before();
}
 const ::std::string& Token::before() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.before)
  return before_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_before(const ::std::string& value) {
  set_has_before();
  before_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.before)
}
 void Token::set_before(const char* value) {
  set_has_before();
  before_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.before)
}
 void Token::set_before(const char* value, size_t size) {
  set_has_before();
  before_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.before)
}
 ::std::string* Token::mutable_before() {
  set_has_before();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.before)
  return before_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_before() {
  clear_has_before();
  return before_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_before(::std::string* before) {
  if (before != NULL) {
    set_has_before();
  } else {
    clear_has_before();
  }
  before_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), before);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.before)
}

// optional string after = 6;
bool Token::has_after() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Token::set_has_after() {
  _has_bits_[0] |= 0x00000020u;
}
void Token::clear_has_after() {
  _has_bits_[0] &= ~0x00000020u;
}
void Token::clear_after() {
  after_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_after();
}
 const ::std::string& Token::after() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.after)
  return after_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_after(const ::std::string& value) {
  set_has_after();
  after_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.after)
}
 void Token::set_after(const char* value) {
  set_has_after();
  after_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.after)
}
 void Token::set_after(const char* value, size_t size) {
  set_has_after();
  after_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.after)
}
 ::std::string* Token::mutable_after() {
  set_has_after();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.after)
  return after_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_after() {
  clear_has_after();
  return after_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_after(::std::string* after) {
  if (after != NULL) {
    set_has_after();
  } else {
    clear_has_after();
  }
  after_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), after);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.after)
}

// optional string originalText = 7;
bool Token::has_originaltext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Token::set_has_originaltext() {
  _has_bits_[0] |= 0x00000040u;
}
void Token::clear_has_originaltext() {
  _has_bits_[0] &= ~0x00000040u;
}
void Token::clear_originaltext() {
  originaltext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_originaltext();
}
 const ::std::string& Token::originaltext() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.originalText)
  return originaltext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_originaltext(const ::std::string& value) {
  set_has_originaltext();
  originaltext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.originalText)
}
 void Token::set_originaltext(const char* value) {
  set_has_originaltext();
  originaltext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.originalText)
}
 void Token::set_originaltext(const char* value, size_t size) {
  set_has_originaltext();
  originaltext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.originalText)
}
 ::std::string* Token::mutable_originaltext() {
  set_has_originaltext();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.originalText)
  return originaltext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_originaltext() {
  clear_has_originaltext();
  return originaltext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_originaltext(::std::string* originaltext) {
  if (originaltext != NULL) {
    set_has_originaltext();
  } else {
    clear_has_originaltext();
  }
  originaltext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), originaltext);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.originalText)
}

// optional string ner = 8;
bool Token::has_ner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Token::set_has_ner() {
  _has_bits_[0] |= 0x00000080u;
}
void Token::clear_has_ner() {
  _has_bits_[0] &= ~0x00000080u;
}
void Token::clear_ner() {
  ner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ner();
}
 const ::std::string& Token::ner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.ner)
  return ner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_ner(const ::std::string& value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.ner)
}
 void Token::set_ner(const char* value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.ner)
}
 void Token::set_ner(const char* value, size_t size) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.ner)
}
 ::std::string* Token::mutable_ner() {
  set_has_ner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.ner)
  return ner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_ner() {
  clear_has_ner();
  return ner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_ner(::std::string* ner) {
  if (ner != NULL) {
    set_has_ner();
  } else {
    clear_has_ner();
  }
  ner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.ner)
}

// optional string normalizedNER = 9;
bool Token::has_normalizedner() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Token::set_has_normalizedner() {
  _has_bits_[0] |= 0x00000100u;
}
void Token::clear_has_normalizedner() {
  _has_bits_[0] &= ~0x00000100u;
}
void Token::clear_normalizedner() {
  normalizedner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_normalizedner();
}
 const ::std::string& Token::normalizedner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.normalizedNER)
  return normalizedner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_normalizedner(const ::std::string& value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.normalizedNER)
}
 void Token::set_normalizedner(const char* value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.normalizedNER)
}
 void Token::set_normalizedner(const char* value, size_t size) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.normalizedNER)
}
 ::std::string* Token::mutable_normalizedner() {
  set_has_normalizedner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.normalizedNER)
  return normalizedner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_normalizedner() {
  clear_has_normalizedner();
  return normalizedner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_normalizedner(::std::string* normalizedner) {
  if (normalizedner != NULL) {
    set_has_normalizedner();
  } else {
    clear_has_normalizedner();
  }
  normalizedner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normalizedner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.normalizedNER)
}

// optional string lemma = 10;
bool Token::has_lemma() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Token::set_has_lemma() {
  _has_bits_[0] |= 0x00000200u;
}
void Token::clear_has_lemma() {
  _has_bits_[0] &= ~0x00000200u;
}
void Token::clear_lemma() {
  lemma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lemma();
}
 const ::std::string& Token::lemma() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.lemma)
  return lemma_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_lemma(const ::std::string& value) {
  set_has_lemma();
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.lemma)
}
 void Token::set_lemma(const char* value) {
  set_has_lemma();
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.lemma)
}
 void Token::set_lemma(const char* value, size_t size) {
  set_has_lemma();
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.lemma)
}
 ::std::string* Token::mutable_lemma() {
  set_has_lemma();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.lemma)
  return lemma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_lemma() {
  clear_has_lemma();
  return lemma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_lemma(::std::string* lemma) {
  if (lemma != NULL) {
    set_has_lemma();
  } else {
    clear_has_lemma();
  }
  lemma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lemma);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.lemma)
}

// optional uint32 beginChar = 11;
bool Token::has_beginchar() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Token::set_has_beginchar() {
  _has_bits_[0] |= 0x00000400u;
}
void Token::clear_has_beginchar() {
  _has_bits_[0] &= ~0x00000400u;
}
void Token::clear_beginchar() {
  beginchar_ = 0u;
  clear_has_beginchar();
}
 ::google::protobuf::uint32 Token::beginchar() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.beginChar)
  return beginchar_;
}
 void Token::set_beginchar(::google::protobuf::uint32 value) {
  set_has_beginchar();
  beginchar_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.beginChar)
}

// optional uint32 endChar = 12;
bool Token::has_endchar() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Token::set_has_endchar() {
  _has_bits_[0] |= 0x00000800u;
}
void Token::clear_has_endchar() {
  _has_bits_[0] &= ~0x00000800u;
}
void Token::clear_endchar() {
  endchar_ = 0u;
  clear_has_endchar();
}
 ::google::protobuf::uint32 Token::endchar() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.endChar)
  return endchar_;
}
 void Token::set_endchar(::google::protobuf::uint32 value) {
  set_has_endchar();
  endchar_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.endChar)
}

// optional uint32 utterance = 13;
bool Token::has_utterance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Token::set_has_utterance() {
  _has_bits_[0] |= 0x00001000u;
}
void Token::clear_has_utterance() {
  _has_bits_[0] &= ~0x00001000u;
}
void Token::clear_utterance() {
  utterance_ = 0u;
  clear_has_utterance();
}
 ::google::protobuf::uint32 Token::utterance() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.utterance)
  return utterance_;
}
 void Token::set_utterance(::google::protobuf::uint32 value) {
  set_has_utterance();
  utterance_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.utterance)
}

// optional string speaker = 14;
bool Token::has_speaker() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Token::set_has_speaker() {
  _has_bits_[0] |= 0x00002000u;
}
void Token::clear_has_speaker() {
  _has_bits_[0] &= ~0x00002000u;
}
void Token::clear_speaker() {
  speaker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_speaker();
}
 const ::std::string& Token::speaker() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.speaker)
  return speaker_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_speaker(const ::std::string& value) {
  set_has_speaker();
  speaker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.speaker)
}
 void Token::set_speaker(const char* value) {
  set_has_speaker();
  speaker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.speaker)
}
 void Token::set_speaker(const char* value, size_t size) {
  set_has_speaker();
  speaker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.speaker)
}
 ::std::string* Token::mutable_speaker() {
  set_has_speaker();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.speaker)
  return speaker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_speaker() {
  clear_has_speaker();
  return speaker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_speaker(::std::string* speaker) {
  if (speaker != NULL) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
  speaker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), speaker);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.speaker)
}

// optional uint32 beginIndex = 15;
bool Token::has_beginindex() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Token::set_has_beginindex() {
  _has_bits_[0] |= 0x00004000u;
}
void Token::clear_has_beginindex() {
  _has_bits_[0] &= ~0x00004000u;
}
void Token::clear_beginindex() {
  beginindex_ = 0u;
  clear_has_beginindex();
}
 ::google::protobuf::uint32 Token::beginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.beginIndex)
  return beginindex_;
}
 void Token::set_beginindex(::google::protobuf::uint32 value) {
  set_has_beginindex();
  beginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.beginIndex)
}

// optional uint32 endIndex = 16;
bool Token::has_endindex() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void Token::set_has_endindex() {
  _has_bits_[0] |= 0x00008000u;
}
void Token::clear_has_endindex() {
  _has_bits_[0] &= ~0x00008000u;
}
void Token::clear_endindex() {
  endindex_ = 0u;
  clear_has_endindex();
}
 ::google::protobuf::uint32 Token::endindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.endIndex)
  return endindex_;
}
 void Token::set_endindex(::google::protobuf::uint32 value) {
  set_has_endindex();
  endindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.endIndex)
}

// optional uint32 tokenBeginIndex = 17;
bool Token::has_tokenbeginindex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void Token::set_has_tokenbeginindex() {
  _has_bits_[0] |= 0x00010000u;
}
void Token::clear_has_tokenbeginindex() {
  _has_bits_[0] &= ~0x00010000u;
}
void Token::clear_tokenbeginindex() {
  tokenbeginindex_ = 0u;
  clear_has_tokenbeginindex();
}
 ::google::protobuf::uint32 Token::tokenbeginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.tokenBeginIndex)
  return tokenbeginindex_;
}
 void Token::set_tokenbeginindex(::google::protobuf::uint32 value) {
  set_has_tokenbeginindex();
  tokenbeginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.tokenBeginIndex)
}

// optional uint32 tokenEndIndex = 18;
bool Token::has_tokenendindex() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void Token::set_has_tokenendindex() {
  _has_bits_[0] |= 0x00020000u;
}
void Token::clear_has_tokenendindex() {
  _has_bits_[0] &= ~0x00020000u;
}
void Token::clear_tokenendindex() {
  tokenendindex_ = 0u;
  clear_has_tokenendindex();
}
 ::google::protobuf::uint32 Token::tokenendindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.tokenEndIndex)
  return tokenendindex_;
}
 void Token::set_tokenendindex(::google::protobuf::uint32 value) {
  set_has_tokenendindex();
  tokenendindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.tokenEndIndex)
}

// optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
bool Token::has_timexvalue() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void Token::set_has_timexvalue() {
  _has_bits_[0] |= 0x00040000u;
}
void Token::clear_has_timexvalue() {
  _has_bits_[0] &= ~0x00040000u;
}
void Token::clear_timexvalue() {
  if (timexvalue_ != NULL) timexvalue_->::edu::stanford::nlp::pipeline::Timex::Clear();
  clear_has_timexvalue();
}
const ::edu::stanford::nlp::pipeline::Timex& Token::timexvalue() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.timexValue)
  return timexvalue_ != NULL ? *timexvalue_ : *default_instance_->timexvalue_;
}
::edu::stanford::nlp::pipeline::Timex* Token::mutable_timexvalue() {
  set_has_timexvalue();
  if (timexvalue_ == NULL) {
    timexvalue_ = new ::edu::stanford::nlp::pipeline::Timex;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.timexValue)
  return timexvalue_;
}
::edu::stanford::nlp::pipeline::Timex* Token::release_timexvalue() {
  clear_has_timexvalue();
  ::edu::stanford::nlp::pipeline::Timex* temp = timexvalue_;
  timexvalue_ = NULL;
  return temp;
}
void Token::set_allocated_timexvalue(::edu::stanford::nlp::pipeline::Timex* timexvalue) {
  delete timexvalue_;
  timexvalue_ = timexvalue;
  if (timexvalue) {
    set_has_timexvalue();
  } else {
    clear_has_timexvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.timexValue)
}

// optional bool hasXmlContext = 21;
bool Token::has_hasxmlcontext() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void Token::set_has_hasxmlcontext() {
  _has_bits_[0] |= 0x00080000u;
}
void Token::clear_has_hasxmlcontext() {
  _has_bits_[0] &= ~0x00080000u;
}
void Token::clear_hasxmlcontext() {
  hasxmlcontext_ = false;
  clear_has_hasxmlcontext();
}
 bool Token::hasxmlcontext() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.hasXmlContext)
  return hasxmlcontext_;
}
 void Token::set_hasxmlcontext(bool value) {
  set_has_hasxmlcontext();
  hasxmlcontext_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.hasXmlContext)
}

// repeated string xmlContext = 22;
int Token::xmlcontext_size() const {
  return xmlcontext_.size();
}
void Token::clear_xmlcontext() {
  xmlcontext_.Clear();
}
 const ::std::string& Token::xmlcontext(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.xmlContext)
  return xmlcontext_.Get(index);
}
 ::std::string* Token::mutable_xmlcontext(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.xmlContext)
  return xmlcontext_.Mutable(index);
}
 void Token::set_xmlcontext(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.xmlContext)
  xmlcontext_.Mutable(index)->assign(value);
}
 void Token::set_xmlcontext(int index, const char* value) {
  xmlcontext_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.xmlContext)
}
 void Token::set_xmlcontext(int index, const char* value, size_t size) {
  xmlcontext_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.xmlContext)
}
 ::std::string* Token::add_xmlcontext() {
  return xmlcontext_.Add();
}
 void Token::add_xmlcontext(const ::std::string& value) {
  xmlcontext_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Token.xmlContext)
}
 void Token::add_xmlcontext(const char* value) {
  xmlcontext_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Token.xmlContext)
}
 void Token::add_xmlcontext(const char* value, size_t size) {
  xmlcontext_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Token.xmlContext)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Token::xmlcontext() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Token.xmlContext)
  return xmlcontext_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Token::mutable_xmlcontext() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Token.xmlContext)
  return &xmlcontext_;
}

// optional uint32 corefClusterID = 23;
bool Token::has_corefclusterid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void Token::set_has_corefclusterid() {
  _has_bits_[0] |= 0x00200000u;
}
void Token::clear_has_corefclusterid() {
  _has_bits_[0] &= ~0x00200000u;
}
void Token::clear_corefclusterid() {
  corefclusterid_ = 0u;
  clear_has_corefclusterid();
}
 ::google::protobuf::uint32 Token::corefclusterid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.corefClusterID)
  return corefclusterid_;
}
 void Token::set_corefclusterid(::google::protobuf::uint32 value) {
  set_has_corefclusterid();
  corefclusterid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.corefClusterID)
}

// optional string answer = 24;
bool Token::has_answer() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void Token::set_has_answer() {
  _has_bits_[0] |= 0x00400000u;
}
void Token::clear_has_answer() {
  _has_bits_[0] &= ~0x00400000u;
}
void Token::clear_answer() {
  answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_answer();
}
 const ::std::string& Token::answer() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.answer)
  return answer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_answer(const ::std::string& value) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.answer)
}
 void Token::set_answer(const char* value) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.answer)
}
 void Token::set_answer(const char* value, size_t size) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.answer)
}
 ::std::string* Token::mutable_answer() {
  set_has_answer();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.answer)
  return answer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_answer() {
  clear_has_answer();
  return answer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_answer(::std::string* answer) {
  if (answer != NULL) {
    set_has_answer();
  } else {
    clear_has_answer();
  }
  answer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), answer);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.answer)
}

// optional uint32 headWordIndex = 26;
bool Token::has_headwordindex() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void Token::set_has_headwordindex() {
  _has_bits_[0] |= 0x00800000u;
}
void Token::clear_has_headwordindex() {
  _has_bits_[0] &= ~0x00800000u;
}
void Token::clear_headwordindex() {
  headwordindex_ = 0u;
  clear_has_headwordindex();
}
 ::google::protobuf::uint32 Token::headwordindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.headWordIndex)
  return headwordindex_;
}
 void Token::set_headwordindex(::google::protobuf::uint32 value) {
  set_has_headwordindex();
  headwordindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.headWordIndex)
}

// optional .edu.stanford.nlp.pipeline.Operator operator = 27;
bool Token::has_operator_() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void Token::set_has_operator_() {
  _has_bits_[0] |= 0x01000000u;
}
void Token::clear_has_operator_() {
  _has_bits_[0] &= ~0x01000000u;
}
void Token::clear_operator_() {
  if (operator__ != NULL) operator__->::edu::stanford::nlp::pipeline::Operator::Clear();
  clear_has_operator_();
}
const ::edu::stanford::nlp::pipeline::Operator& Token::operator_() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.operator)
  return operator__ != NULL ? *operator__ : *default_instance_->operator__;
}
::edu::stanford::nlp::pipeline::Operator* Token::mutable_operator_() {
  set_has_operator_();
  if (operator__ == NULL) {
    operator__ = new ::edu::stanford::nlp::pipeline::Operator;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.operator)
  return operator__;
}
::edu::stanford::nlp::pipeline::Operator* Token::release_operator_() {
  clear_has_operator_();
  ::edu::stanford::nlp::pipeline::Operator* temp = operator__;
  operator__ = NULL;
  return temp;
}
void Token::set_allocated_operator_(::edu::stanford::nlp::pipeline::Operator* operator_) {
  delete operator__;
  operator__ = operator_;
  if (operator_) {
    set_has_operator_();
  } else {
    clear_has_operator_();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.operator)
}

// optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
bool Token::has_polarity() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void Token::set_has_polarity() {
  _has_bits_[0] |= 0x02000000u;
}
void Token::clear_has_polarity() {
  _has_bits_[0] &= ~0x02000000u;
}
void Token::clear_polarity() {
  if (polarity_ != NULL) polarity_->::edu::stanford::nlp::pipeline::Polarity::Clear();
  clear_has_polarity();
}
const ::edu::stanford::nlp::pipeline::Polarity& Token::polarity() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.polarity)
  return polarity_ != NULL ? *polarity_ : *default_instance_->polarity_;
}
::edu::stanford::nlp::pipeline::Polarity* Token::mutable_polarity() {
  set_has_polarity();
  if (polarity_ == NULL) {
    polarity_ = new ::edu::stanford::nlp::pipeline::Polarity;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.polarity)
  return polarity_;
}
::edu::stanford::nlp::pipeline::Polarity* Token::release_polarity() {
  clear_has_polarity();
  ::edu::stanford::nlp::pipeline::Polarity* temp = polarity_;
  polarity_ = NULL;
  return temp;
}
void Token::set_allocated_polarity(::edu::stanford::nlp::pipeline::Polarity* polarity) {
  delete polarity_;
  polarity_ = polarity;
  if (polarity) {
    set_has_polarity();
  } else {
    clear_has_polarity();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.polarity)
}

// optional .edu.stanford.nlp.pipeline.Span span = 29;
bool Token::has_span() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void Token::set_has_span() {
  _has_bits_[0] |= 0x04000000u;
}
void Token::clear_has_span() {
  _has_bits_[0] &= ~0x04000000u;
}
void Token::clear_span() {
  if (span_ != NULL) span_->::edu::stanford::nlp::pipeline::Span::Clear();
  clear_has_span();
}
const ::edu::stanford::nlp::pipeline::Span& Token::span() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.span)
  return span_ != NULL ? *span_ : *default_instance_->span_;
}
::edu::stanford::nlp::pipeline::Span* Token::mutable_span() {
  set_has_span();
  if (span_ == NULL) {
    span_ = new ::edu::stanford::nlp::pipeline::Span;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.span)
  return span_;
}
::edu::stanford::nlp::pipeline::Span* Token::release_span() {
  clear_has_span();
  ::edu::stanford::nlp::pipeline::Span* temp = span_;
  span_ = NULL;
  return temp;
}
void Token::set_allocated_span(::edu::stanford::nlp::pipeline::Span* span) {
  delete span_;
  span_ = span;
  if (span) {
    set_has_span();
  } else {
    clear_has_span();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.span)
}

// optional string sentiment = 30;
bool Token::has_sentiment() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void Token::set_has_sentiment() {
  _has_bits_[0] |= 0x08000000u;
}
void Token::clear_has_sentiment() {
  _has_bits_[0] &= ~0x08000000u;
}
void Token::clear_sentiment() {
  sentiment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentiment();
}
 const ::std::string& Token::sentiment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.sentiment)
  return sentiment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_sentiment(const ::std::string& value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.sentiment)
}
 void Token::set_sentiment(const char* value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.sentiment)
}
 void Token::set_sentiment(const char* value, size_t size) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.sentiment)
}
 ::std::string* Token::mutable_sentiment() {
  set_has_sentiment();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.sentiment)
  return sentiment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_sentiment() {
  clear_has_sentiment();
  return sentiment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_sentiment(::std::string* sentiment) {
  if (sentiment != NULL) {
    set_has_sentiment();
  } else {
    clear_has_sentiment();
  }
  sentiment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentiment);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.sentiment)
}

// optional int32 quotationIndex = 31;
bool Token::has_quotationindex() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
void Token::set_has_quotationindex() {
  _has_bits_[0] |= 0x10000000u;
}
void Token::clear_has_quotationindex() {
  _has_bits_[0] &= ~0x10000000u;
}
void Token::clear_quotationindex() {
  quotationindex_ = 0;
  clear_has_quotationindex();
}
 ::google::protobuf::int32 Token::quotationindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.quotationIndex)
  return quotationindex_;
}
 void Token::set_quotationindex(::google::protobuf::int32 value) {
  set_has_quotationindex();
  quotationindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.quotationIndex)
}

// optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
bool Token::has_conllufeatures() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
void Token::set_has_conllufeatures() {
  _has_bits_[0] |= 0x20000000u;
}
void Token::clear_has_conllufeatures() {
  _has_bits_[0] &= ~0x20000000u;
}
void Token::clear_conllufeatures() {
  if (conllufeatures_ != NULL) conllufeatures_->::edu::stanford::nlp::pipeline::MapStringString::Clear();
  clear_has_conllufeatures();
}
const ::edu::stanford::nlp::pipeline::MapStringString& Token::conllufeatures() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUFeatures)
  return conllufeatures_ != NULL ? *conllufeatures_ : *default_instance_->conllufeatures_;
}
::edu::stanford::nlp::pipeline::MapStringString* Token::mutable_conllufeatures() {
  set_has_conllufeatures();
  if (conllufeatures_ == NULL) {
    conllufeatures_ = new ::edu::stanford::nlp::pipeline::MapStringString;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUFeatures)
  return conllufeatures_;
}
::edu::stanford::nlp::pipeline::MapStringString* Token::release_conllufeatures() {
  clear_has_conllufeatures();
  ::edu::stanford::nlp::pipeline::MapStringString* temp = conllufeatures_;
  conllufeatures_ = NULL;
  return temp;
}
void Token::set_allocated_conllufeatures(::edu::stanford::nlp::pipeline::MapStringString* conllufeatures) {
  delete conllufeatures_;
  conllufeatures_ = conllufeatures;
  if (conllufeatures) {
    set_has_conllufeatures();
  } else {
    clear_has_conllufeatures();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUFeatures)
}

// optional string coarseTag = 33;
bool Token::has_coarsetag() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
void Token::set_has_coarsetag() {
  _has_bits_[0] |= 0x40000000u;
}
void Token::clear_has_coarsetag() {
  _has_bits_[0] &= ~0x40000000u;
}
void Token::clear_coarsetag() {
  coarsetag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coarsetag();
}
 const ::std::string& Token::coarsetag() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.coarseTag)
  return coarsetag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_coarsetag(const ::std::string& value) {
  set_has_coarsetag();
  coarsetag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.coarseTag)
}
 void Token::set_coarsetag(const char* value) {
  set_has_coarsetag();
  coarsetag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.coarseTag)
}
 void Token::set_coarsetag(const char* value, size_t size) {
  set_has_coarsetag();
  coarsetag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.coarseTag)
}
 ::std::string* Token::mutable_coarsetag() {
  set_has_coarsetag();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.coarseTag)
  return coarsetag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_coarsetag() {
  clear_has_coarsetag();
  return coarsetag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_coarsetag(::std::string* coarsetag) {
  if (coarsetag != NULL) {
    set_has_coarsetag();
  } else {
    clear_has_coarsetag();
  }
  coarsetag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coarsetag);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.coarseTag)
}

// optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
bool Token::has_conllutokenspan() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
void Token::set_has_conllutokenspan() {
  _has_bits_[0] |= 0x80000000u;
}
void Token::clear_has_conllutokenspan() {
  _has_bits_[0] &= ~0x80000000u;
}
void Token::clear_conllutokenspan() {
  if (conllutokenspan_ != NULL) conllutokenspan_->::edu::stanford::nlp::pipeline::Span::Clear();
  clear_has_conllutokenspan();
}
const ::edu::stanford::nlp::pipeline::Span& Token::conllutokenspan() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUTokenSpan)
  return conllutokenspan_ != NULL ? *conllutokenspan_ : *default_instance_->conllutokenspan_;
}
::edu::stanford::nlp::pipeline::Span* Token::mutable_conllutokenspan() {
  set_has_conllutokenspan();
  if (conllutokenspan_ == NULL) {
    conllutokenspan_ = new ::edu::stanford::nlp::pipeline::Span;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUTokenSpan)
  return conllutokenspan_;
}
::edu::stanford::nlp::pipeline::Span* Token::release_conllutokenspan() {
  clear_has_conllutokenspan();
  ::edu::stanford::nlp::pipeline::Span* temp = conllutokenspan_;
  conllutokenspan_ = NULL;
  return temp;
}
void Token::set_allocated_conllutokenspan(::edu::stanford::nlp::pipeline::Span* conllutokenspan) {
  delete conllutokenspan_;
  conllutokenspan_ = conllutokenspan;
  if (conllutokenspan) {
    set_has_conllutokenspan();
  } else {
    clear_has_conllutokenspan();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUTokenSpan)
}

// optional string conllUMisc = 35;
bool Token::has_conllumisc() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
void Token::set_has_conllumisc() {
  _has_bits_[1] |= 0x00000001u;
}
void Token::clear_has_conllumisc() {
  _has_bits_[1] &= ~0x00000001u;
}
void Token::clear_conllumisc() {
  conllumisc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_conllumisc();
}
 const ::std::string& Token::conllumisc() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUMisc)
  return conllumisc_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_conllumisc(const ::std::string& value) {
  set_has_conllumisc();
  conllumisc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.conllUMisc)
}
 void Token::set_conllumisc(const char* value) {
  set_has_conllumisc();
  conllumisc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.conllUMisc)
}
 void Token::set_conllumisc(const char* value, size_t size) {
  set_has_conllumisc();
  conllumisc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.conllUMisc)
}
 ::std::string* Token::mutable_conllumisc() {
  set_has_conllumisc();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUMisc)
  return conllumisc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_conllumisc() {
  clear_has_conllumisc();
  return conllumisc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_conllumisc(::std::string* conllumisc) {
  if (conllumisc != NULL) {
    set_has_conllumisc();
  } else {
    clear_has_conllumisc();
  }
  conllumisc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conllumisc);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUMisc)
}

// optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
bool Token::has_conllusecondarydeps() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
void Token::set_has_conllusecondarydeps() {
  _has_bits_[1] |= 0x00000002u;
}
void Token::clear_has_conllusecondarydeps() {
  _has_bits_[1] &= ~0x00000002u;
}
void Token::clear_conllusecondarydeps() {
  if (conllusecondarydeps_ != NULL) conllusecondarydeps_->::edu::stanford::nlp::pipeline::MapIntString::Clear();
  clear_has_conllusecondarydeps();
}
const ::edu::stanford::nlp::pipeline::MapIntString& Token::conllusecondarydeps() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUSecondaryDeps)
  return conllusecondarydeps_ != NULL ? *conllusecondarydeps_ : *default_instance_->conllusecondarydeps_;
}
::edu::stanford::nlp::pipeline::MapIntString* Token::mutable_conllusecondarydeps() {
  set_has_conllusecondarydeps();
  if (conllusecondarydeps_ == NULL) {
    conllusecondarydeps_ = new ::edu::stanford::nlp::pipeline::MapIntString;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUSecondaryDeps)
  return conllusecondarydeps_;
}
::edu::stanford::nlp::pipeline::MapIntString* Token::release_conllusecondarydeps() {
  clear_has_conllusecondarydeps();
  ::edu::stanford::nlp::pipeline::MapIntString* temp = conllusecondarydeps_;
  conllusecondarydeps_ = NULL;
  return temp;
}
void Token::set_allocated_conllusecondarydeps(::edu::stanford::nlp::pipeline::MapIntString* conllusecondarydeps) {
  delete conllusecondarydeps_;
  conllusecondarydeps_ = conllusecondarydeps;
  if (conllusecondarydeps) {
    set_has_conllusecondarydeps();
  } else {
    clear_has_conllusecondarydeps();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUSecondaryDeps)
}

// optional string wikipediaEntity = 37;
bool Token::has_wikipediaentity() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
void Token::set_has_wikipediaentity() {
  _has_bits_[1] |= 0x00000004u;
}
void Token::clear_has_wikipediaentity() {
  _has_bits_[1] &= ~0x00000004u;
}
void Token::clear_wikipediaentity() {
  wikipediaentity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wikipediaentity();
}
 const ::std::string& Token::wikipediaentity() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
  return wikipediaentity_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_wikipediaentity(const ::std::string& value) {
  set_has_wikipediaentity();
  wikipediaentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}
 void Token::set_wikipediaentity(const char* value) {
  set_has_wikipediaentity();
  wikipediaentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}
 void Token::set_wikipediaentity(const char* value, size_t size) {
  set_has_wikipediaentity();
  wikipediaentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}
 ::std::string* Token::mutable_wikipediaentity() {
  set_has_wikipediaentity();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
  return wikipediaentity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_wikipediaentity() {
  clear_has_wikipediaentity();
  return wikipediaentity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_wikipediaentity(::std::string* wikipediaentity) {
  if (wikipediaentity != NULL) {
    set_has_wikipediaentity();
  } else {
    clear_has_wikipediaentity();
  }
  wikipediaentity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wikipediaentity);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}

// optional string gender = 51;
bool Token::has_gender() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
void Token::set_has_gender() {
  _has_bits_[1] |= 0x00000008u;
}
void Token::clear_has_gender() {
  _has_bits_[1] &= ~0x00000008u;
}
void Token::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
 const ::std::string& Token::gender() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.gender)
  return gender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.gender)
}
 void Token::set_gender(const char* value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.gender)
}
 void Token::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.gender)
}
 ::std::string* Token::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_gender() {
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.gender)
}

// optional string trueCase = 52;
bool Token::has_truecase() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
void Token::set_has_truecase() {
  _has_bits_[1] |= 0x00000010u;
}
void Token::clear_has_truecase() {
  _has_bits_[1] &= ~0x00000010u;
}
void Token::clear_truecase() {
  truecase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_truecase();
}
 const ::std::string& Token::truecase() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.trueCase)
  return truecase_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_truecase(const ::std::string& value) {
  set_has_truecase();
  truecase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.trueCase)
}
 void Token::set_truecase(const char* value) {
  set_has_truecase();
  truecase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.trueCase)
}
 void Token::set_truecase(const char* value, size_t size) {
  set_has_truecase();
  truecase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.trueCase)
}
 ::std::string* Token::mutable_truecase() {
  set_has_truecase();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.trueCase)
  return truecase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_truecase() {
  clear_has_truecase();
  return truecase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_truecase(::std::string* truecase) {
  if (truecase != NULL) {
    set_has_truecase();
  } else {
    clear_has_truecase();
  }
  truecase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), truecase);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.trueCase)
}

// optional string trueCaseText = 53;
bool Token::has_truecasetext() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
void Token::set_has_truecasetext() {
  _has_bits_[1] |= 0x00000020u;
}
void Token::clear_has_truecasetext() {
  _has_bits_[1] &= ~0x00000020u;
}
void Token::clear_truecasetext() {
  truecasetext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_truecasetext();
}
 const ::std::string& Token::truecasetext() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.trueCaseText)
  return truecasetext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_truecasetext(const ::std::string& value) {
  set_has_truecasetext();
  truecasetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.trueCaseText)
}
 void Token::set_truecasetext(const char* value) {
  set_has_truecasetext();
  truecasetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.trueCaseText)
}
 void Token::set_truecasetext(const char* value, size_t size) {
  set_has_truecasetext();
  truecasetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.trueCaseText)
}
 ::std::string* Token::mutable_truecasetext() {
  set_has_truecasetext();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.trueCaseText)
  return truecasetext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Token::release_truecasetext() {
  clear_has_truecasetext();
  return truecasetext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Token::set_allocated_truecasetext(::std::string* truecasetext) {
  if (truecasetext != NULL) {
    set_has_truecasetext();
  } else {
    clear_has_truecasetext();
  }
  truecasetext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), truecasetext);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.trueCaseText)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quote::kTextFieldNumber;
const int Quote::kBeginFieldNumber;
const int Quote::kEndFieldNumber;
const int Quote::kSentenceBeginFieldNumber;
const int Quote::kSentenceEndFieldNumber;
const int Quote::kTokenBeginFieldNumber;
const int Quote::kTokenEndFieldNumber;
const int Quote::kDocidFieldNumber;
const int Quote::kIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quote::Quote()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Quote)
}

void Quote::InitAsDefaultInstance() {
}

Quote::Quote(const Quote& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Quote)
}

void Quote::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  begin_ = 0u;
  end_ = 0u;
  sentencebegin_ = 0u;
  sentenceend_ = 0u;
  tokenbegin_ = 0u;
  tokenend_ = 0u;
  docid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Quote::~Quote() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Quote)
  SharedDtor();
}

void Quote::SharedDtor() {
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  docid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Quote::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Quote::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Quote_descriptor_;
}

const Quote& Quote::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Quote* Quote::default_instance_ = NULL;

Quote* Quote::New(::google::protobuf::Arena* arena) const {
  Quote* n = new Quote;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Quote::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Quote*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(begin_, tokenend_);
    if (has_text()) {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_docid()) {
      docid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  index_ = 0u;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Quote::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Quote)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Quote.text");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_begin;
        break;
      }

      // optional uint32 begin = 2;
      case 2: {
        if (tag == 16) {
         parse_begin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_)));
          set_has_begin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_end;
        break;
      }

      // optional uint32 end = 3;
      case 3: {
        if (tag == 24) {
         parse_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_)));
          set_has_end();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_sentenceBegin;
        break;
      }

      // optional uint32 sentenceBegin = 5;
      case 5: {
        if (tag == 40) {
         parse_sentenceBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentencebegin_)));
          set_has_sentencebegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_sentenceEnd;
        break;
      }

      // optional uint32 sentenceEnd = 6;
      case 6: {
        if (tag == 48) {
         parse_sentenceEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentenceend_)));
          set_has_sentenceend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tokenBegin;
        break;
      }

      // optional uint32 tokenBegin = 7;
      case 7: {
        if (tag == 56) {
         parse_tokenBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenbegin_)));
          set_has_tokenbegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_tokenEnd;
        break;
      }

      // optional uint32 tokenEnd = 8;
      case 8: {
        if (tag == 64) {
         parse_tokenEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenend_)));
          set_has_tokenend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_docid;
        break;
      }

      // optional string docid = 9;
      case 9: {
        if (tag == 74) {
         parse_docid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_docid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->docid().data(), this->docid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Quote.docid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_index;
        break;
      }

      // optional uint32 index = 10;
      case 10: {
        if (tag == 80) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Quote)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Quote)
  return false;
#undef DO_
}

void Quote::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Quote)
  // optional string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Quote.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->text(), output);
  }

  // optional uint32 begin = 2;
  if (has_begin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->begin(), output);
  }

  // optional uint32 end = 3;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->end(), output);
  }

  // optional uint32 sentenceBegin = 5;
  if (has_sentencebegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sentencebegin(), output);
  }

  // optional uint32 sentenceEnd = 6;
  if (has_sentenceend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->sentenceend(), output);
  }

  // optional uint32 tokenBegin = 7;
  if (has_tokenbegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->tokenbegin(), output);
  }

  // optional uint32 tokenEnd = 8;
  if (has_tokenend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->tokenend(), output);
  }

  // optional string docid = 9;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Quote.docid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->docid(), output);
  }

  // optional uint32 index = 10;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Quote)
}

::google::protobuf::uint8* Quote::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Quote)
  // optional string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Quote.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->text(), target);
  }

  // optional uint32 begin = 2;
  if (has_begin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->begin(), target);
  }

  // optional uint32 end = 3;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->end(), target);
  }

  // optional uint32 sentenceBegin = 5;
  if (has_sentencebegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->sentencebegin(), target);
  }

  // optional uint32 sentenceEnd = 6;
  if (has_sentenceend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->sentenceend(), target);
  }

  // optional uint32 tokenBegin = 7;
  if (has_tokenbegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->tokenbegin(), target);
  }

  // optional uint32 tokenEnd = 8;
  if (has_tokenend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->tokenend(), target);
  }

  // optional string docid = 9;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Quote.docid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->docid(), target);
  }

  // optional uint32 index = 10;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Quote)
  return target;
}

int Quote::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string text = 1;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional uint32 begin = 2;
    if (has_begin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin());
    }

    // optional uint32 end = 3;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end());
    }

    // optional uint32 sentenceBegin = 5;
    if (has_sentencebegin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentencebegin());
    }

    // optional uint32 sentenceEnd = 6;
    if (has_sentenceend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentenceend());
    }

    // optional uint32 tokenBegin = 7;
    if (has_tokenbegin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tokenbegin());
    }

    // optional uint32 tokenEnd = 8;
    if (has_tokenend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tokenend());
    }

    // optional string docid = 9;
    if (has_docid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->docid());
    }

  }
  // optional uint32 index = 10;
  if (has_index()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Quote::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Quote* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Quote>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Quote::MergeFrom(const Quote& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_text()) {
      set_has_text();
      text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (from.has_begin()) {
      set_begin(from.begin());
    }
    if (from.has_end()) {
      set_end(from.end());
    }
    if (from.has_sentencebegin()) {
      set_sentencebegin(from.sentencebegin());
    }
    if (from.has_sentenceend()) {
      set_sentenceend(from.sentenceend());
    }
    if (from.has_tokenbegin()) {
      set_tokenbegin(from.tokenbegin());
    }
    if (from.has_tokenend()) {
      set_tokenend(from.tokenend());
    }
    if (from.has_docid()) {
      set_has_docid();
      docid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.docid_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Quote::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quote::CopyFrom(const Quote& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quote::IsInitialized() const {

  return true;
}

void Quote::Swap(Quote* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quote::InternalSwap(Quote* other) {
  text_.Swap(&other->text_);
  std::swap(begin_, other->begin_);
  std::swap(end_, other->end_);
  std::swap(sentencebegin_, other->sentencebegin_);
  std::swap(sentenceend_, other->sentenceend_);
  std::swap(tokenbegin_, other->tokenbegin_);
  std::swap(tokenend_, other->tokenend_);
  docid_.Swap(&other->docid_);
  std::swap(index_, other->index_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Quote::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Quote_descriptor_;
  metadata.reflection = Quote_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Quote

// optional string text = 1;
bool Quote::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Quote::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
void Quote::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
void Quote::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
 const ::std::string& Quote::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Quote::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.text)
}
 void Quote::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Quote.text)
}
 void Quote::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Quote.text)
}
 ::std::string* Quote::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Quote.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Quote::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Quote::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Quote.text)
}

// optional uint32 begin = 2;
bool Quote::has_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Quote::set_has_begin() {
  _has_bits_[0] |= 0x00000002u;
}
void Quote::clear_has_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
void Quote::clear_begin() {
  begin_ = 0u;
  clear_has_begin();
}
 ::google::protobuf::uint32 Quote::begin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.begin)
  return begin_;
}
 void Quote::set_begin(::google::protobuf::uint32 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.begin)
}

// optional uint32 end = 3;
bool Quote::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Quote::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
void Quote::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
void Quote::clear_end() {
  end_ = 0u;
  clear_has_end();
}
 ::google::protobuf::uint32 Quote::end() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.end)
  return end_;
}
 void Quote::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.end)
}

// optional uint32 sentenceBegin = 5;
bool Quote::has_sentencebegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Quote::set_has_sentencebegin() {
  _has_bits_[0] |= 0x00000008u;
}
void Quote::clear_has_sentencebegin() {
  _has_bits_[0] &= ~0x00000008u;
}
void Quote::clear_sentencebegin() {
  sentencebegin_ = 0u;
  clear_has_sentencebegin();
}
 ::google::protobuf::uint32 Quote::sentencebegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.sentenceBegin)
  return sentencebegin_;
}
 void Quote::set_sentencebegin(::google::protobuf::uint32 value) {
  set_has_sentencebegin();
  sentencebegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.sentenceBegin)
}

// optional uint32 sentenceEnd = 6;
bool Quote::has_sentenceend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Quote::set_has_sentenceend() {
  _has_bits_[0] |= 0x00000010u;
}
void Quote::clear_has_sentenceend() {
  _has_bits_[0] &= ~0x00000010u;
}
void Quote::clear_sentenceend() {
  sentenceend_ = 0u;
  clear_has_sentenceend();
}
 ::google::protobuf::uint32 Quote::sentenceend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.sentenceEnd)
  return sentenceend_;
}
 void Quote::set_sentenceend(::google::protobuf::uint32 value) {
  set_has_sentenceend();
  sentenceend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.sentenceEnd)
}

// optional uint32 tokenBegin = 7;
bool Quote::has_tokenbegin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Quote::set_has_tokenbegin() {
  _has_bits_[0] |= 0x00000020u;
}
void Quote::clear_has_tokenbegin() {
  _has_bits_[0] &= ~0x00000020u;
}
void Quote::clear_tokenbegin() {
  tokenbegin_ = 0u;
  clear_has_tokenbegin();
}
 ::google::protobuf::uint32 Quote::tokenbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.tokenBegin)
  return tokenbegin_;
}
 void Quote::set_tokenbegin(::google::protobuf::uint32 value) {
  set_has_tokenbegin();
  tokenbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.tokenBegin)
}

// optional uint32 tokenEnd = 8;
bool Quote::has_tokenend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Quote::set_has_tokenend() {
  _has_bits_[0] |= 0x00000040u;
}
void Quote::clear_has_tokenend() {
  _has_bits_[0] &= ~0x00000040u;
}
void Quote::clear_tokenend() {
  tokenend_ = 0u;
  clear_has_tokenend();
}
 ::google::protobuf::uint32 Quote::tokenend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.tokenEnd)
  return tokenend_;
}
 void Quote::set_tokenend(::google::protobuf::uint32 value) {
  set_has_tokenend();
  tokenend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.tokenEnd)
}

// optional string docid = 9;
bool Quote::has_docid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Quote::set_has_docid() {
  _has_bits_[0] |= 0x00000080u;
}
void Quote::clear_has_docid() {
  _has_bits_[0] &= ~0x00000080u;
}
void Quote::clear_docid() {
  docid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docid();
}
 const ::std::string& Quote::docid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.docid)
  return docid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Quote::set_docid(const ::std::string& value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.docid)
}
 void Quote::set_docid(const char* value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Quote.docid)
}
 void Quote::set_docid(const char* value, size_t size) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Quote.docid)
}
 ::std::string* Quote::mutable_docid() {
  set_has_docid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Quote.docid)
  return docid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Quote::release_docid() {
  clear_has_docid();
  return docid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Quote::set_allocated_docid(::std::string* docid) {
  if (docid != NULL) {
    set_has_docid();
  } else {
    clear_has_docid();
  }
  docid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Quote.docid)
}

// optional uint32 index = 10;
bool Quote::has_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Quote::set_has_index() {
  _has_bits_[0] |= 0x00000100u;
}
void Quote::clear_has_index() {
  _has_bits_[0] &= ~0x00000100u;
}
void Quote::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 Quote::index() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.index)
  return index_;
}
 void Quote::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ParseTree::kChildFieldNumber;
const int ParseTree::kValueFieldNumber;
const int ParseTree::kYieldBeginIndexFieldNumber;
const int ParseTree::kYieldEndIndexFieldNumber;
const int ParseTree::kScoreFieldNumber;
const int ParseTree::kSentimentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ParseTree::ParseTree()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.ParseTree)
}

void ParseTree::InitAsDefaultInstance() {
}

ParseTree::ParseTree(const ParseTree& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.ParseTree)
}

void ParseTree::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  yieldbeginindex_ = 0u;
  yieldendindex_ = 0u;
  score_ = 0;
  sentiment_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParseTree::~ParseTree() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.ParseTree)
  SharedDtor();
}

void ParseTree::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ParseTree::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParseTree::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParseTree_descriptor_;
}

const ParseTree& ParseTree::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

ParseTree* ParseTree::default_instance_ = NULL;

ParseTree* ParseTree::New(::google::protobuf::Arena* arena) const {
  ParseTree* n = new ParseTree;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ParseTree::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ParseTree*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 62u) {
    ZR_(yieldbeginindex_, sentiment_);
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  child_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ParseTree::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.ParseTree)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_child:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_child()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_child;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.ParseTree.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_yieldBeginIndex;
        break;
      }

      // optional uint32 yieldBeginIndex = 3;
      case 3: {
        if (tag == 24) {
         parse_yieldBeginIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &yieldbeginindex_)));
          set_has_yieldbeginindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_yieldEndIndex;
        break;
      }

      // optional uint32 yieldEndIndex = 4;
      case 4: {
        if (tag == 32) {
         parse_yieldEndIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &yieldendindex_)));
          set_has_yieldendindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_score;
        break;
      }

      // optional double score = 5;
      case 5: {
        if (tag == 41) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_sentiment;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
      case 6: {
        if (tag == 48) {
         parse_sentiment:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::Sentiment_IsValid(value)) {
            set_sentiment(static_cast< ::edu::stanford::nlp::pipeline::Sentiment >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.ParseTree)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.ParseTree)
  return false;
#undef DO_
}

void ParseTree::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.ParseTree)
  // repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
  for (unsigned int i = 0, n = this->child_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->child(i), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.ParseTree.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  // optional uint32 yieldBeginIndex = 3;
  if (has_yieldbeginindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->yieldbeginindex(), output);
  }

  // optional uint32 yieldEndIndex = 4;
  if (has_yieldendindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->yieldendindex(), output);
  }

  // optional double score = 5;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->score(), output);
  }

  // optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
  if (has_sentiment()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->sentiment(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.ParseTree)
}

::google::protobuf::uint8* ParseTree::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.ParseTree)
  // repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
  for (unsigned int i = 0, n = this->child_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->child(i), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.ParseTree.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  // optional uint32 yieldBeginIndex = 3;
  if (has_yieldbeginindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->yieldbeginindex(), target);
  }

  // optional uint32 yieldEndIndex = 4;
  if (has_yieldendindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->yieldendindex(), target);
  }

  // optional double score = 5;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->score(), target);
  }

  // optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
  if (has_sentiment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->sentiment(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.ParseTree)
  return target;
}

int ParseTree::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & 62u) {
    // optional string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional uint32 yieldBeginIndex = 3;
    if (has_yieldbeginindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->yieldbeginindex());
    }

    // optional uint32 yieldEndIndex = 4;
    if (has_yieldendindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->yieldendindex());
    }

    // optional double score = 5;
    if (has_score()) {
      total_size += 1 + 8;
    }

    // optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
    if (has_sentiment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sentiment());
    }

  }
  // repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
  total_size += 1 * this->child_size();
  for (int i = 0; i < this->child_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->child(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParseTree::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ParseTree* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ParseTree>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ParseTree::MergeFrom(const ParseTree& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  child_.MergeFrom(from.child_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_yieldbeginindex()) {
      set_yieldbeginindex(from.yieldbeginindex());
    }
    if (from.has_yieldendindex()) {
      set_yieldendindex(from.yieldendindex());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_sentiment()) {
      set_sentiment(from.sentiment());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ParseTree::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParseTree::CopyFrom(const ParseTree& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParseTree::IsInitialized() const {

  return true;
}

void ParseTree::Swap(ParseTree* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ParseTree::InternalSwap(ParseTree* other) {
  child_.UnsafeArenaSwap(&other->child_);
  value_.Swap(&other->value_);
  std::swap(yieldbeginindex_, other->yieldbeginindex_);
  std::swap(yieldendindex_, other->yieldendindex_);
  std::swap(score_, other->score_);
  std::swap(sentiment_, other->sentiment_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ParseTree::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ParseTree_descriptor_;
  metadata.reflection = ParseTree_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ParseTree

// repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
int ParseTree::child_size() const {
  return child_.size();
}
void ParseTree::clear_child() {
  child_.Clear();
}
const ::edu::stanford::nlp::pipeline::ParseTree& ParseTree::child(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_.Get(index);
}
::edu::stanford::nlp::pipeline::ParseTree* ParseTree::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_.Mutable(index);
}
::edu::stanford::nlp::pipeline::ParseTree* ParseTree::add_child() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >*
ParseTree::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.ParseTree.child)
  return &child_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >&
ParseTree::child() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_;
}

// optional string value = 2;
bool ParseTree::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ParseTree::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void ParseTree::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void ParseTree::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& ParseTree::value() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ParseTree::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.value)
}
 void ParseTree::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.ParseTree.value)
}
 void ParseTree::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.ParseTree.value)
}
 ::std::string* ParseTree::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.ParseTree.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ParseTree::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ParseTree::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.ParseTree.value)
}

// optional uint32 yieldBeginIndex = 3;
bool ParseTree::has_yieldbeginindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ParseTree::set_has_yieldbeginindex() {
  _has_bits_[0] |= 0x00000004u;
}
void ParseTree::clear_has_yieldbeginindex() {
  _has_bits_[0] &= ~0x00000004u;
}
void ParseTree::clear_yieldbeginindex() {
  yieldbeginindex_ = 0u;
  clear_has_yieldbeginindex();
}
 ::google::protobuf::uint32 ParseTree::yieldbeginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.yieldBeginIndex)
  return yieldbeginindex_;
}
 void ParseTree::set_yieldbeginindex(::google::protobuf::uint32 value) {
  set_has_yieldbeginindex();
  yieldbeginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.yieldBeginIndex)
}

// optional uint32 yieldEndIndex = 4;
bool ParseTree::has_yieldendindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ParseTree::set_has_yieldendindex() {
  _has_bits_[0] |= 0x00000008u;
}
void ParseTree::clear_has_yieldendindex() {
  _has_bits_[0] &= ~0x00000008u;
}
void ParseTree::clear_yieldendindex() {
  yieldendindex_ = 0u;
  clear_has_yieldendindex();
}
 ::google::protobuf::uint32 ParseTree::yieldendindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.yieldEndIndex)
  return yieldendindex_;
}
 void ParseTree::set_yieldendindex(::google::protobuf::uint32 value) {
  set_has_yieldendindex();
  yieldendindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.yieldEndIndex)
}

// optional double score = 5;
bool ParseTree::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ParseTree::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
void ParseTree::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
void ParseTree::clear_score() {
  score_ = 0;
  clear_has_score();
}
 double ParseTree::score() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.score)
  return score_;
}
 void ParseTree::set_score(double value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.score)
}

// optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
bool ParseTree::has_sentiment() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ParseTree::set_has_sentiment() {
  _has_bits_[0] |= 0x00000020u;
}
void ParseTree::clear_has_sentiment() {
  _has_bits_[0] &= ~0x00000020u;
}
void ParseTree::clear_sentiment() {
  sentiment_ = 0;
  clear_has_sentiment();
}
 ::edu::stanford::nlp::pipeline::Sentiment ParseTree::sentiment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.sentiment)
  return static_cast< ::edu::stanford::nlp::pipeline::Sentiment >(sentiment_);
}
 void ParseTree::set_sentiment(::edu::stanford::nlp::pipeline::Sentiment value) {
  assert(::edu::stanford::nlp::pipeline::Sentiment_IsValid(value));
  set_has_sentiment();
  sentiment_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.sentiment)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DependencyGraph_Node::kSentenceIndexFieldNumber;
const int DependencyGraph_Node::kIndexFieldNumber;
const int DependencyGraph_Node::kCopyAnnotationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DependencyGraph_Node::DependencyGraph_Node()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.DependencyGraph.Node)
}

void DependencyGraph_Node::InitAsDefaultInstance() {
}

DependencyGraph_Node::DependencyGraph_Node(const DependencyGraph_Node& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.DependencyGraph.Node)
}

void DependencyGraph_Node::SharedCtor() {
  _cached_size_ = 0;
  sentenceindex_ = 0u;
  index_ = 0u;
  copyannotation_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DependencyGraph_Node::~DependencyGraph_Node() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  SharedDtor();
}

void DependencyGraph_Node::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DependencyGraph_Node::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DependencyGraph_Node::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DependencyGraph_Node_descriptor_;
}

const DependencyGraph_Node& DependencyGraph_Node::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

DependencyGraph_Node* DependencyGraph_Node::default_instance_ = NULL;

DependencyGraph_Node* DependencyGraph_Node::New(::google::protobuf::Arena* arena) const {
  DependencyGraph_Node* n = new DependencyGraph_Node;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DependencyGraph_Node::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DependencyGraph_Node*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(sentenceindex_, copyannotation_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DependencyGraph_Node::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sentenceIndex = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentenceindex_)));
          set_has_sentenceindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // required uint32 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_copyAnnotation;
        break;
      }

      // optional uint32 copyAnnotation = 3;
      case 3: {
        if (tag == 24) {
         parse_copyAnnotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &copyannotation_)));
          set_has_copyannotation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  return false;
#undef DO_
}

void DependencyGraph_Node::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  // required uint32 sentenceIndex = 1;
  if (has_sentenceindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sentenceindex(), output);
  }

  // required uint32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->index(), output);
  }

  // optional uint32 copyAnnotation = 3;
  if (has_copyannotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->copyannotation(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.DependencyGraph.Node)
}

::google::protobuf::uint8* DependencyGraph_Node::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  // required uint32 sentenceIndex = 1;
  if (has_sentenceindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sentenceindex(), target);
  }

  // required uint32 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->index(), target);
  }

  // optional uint32 copyAnnotation = 3;
  if (has_copyannotation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->copyannotation(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.DependencyGraph.Node)
  return target;
}

int DependencyGraph_Node::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_sentenceindex()) {
    // required uint32 sentenceIndex = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->sentenceindex());
  }

  if (has_index()) {
    // required uint32 index = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());
  }

  return total_size;
}
int DependencyGraph_Node::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 sentenceIndex = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->sentenceindex());

    // required uint32 index = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional uint32 copyAnnotation = 3;
  if (has_copyannotation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->copyannotation());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DependencyGraph_Node::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DependencyGraph_Node* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DependencyGraph_Node>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DependencyGraph_Node::MergeFrom(const DependencyGraph_Node& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sentenceindex()) {
      set_sentenceindex(from.sentenceindex());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_copyannotation()) {
      set_copyannotation(from.copyannotation());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DependencyGraph_Node::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DependencyGraph_Node::CopyFrom(const DependencyGraph_Node& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DependencyGraph_Node::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DependencyGraph_Node::Swap(DependencyGraph_Node* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DependencyGraph_Node::InternalSwap(DependencyGraph_Node* other) {
  std::swap(sentenceindex_, other->sentenceindex_);
  std::swap(index_, other->index_);
  std::swap(copyannotation_, other->copyannotation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DependencyGraph_Node::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DependencyGraph_Node_descriptor_;
  metadata.reflection = DependencyGraph_Node_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DependencyGraph_Edge::kSourceFieldNumber;
const int DependencyGraph_Edge::kTargetFieldNumber;
const int DependencyGraph_Edge::kDepFieldNumber;
const int DependencyGraph_Edge::kIsExtraFieldNumber;
const int DependencyGraph_Edge::kSourceCopyFieldNumber;
const int DependencyGraph_Edge::kTargetCopyFieldNumber;
const int DependencyGraph_Edge::kLanguageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DependencyGraph_Edge::DependencyGraph_Edge()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
}

void DependencyGraph_Edge::InitAsDefaultInstance() {
}

DependencyGraph_Edge::DependencyGraph_Edge(const DependencyGraph_Edge& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
}

void DependencyGraph_Edge::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  source_ = 0u;
  target_ = 0u;
  dep_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  isextra_ = false;
  sourcecopy_ = 0u;
  targetcopy_ = 0u;
  language_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DependencyGraph_Edge::~DependencyGraph_Edge() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  SharedDtor();
}

void DependencyGraph_Edge::SharedDtor() {
  dep_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void DependencyGraph_Edge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DependencyGraph_Edge::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DependencyGraph_Edge_descriptor_;
}

const DependencyGraph_Edge& DependencyGraph_Edge::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

DependencyGraph_Edge* DependencyGraph_Edge::default_instance_ = NULL;

DependencyGraph_Edge* DependencyGraph_Edge::New(::google::protobuf::Arena* arena) const {
  DependencyGraph_Edge* n = new DependencyGraph_Edge;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DependencyGraph_Edge::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DependencyGraph_Edge*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(source_, target_);
    ZR_(isextra_, language_);
    if (has_dep()) {
      dep_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DependencyGraph_Edge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 source = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_)));
          set_has_source();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_target;
        break;
      }

      // required uint32 target = 2;
      case 2: {
        if (tag == 16) {
         parse_target:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_)));
          set_has_target();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_dep;
        break;
      }

      // optional string dep = 3;
      case 3: {
        if (tag == 26) {
         parse_dep:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dep()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->dep().data(), this->dep().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_isExtra;
        break;
      }

      // optional bool isExtra = 4;
      case 4: {
        if (tag == 32) {
         parse_isExtra:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isextra_)));
          set_has_isextra();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_sourceCopy;
        break;
      }

      // optional uint32 sourceCopy = 5;
      case 5: {
        if (tag == 40) {
         parse_sourceCopy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sourcecopy_)));
          set_has_sourcecopy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_targetCopy;
        break;
      }

      // optional uint32 targetCopy = 6;
      case 6: {
        if (tag == 48) {
         parse_targetCopy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &targetcopy_)));
          set_has_targetcopy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_language;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
      case 7: {
        if (tag == 56) {
         parse_language:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::Language_IsValid(value)) {
            set_language(static_cast< ::edu::stanford::nlp::pipeline::Language >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  return false;
#undef DO_
}

void DependencyGraph_Edge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  // required uint32 source = 1;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->source(), output);
  }

  // required uint32 target = 2;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target(), output);
  }

  // optional string dep = 3;
  if (has_dep()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dep().data(), this->dep().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->dep(), output);
  }

  // optional bool isExtra = 4;
  if (has_isextra()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isextra(), output);
  }

  // optional uint32 sourceCopy = 5;
  if (has_sourcecopy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sourcecopy(), output);
  }

  // optional uint32 targetCopy = 6;
  if (has_targetcopy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->targetcopy(), output);
  }

  // optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
  if (has_language()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->language(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
}

::google::protobuf::uint8* DependencyGraph_Edge::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  // required uint32 source = 1;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->source(), target);
  }

  // required uint32 target = 2;
  if (has_target()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->target(), target);
  }

  // optional string dep = 3;
  if (has_dep()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dep().data(), this->dep().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->dep(), target);
  }

  // optional bool isExtra = 4;
  if (has_isextra()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->isextra(), target);
  }

  // optional uint32 sourceCopy = 5;
  if (has_sourcecopy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->sourcecopy(), target);
  }

  // optional uint32 targetCopy = 6;
  if (has_targetcopy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->targetcopy(), target);
  }

  // optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
  if (has_language()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->language(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
  return target;
}

int DependencyGraph_Edge::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_source()) {
    // required uint32 source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->source());
  }

  if (has_target()) {
    // required uint32 target = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->target());
  }

  return total_size;
}
int DependencyGraph_Edge::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 source = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->source());

    // required uint32 target = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->target());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 124u) {
    // optional string dep = 3;
    if (has_dep()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dep());
    }

    // optional bool isExtra = 4;
    if (has_isextra()) {
      total_size += 1 + 1;
    }

    // optional uint32 sourceCopy = 5;
    if (has_sourcecopy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sourcecopy());
    }

    // optional uint32 targetCopy = 6;
    if (has_targetcopy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->targetcopy());
    }

    // optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->language());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DependencyGraph_Edge::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DependencyGraph_Edge* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DependencyGraph_Edge>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DependencyGraph_Edge::MergeFrom(const DependencyGraph_Edge& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source()) {
      set_source(from.source());
    }
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_dep()) {
      set_has_dep();
      dep_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dep_);
    }
    if (from.has_isextra()) {
      set_isextra(from.isextra());
    }
    if (from.has_sourcecopy()) {
      set_sourcecopy(from.sourcecopy());
    }
    if (from.has_targetcopy()) {
      set_targetcopy(from.targetcopy());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DependencyGraph_Edge::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DependencyGraph_Edge::CopyFrom(const DependencyGraph_Edge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DependencyGraph_Edge::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DependencyGraph_Edge::Swap(DependencyGraph_Edge* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DependencyGraph_Edge::InternalSwap(DependencyGraph_Edge* other) {
  std::swap(source_, other->source_);
  std::swap(target_, other->target_);
  dep_.Swap(&other->dep_);
  std::swap(isextra_, other->isextra_);
  std::swap(sourcecopy_, other->sourcecopy_);
  std::swap(targetcopy_, other->targetcopy_);
  std::swap(language_, other->language_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DependencyGraph_Edge::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DependencyGraph_Edge_descriptor_;
  metadata.reflection = DependencyGraph_Edge_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DependencyGraph::kNodeFieldNumber;
const int DependencyGraph::kEdgeFieldNumber;
const int DependencyGraph::kRootFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DependencyGraph::DependencyGraph()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.DependencyGraph)
}

void DependencyGraph::InitAsDefaultInstance() {
}

DependencyGraph::DependencyGraph(const DependencyGraph& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.DependencyGraph)
}

void DependencyGraph::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DependencyGraph::~DependencyGraph() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.DependencyGraph)
  SharedDtor();
}

void DependencyGraph::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DependencyGraph::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DependencyGraph::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DependencyGraph_descriptor_;
}

const DependencyGraph& DependencyGraph::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

DependencyGraph* DependencyGraph::default_instance_ = NULL;

DependencyGraph* DependencyGraph::New(::google::protobuf::Arena* arena) const {
  DependencyGraph* n = new DependencyGraph;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DependencyGraph::Clear() {
  node_.Clear();
  edge_.Clear();
  root_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DependencyGraph::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.DependencyGraph)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_node()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_node;
        if (input->ExpectTag(18)) goto parse_loop_edge;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_edge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_edge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_edge;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(26)) goto parse_root;
        break;
      }

      // repeated uint32 root = 3 [packed = true];
      case 3: {
        if (tag == 26) {
         parse_root:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_root())));
        } else if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 26, input, this->mutable_root())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.DependencyGraph)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.DependencyGraph)
  return false;
#undef DO_
}

void DependencyGraph::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.DependencyGraph)
  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
  for (unsigned int i = 0, n = this->node_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
  for (unsigned int i = 0, n = this->edge_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->edge(i), output);
  }

  // repeated uint32 root = 3 [packed = true];
  if (this->root_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_root_cached_byte_size_);
  }
  for (int i = 0; i < this->root_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->root(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.DependencyGraph)
}

::google::protobuf::uint8* DependencyGraph::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.DependencyGraph)
  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
  for (unsigned int i = 0, n = this->node_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
  for (unsigned int i = 0, n = this->edge_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->edge(i), target);
  }

  // repeated uint32 root = 3 [packed = true];
  if (this->root_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _root_cached_byte_size_, target);
  }
  for (int i = 0; i < this->root_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32NoTagToArray(this->root(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.DependencyGraph)
  return target;
}

int DependencyGraph::ByteSize() const {
  int total_size = 0;

  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
  total_size += 1 * this->node_size();
  for (int i = 0; i < this->node_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->node(i));
  }

  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
  total_size += 1 * this->edge_size();
  for (int i = 0; i < this->edge_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->edge(i));
  }

  // repeated uint32 root = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->root_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->root(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _root_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DependencyGraph::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DependencyGraph* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DependencyGraph>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DependencyGraph::MergeFrom(const DependencyGraph& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  node_.MergeFrom(from.node_);
  edge_.MergeFrom(from.edge_);
  root_.MergeFrom(from.root_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DependencyGraph::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DependencyGraph::CopyFrom(const DependencyGraph& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DependencyGraph::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->node())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->edge())) return false;
  return true;
}

void DependencyGraph::Swap(DependencyGraph* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DependencyGraph::InternalSwap(DependencyGraph* other) {
  node_.UnsafeArenaSwap(&other->node_);
  edge_.UnsafeArenaSwap(&other->edge_);
  root_.UnsafeArenaSwap(&other->root_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DependencyGraph::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DependencyGraph_descriptor_;
  metadata.reflection = DependencyGraph_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DependencyGraph_Node

// required uint32 sentenceIndex = 1;
bool DependencyGraph_Node::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DependencyGraph_Node::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000001u;
}
void DependencyGraph_Node::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000001u;
}
void DependencyGraph_Node::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
 ::google::protobuf::uint32 DependencyGraph_Node::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Node.sentenceIndex)
  return sentenceindex_;
}
 void DependencyGraph_Node::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Node.sentenceIndex)
}

// required uint32 index = 2;
bool DependencyGraph_Node::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DependencyGraph_Node::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
void DependencyGraph_Node::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
void DependencyGraph_Node::clear_index() {
  index_ = 0u;
  clear_has_index();
}
 ::google::protobuf::uint32 DependencyGraph_Node::index() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Node.index)
  return index_;
}
 void DependencyGraph_Node::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Node.index)
}

// optional uint32 copyAnnotation = 3;
bool DependencyGraph_Node::has_copyannotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DependencyGraph_Node::set_has_copyannotation() {
  _has_bits_[0] |= 0x00000004u;
}
void DependencyGraph_Node::clear_has_copyannotation() {
  _has_bits_[0] &= ~0x00000004u;
}
void DependencyGraph_Node::clear_copyannotation() {
  copyannotation_ = 0u;
  clear_has_copyannotation();
}
 ::google::protobuf::uint32 DependencyGraph_Node::copyannotation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Node.copyAnnotation)
  return copyannotation_;
}
 void DependencyGraph_Node::set_copyannotation(::google::protobuf::uint32 value) {
  set_has_copyannotation();
  copyannotation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Node.copyAnnotation)
}

// -------------------------------------------------------------------

// DependencyGraph_Edge

// required uint32 source = 1;
bool DependencyGraph_Edge::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DependencyGraph_Edge::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
void DependencyGraph_Edge::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
void DependencyGraph_Edge::clear_source() {
  source_ = 0u;
  clear_has_source();
}
 ::google::protobuf::uint32 DependencyGraph_Edge::source() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.source)
  return source_;
}
 void DependencyGraph_Edge::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.source)
}

// required uint32 target = 2;
bool DependencyGraph_Edge::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DependencyGraph_Edge::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
void DependencyGraph_Edge::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
void DependencyGraph_Edge::clear_target() {
  target_ = 0u;
  clear_has_target();
}
 ::google::protobuf::uint32 DependencyGraph_Edge::target() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.target)
  return target_;
}
 void DependencyGraph_Edge::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.target)
}

// optional string dep = 3;
bool DependencyGraph_Edge::has_dep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DependencyGraph_Edge::set_has_dep() {
  _has_bits_[0] |= 0x00000004u;
}
void DependencyGraph_Edge::clear_has_dep() {
  _has_bits_[0] &= ~0x00000004u;
}
void DependencyGraph_Edge::clear_dep() {
  dep_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dep();
}
 const ::std::string& DependencyGraph_Edge::dep() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
  return dep_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DependencyGraph_Edge::set_dep(const ::std::string& value) {
  set_has_dep();
  dep_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}
 void DependencyGraph_Edge::set_dep(const char* value) {
  set_has_dep();
  dep_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}
 void DependencyGraph_Edge::set_dep(const char* value, size_t size) {
  set_has_dep();
  dep_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}
 ::std::string* DependencyGraph_Edge::mutable_dep() {
  set_has_dep();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
  return dep_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DependencyGraph_Edge::release_dep() {
  clear_has_dep();
  return dep_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DependencyGraph_Edge::set_allocated_dep(::std::string* dep) {
  if (dep != NULL) {
    set_has_dep();
  } else {
    clear_has_dep();
  }
  dep_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dep);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}

// optional bool isExtra = 4;
bool DependencyGraph_Edge::has_isextra() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DependencyGraph_Edge::set_has_isextra() {
  _has_bits_[0] |= 0x00000008u;
}
void DependencyGraph_Edge::clear_has_isextra() {
  _has_bits_[0] &= ~0x00000008u;
}
void DependencyGraph_Edge::clear_isextra() {
  isextra_ = false;
  clear_has_isextra();
}
 bool DependencyGraph_Edge::isextra() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.isExtra)
  return isextra_;
}
 void DependencyGraph_Edge::set_isextra(bool value) {
  set_has_isextra();
  isextra_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.isExtra)
}

// optional uint32 sourceCopy = 5;
bool DependencyGraph_Edge::has_sourcecopy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DependencyGraph_Edge::set_has_sourcecopy() {
  _has_bits_[0] |= 0x00000010u;
}
void DependencyGraph_Edge::clear_has_sourcecopy() {
  _has_bits_[0] &= ~0x00000010u;
}
void DependencyGraph_Edge::clear_sourcecopy() {
  sourcecopy_ = 0u;
  clear_has_sourcecopy();
}
 ::google::protobuf::uint32 DependencyGraph_Edge::sourcecopy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.sourceCopy)
  return sourcecopy_;
}
 void DependencyGraph_Edge::set_sourcecopy(::google::protobuf::uint32 value) {
  set_has_sourcecopy();
  sourcecopy_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.sourceCopy)
}

// optional uint32 targetCopy = 6;
bool DependencyGraph_Edge::has_targetcopy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DependencyGraph_Edge::set_has_targetcopy() {
  _has_bits_[0] |= 0x00000020u;
}
void DependencyGraph_Edge::clear_has_targetcopy() {
  _has_bits_[0] &= ~0x00000020u;
}
void DependencyGraph_Edge::clear_targetcopy() {
  targetcopy_ = 0u;
  clear_has_targetcopy();
}
 ::google::protobuf::uint32 DependencyGraph_Edge::targetcopy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.targetCopy)
  return targetcopy_;
}
 void DependencyGraph_Edge::set_targetcopy(::google::protobuf::uint32 value) {
  set_has_targetcopy();
  targetcopy_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.targetCopy)
}

// optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
bool DependencyGraph_Edge::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DependencyGraph_Edge::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
void DependencyGraph_Edge::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
void DependencyGraph_Edge::clear_language() {
  language_ = 0;
  clear_has_language();
}
 ::edu::stanford::nlp::pipeline::Language DependencyGraph_Edge::language() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.language)
  return static_cast< ::edu::stanford::nlp::pipeline::Language >(language_);
}
 void DependencyGraph_Edge::set_language(::edu::stanford::nlp::pipeline::Language value) {
  assert(::edu::stanford::nlp::pipeline::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.language)
}

// -------------------------------------------------------------------

// DependencyGraph

// repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
int DependencyGraph::node_size() const {
  return node_.size();
}
void DependencyGraph::clear_node() {
  node_.Clear();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph_Node& DependencyGraph::node(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_.Get(index);
}
::edu::stanford::nlp::pipeline::DependencyGraph_Node* DependencyGraph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_.Mutable(index);
}
::edu::stanford::nlp::pipeline::DependencyGraph_Node* DependencyGraph::add_node() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node >*
DependencyGraph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return &node_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node >&
DependencyGraph::node() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_;
}

// repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
int DependencyGraph::edge_size() const {
  return edge_.size();
}
void DependencyGraph::clear_edge() {
  edge_.Clear();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph_Edge& DependencyGraph::edge(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_.Get(index);
}
::edu::stanford::nlp::pipeline::DependencyGraph_Edge* DependencyGraph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_.Mutable(index);
}
::edu::stanford::nlp::pipeline::DependencyGraph_Edge* DependencyGraph::add_edge() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge >*
DependencyGraph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return &edge_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge >&
DependencyGraph::edge() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_;
}

// repeated uint32 root = 3 [packed = true];
int DependencyGraph::root_size() const {
  return root_.size();
}
void DependencyGraph::clear_root() {
  root_.Clear();
}
 ::google::protobuf::uint32 DependencyGraph::root(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.root)
  return root_.Get(index);
}
 void DependencyGraph::set_root(int index, ::google::protobuf::uint32 value) {
  root_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.root)
}
 void DependencyGraph::add_root(::google::protobuf::uint32 value) {
  root_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.DependencyGraph.root)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DependencyGraph::root() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.DependencyGraph.root)
  return root_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DependencyGraph::mutable_root() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.DependencyGraph.root)
  return &root_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CorefChain_CorefMention::kMentionIDFieldNumber;
const int CorefChain_CorefMention::kMentionTypeFieldNumber;
const int CorefChain_CorefMention::kNumberFieldNumber;
const int CorefChain_CorefMention::kGenderFieldNumber;
const int CorefChain_CorefMention::kAnimacyFieldNumber;
const int CorefChain_CorefMention::kBeginIndexFieldNumber;
const int CorefChain_CorefMention::kEndIndexFieldNumber;
const int CorefChain_CorefMention::kHeadIndexFieldNumber;
const int CorefChain_CorefMention::kSentenceIndexFieldNumber;
const int CorefChain_CorefMention::kPositionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CorefChain_CorefMention::CorefChain_CorefMention()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
}

void CorefChain_CorefMention::InitAsDefaultInstance() {
}

CorefChain_CorefMention::CorefChain_CorefMention(const CorefChain_CorefMention& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
}

void CorefChain_CorefMention::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mentionid_ = 0;
  mentiontype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gender_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  animacy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  beginindex_ = 0u;
  endindex_ = 0u;
  headindex_ = 0u;
  sentenceindex_ = 0u;
  position_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CorefChain_CorefMention::~CorefChain_CorefMention() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  SharedDtor();
}

void CorefChain_CorefMention::SharedDtor() {
  mentiontype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gender_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  animacy_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void CorefChain_CorefMention::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CorefChain_CorefMention::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CorefChain_CorefMention_descriptor_;
}

const CorefChain_CorefMention& CorefChain_CorefMention::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

CorefChain_CorefMention* CorefChain_CorefMention::default_instance_ = NULL;

CorefChain_CorefMention* CorefChain_CorefMention::New(::google::protobuf::Arena* arena) const {
  CorefChain_CorefMention* n = new CorefChain_CorefMention;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CorefChain_CorefMention::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CorefChain_CorefMention*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(mentionid_, beginindex_);
    ZR_(endindex_, headindex_);
    if (has_mentiontype()) {
      mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_number()) {
      number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_gender()) {
      gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_animacy()) {
      animacy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ZR_(sentenceindex_, position_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CorefChain_CorefMention::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mentionID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mentionid_)));
          set_has_mentionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_mentionType;
        break;
      }

      // optional string mentionType = 2;
      case 2: {
        if (tag == 18) {
         parse_mentionType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mentiontype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mentiontype().data(), this->mentiontype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_number;
        break;
      }

      // optional string number = 3;
      case 3: {
        if (tag == 26) {
         parse_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_number()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->number().data(), this->number().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.CorefChain.CorefMention.number");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_gender;
        break;
      }

      // optional string gender = 4;
      case 4: {
        if (tag == 34) {
         parse_gender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gender()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->gender().data(), this->gender().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_animacy;
        break;
      }

      // optional string animacy = 5;
      case 5: {
        if (tag == 42) {
         parse_animacy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_animacy()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->animacy().data(), this->animacy().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_beginIndex;
        break;
      }

      // optional uint32 beginIndex = 6;
      case 6: {
        if (tag == 48) {
         parse_beginIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &beginindex_)));
          set_has_beginindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_endIndex;
        break;
      }

      // optional uint32 endIndex = 7;
      case 7: {
        if (tag == 56) {
         parse_endIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endindex_)));
          set_has_endindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_headIndex;
        break;
      }

      // optional uint32 headIndex = 9;
      case 9: {
        if (tag == 72) {
         parse_headIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &headindex_)));
          set_has_headindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_sentenceIndex;
        break;
      }

      // optional uint32 sentenceIndex = 10;
      case 10: {
        if (tag == 80) {
         parse_sentenceIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentenceindex_)));
          set_has_sentenceindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_position;
        break;
      }

      // optional uint32 position = 11;
      case 11: {
        if (tag == 88) {
         parse_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  return false;
#undef DO_
}

void CorefChain_CorefMention::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  // optional int32 mentionID = 1;
  if (has_mentionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mentionid(), output);
  }

  // optional string mentionType = 2;
  if (has_mentiontype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mentiontype().data(), this->mentiontype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mentiontype(), output);
  }

  // optional string number = 3;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.number");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->number(), output);
  }

  // optional string gender = 4;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gender().data(), this->gender().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->gender(), output);
  }

  // optional string animacy = 5;
  if (has_animacy()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->animacy().data(), this->animacy().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->animacy(), output);
  }

  // optional uint32 beginIndex = 6;
  if (has_beginindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->beginindex(), output);
  }

  // optional uint32 endIndex = 7;
  if (has_endindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->endindex(), output);
  }

  // optional uint32 headIndex = 9;
  if (has_headindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->headindex(), output);
  }

  // optional uint32 sentenceIndex = 10;
  if (has_sentenceindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->sentenceindex(), output);
  }

  // optional uint32 position = 11;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->position(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
}

::google::protobuf::uint8* CorefChain_CorefMention::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  // optional int32 mentionID = 1;
  if (has_mentionid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mentionid(), target);
  }

  // optional string mentionType = 2;
  if (has_mentiontype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mentiontype().data(), this->mentiontype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->mentiontype(), target);
  }

  // optional string number = 3;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.number");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->number(), target);
  }

  // optional string gender = 4;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gender().data(), this->gender().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->gender(), target);
  }

  // optional string animacy = 5;
  if (has_animacy()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->animacy().data(), this->animacy().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->animacy(), target);
  }

  // optional uint32 beginIndex = 6;
  if (has_beginindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->beginindex(), target);
  }

  // optional uint32 endIndex = 7;
  if (has_endindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->endindex(), target);
  }

  // optional uint32 headIndex = 9;
  if (has_headindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->headindex(), target);
  }

  // optional uint32 sentenceIndex = 10;
  if (has_sentenceindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->sentenceindex(), target);
  }

  // optional uint32 position = 11;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->position(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
  return target;
}

int CorefChain_CorefMention::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int32 mentionID = 1;
    if (has_mentionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mentionid());
    }

    // optional string mentionType = 2;
    if (has_mentiontype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mentiontype());
    }

    // optional string number = 3;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->number());
    }

    // optional string gender = 4;
    if (has_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gender());
    }

    // optional string animacy = 5;
    if (has_animacy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->animacy());
    }

    // optional uint32 beginIndex = 6;
    if (has_beginindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->beginindex());
    }

    // optional uint32 endIndex = 7;
    if (has_endindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endindex());
    }

    // optional uint32 headIndex = 9;
    if (has_headindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->headindex());
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional uint32 sentenceIndex = 10;
    if (has_sentenceindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentenceindex());
    }

    // optional uint32 position = 11;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->position());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CorefChain_CorefMention::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CorefChain_CorefMention* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CorefChain_CorefMention>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CorefChain_CorefMention::MergeFrom(const CorefChain_CorefMention& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mentionid()) {
      set_mentionid(from.mentionid());
    }
    if (from.has_mentiontype()) {
      set_has_mentiontype();
      mentiontype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mentiontype_);
    }
    if (from.has_number()) {
      set_has_number();
      number_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.number_);
    }
    if (from.has_gender()) {
      set_has_gender();
      gender_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gender_);
    }
    if (from.has_animacy()) {
      set_has_animacy();
      animacy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.animacy_);
    }
    if (from.has_beginindex()) {
      set_beginindex(from.beginindex());
    }
    if (from.has_endindex()) {
      set_endindex(from.endindex());
    }
    if (from.has_headindex()) {
      set_headindex(from.headindex());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sentenceindex()) {
      set_sentenceindex(from.sentenceindex());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CorefChain_CorefMention::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CorefChain_CorefMention::CopyFrom(const CorefChain_CorefMention& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CorefChain_CorefMention::IsInitialized() const {

  return true;
}

void CorefChain_CorefMention::Swap(CorefChain_CorefMention* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CorefChain_CorefMention::InternalSwap(CorefChain_CorefMention* other) {
  std::swap(mentionid_, other->mentionid_);
  mentiontype_.Swap(&other->mentiontype_);
  number_.Swap(&other->number_);
  gender_.Swap(&other->gender_);
  animacy_.Swap(&other->animacy_);
  std::swap(beginindex_, other->beginindex_);
  std::swap(endindex_, other->endindex_);
  std::swap(headindex_, other->headindex_);
  std::swap(sentenceindex_, other->sentenceindex_);
  std::swap(position_, other->position_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CorefChain_CorefMention::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CorefChain_CorefMention_descriptor_;
  metadata.reflection = CorefChain_CorefMention_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CorefChain::kChainIDFieldNumber;
const int CorefChain::kMentionFieldNumber;
const int CorefChain::kRepresentativeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CorefChain::CorefChain()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.CorefChain)
}

void CorefChain::InitAsDefaultInstance() {
}

CorefChain::CorefChain(const CorefChain& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.CorefChain)
}

void CorefChain::SharedCtor() {
  _cached_size_ = 0;
  chainid_ = 0;
  representative_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CorefChain::~CorefChain() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.CorefChain)
  SharedDtor();
}

void CorefChain::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CorefChain::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CorefChain::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CorefChain_descriptor_;
}

const CorefChain& CorefChain::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

CorefChain* CorefChain::default_instance_ = NULL;

CorefChain* CorefChain::New(::google::protobuf::Arena* arena) const {
  CorefChain* n = new CorefChain;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CorefChain::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CorefChain*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(chainid_, representative_);

#undef ZR_HELPER_
#undef ZR_

  mention_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CorefChain::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.CorefChain)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 chainID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chainid_)));
          set_has_chainid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_mention;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
      case 2: {
        if (tag == 18) {
         parse_mention:
          DO_(input->IncrementRecursionDepth());
         parse_loop_mention:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mention()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_mention;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_representative;
        break;
      }

      // required uint32 representative = 3;
      case 3: {
        if (tag == 24) {
         parse_representative:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &representative_)));
          set_has_representative();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.CorefChain)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.CorefChain)
  return false;
#undef DO_
}

void CorefChain::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.CorefChain)
  // required int32 chainID = 1;
  if (has_chainid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->chainid(), output);
  }

  // repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
  for (unsigned int i = 0, n = this->mention_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->mention(i), output);
  }

  // required uint32 representative = 3;
  if (has_representative()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->representative(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.CorefChain)
}

::google::protobuf::uint8* CorefChain::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.CorefChain)
  // required int32 chainID = 1;
  if (has_chainid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->chainid(), target);
  }

  // repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
  for (unsigned int i = 0, n = this->mention_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->mention(i), target);
  }

  // required uint32 representative = 3;
  if (has_representative()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->representative(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.CorefChain)
  return target;
}

int CorefChain::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_chainid()) {
    // required int32 chainID = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->chainid());
  }

  if (has_representative()) {
    // required uint32 representative = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->representative());
  }

  return total_size;
}
int CorefChain::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required int32 chainID = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->chainid());

    // required uint32 representative = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->representative());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
  total_size += 1 * this->mention_size();
  for (int i = 0; i < this->mention_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mention(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CorefChain::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CorefChain* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CorefChain>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CorefChain::MergeFrom(const CorefChain& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  mention_.MergeFrom(from.mention_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_chainid()) {
      set_chainid(from.chainid());
    }
    if (from.has_representative()) {
      set_representative(from.representative());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CorefChain::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CorefChain::CopyFrom(const CorefChain& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CorefChain::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  return true;
}

void CorefChain::Swap(CorefChain* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CorefChain::InternalSwap(CorefChain* other) {
  std::swap(chainid_, other->chainid_);
  mention_.UnsafeArenaSwap(&other->mention_);
  std::swap(representative_, other->representative_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CorefChain::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CorefChain_descriptor_;
  metadata.reflection = CorefChain_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CorefChain_CorefMention

// optional int32 mentionID = 1;
bool CorefChain_CorefMention::has_mentionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CorefChain_CorefMention::set_has_mentionid() {
  _has_bits_[0] |= 0x00000001u;
}
void CorefChain_CorefMention::clear_has_mentionid() {
  _has_bits_[0] &= ~0x00000001u;
}
void CorefChain_CorefMention::clear_mentionid() {
  mentionid_ = 0;
  clear_has_mentionid();
}
 ::google::protobuf::int32 CorefChain_CorefMention::mentionid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionID)
  return mentionid_;
}
 void CorefChain_CorefMention::set_mentionid(::google::protobuf::int32 value) {
  set_has_mentionid();
  mentionid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionID)
}

// optional string mentionType = 2;
bool CorefChain_CorefMention::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CorefChain_CorefMention::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000002u;
}
void CorefChain_CorefMention::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
void CorefChain_CorefMention::clear_mentiontype() {
  mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mentiontype();
}
 const ::std::string& CorefChain_CorefMention::mentiontype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
  return mentiontype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}
 void CorefChain_CorefMention::set_mentiontype(const char* value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}
 void CorefChain_CorefMention::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}
 ::std::string* CorefChain_CorefMention::mutable_mentiontype() {
  set_has_mentiontype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
  return mentiontype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CorefChain_CorefMention::release_mentiontype() {
  clear_has_mentiontype();
  return mentiontype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype != NULL) {
    set_has_mentiontype();
  } else {
    clear_has_mentiontype();
  }
  mentiontype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mentiontype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}

// optional string number = 3;
bool CorefChain_CorefMention::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CorefChain_CorefMention::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
void CorefChain_CorefMention::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
void CorefChain_CorefMention::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_number();
}
 const ::std::string& CorefChain_CorefMention::number() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
  return number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_number(const ::std::string& value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}
 void CorefChain_CorefMention::set_number(const char* value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}
 void CorefChain_CorefMention::set_number(const char* value, size_t size) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}
 ::std::string* CorefChain_CorefMention::mutable_number() {
  set_has_number();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CorefChain_CorefMention::release_number() {
  clear_has_number();
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    set_has_number();
  } else {
    clear_has_number();
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}

// optional string gender = 4;
bool CorefChain_CorefMention::has_gender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CorefChain_CorefMention::set_has_gender() {
  _has_bits_[0] |= 0x00000008u;
}
void CorefChain_CorefMention::clear_has_gender() {
  _has_bits_[0] &= ~0x00000008u;
}
void CorefChain_CorefMention::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
 const ::std::string& CorefChain_CorefMention::gender() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
  return gender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}
 void CorefChain_CorefMention::set_gender(const char* value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}
 void CorefChain_CorefMention::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}
 ::std::string* CorefChain_CorefMention::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CorefChain_CorefMention::release_gender() {
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}

// optional string animacy = 5;
bool CorefChain_CorefMention::has_animacy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CorefChain_CorefMention::set_has_animacy() {
  _has_bits_[0] |= 0x00000010u;
}
void CorefChain_CorefMention::clear_has_animacy() {
  _has_bits_[0] &= ~0x00000010u;
}
void CorefChain_CorefMention::clear_animacy() {
  animacy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_animacy();
}
 const ::std::string& CorefChain_CorefMention::animacy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
  return animacy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_animacy(const ::std::string& value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}
 void CorefChain_CorefMention::set_animacy(const char* value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}
 void CorefChain_CorefMention::set_animacy(const char* value, size_t size) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}
 ::std::string* CorefChain_CorefMention::mutable_animacy() {
  set_has_animacy();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
  return animacy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CorefChain_CorefMention::release_animacy() {
  clear_has_animacy();
  return animacy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CorefChain_CorefMention::set_allocated_animacy(::std::string* animacy) {
  if (animacy != NULL) {
    set_has_animacy();
  } else {
    clear_has_animacy();
  }
  animacy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), animacy);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}

// optional uint32 beginIndex = 6;
bool CorefChain_CorefMention::has_beginindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CorefChain_CorefMention::set_has_beginindex() {
  _has_bits_[0] |= 0x00000020u;
}
void CorefChain_CorefMention::clear_has_beginindex() {
  _has_bits_[0] &= ~0x00000020u;
}
void CorefChain_CorefMention::clear_beginindex() {
  beginindex_ = 0u;
  clear_has_beginindex();
}
 ::google::protobuf::uint32 CorefChain_CorefMention::beginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.beginIndex)
  return beginindex_;
}
 void CorefChain_CorefMention::set_beginindex(::google::protobuf::uint32 value) {
  set_has_beginindex();
  beginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.beginIndex)
}

// optional uint32 endIndex = 7;
bool CorefChain_CorefMention::has_endindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void CorefChain_CorefMention::set_has_endindex() {
  _has_bits_[0] |= 0x00000040u;
}
void CorefChain_CorefMention::clear_has_endindex() {
  _has_bits_[0] &= ~0x00000040u;
}
void CorefChain_CorefMention::clear_endindex() {
  endindex_ = 0u;
  clear_has_endindex();
}
 ::google::protobuf::uint32 CorefChain_CorefMention::endindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.endIndex)
  return endindex_;
}
 void CorefChain_CorefMention::set_endindex(::google::protobuf::uint32 value) {
  set_has_endindex();
  endindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.endIndex)
}

// optional uint32 headIndex = 9;
bool CorefChain_CorefMention::has_headindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void CorefChain_CorefMention::set_has_headindex() {
  _has_bits_[0] |= 0x00000080u;
}
void CorefChain_CorefMention::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000080u;
}
void CorefChain_CorefMention::clear_headindex() {
  headindex_ = 0u;
  clear_has_headindex();
}
 ::google::protobuf::uint32 CorefChain_CorefMention::headindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.headIndex)
  return headindex_;
}
 void CorefChain_CorefMention::set_headindex(::google::protobuf::uint32 value) {
  set_has_headindex();
  headindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.headIndex)
}

// optional uint32 sentenceIndex = 10;
bool CorefChain_CorefMention::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void CorefChain_CorefMention::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000100u;
}
void CorefChain_CorefMention::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000100u;
}
void CorefChain_CorefMention::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
 ::google::protobuf::uint32 CorefChain_CorefMention::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.sentenceIndex)
  return sentenceindex_;
}
 void CorefChain_CorefMention::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.sentenceIndex)
}

// optional uint32 position = 11;
bool CorefChain_CorefMention::has_position() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void CorefChain_CorefMention::set_has_position() {
  _has_bits_[0] |= 0x00000200u;
}
void CorefChain_CorefMention::clear_has_position() {
  _has_bits_[0] &= ~0x00000200u;
}
void CorefChain_CorefMention::clear_position() {
  position_ = 0u;
  clear_has_position();
}
 ::google::protobuf::uint32 CorefChain_CorefMention::position() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.position)
  return position_;
}
 void CorefChain_CorefMention::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.position)
}

// -------------------------------------------------------------------

// CorefChain

// required int32 chainID = 1;
bool CorefChain::has_chainid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CorefChain::set_has_chainid() {
  _has_bits_[0] |= 0x00000001u;
}
void CorefChain::clear_has_chainid() {
  _has_bits_[0] &= ~0x00000001u;
}
void CorefChain::clear_chainid() {
  chainid_ = 0;
  clear_has_chainid();
}
 ::google::protobuf::int32 CorefChain::chainid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.chainID)
  return chainid_;
}
 void CorefChain::set_chainid(::google::protobuf::int32 value) {
  set_has_chainid();
  chainid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.chainID)
}

// repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
int CorefChain::mention_size() const {
  return mention_.size();
}
void CorefChain::clear_mention() {
  mention_.Clear();
}
const ::edu::stanford::nlp::pipeline::CorefChain_CorefMention& CorefChain::mention(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_.Get(index);
}
::edu::stanford::nlp::pipeline::CorefChain_CorefMention* CorefChain::mutable_mention(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_.Mutable(index);
}
::edu::stanford::nlp::pipeline::CorefChain_CorefMention* CorefChain::add_mention() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention >*
CorefChain::mutable_mention() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.CorefChain.mention)
  return &mention_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention >&
CorefChain::mention() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_;
}

// required uint32 representative = 3;
bool CorefChain::has_representative() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CorefChain::set_has_representative() {
  _has_bits_[0] |= 0x00000004u;
}
void CorefChain::clear_has_representative() {
  _has_bits_[0] &= ~0x00000004u;
}
void CorefChain::clear_representative() {
  representative_ = 0u;
  clear_has_representative();
}
 ::google::protobuf::uint32 CorefChain::representative() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.representative)
  return representative_;
}
 void CorefChain::set_representative(::google::protobuf::uint32 value) {
  set_has_representative();
  representative_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.representative)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Mention::kMentionIDFieldNumber;
const int Mention::kMentionTypeFieldNumber;
const int Mention::kNumberFieldNumber;
const int Mention::kGenderFieldNumber;
const int Mention::kAnimacyFieldNumber;
const int Mention::kPersonFieldNumber;
const int Mention::kStartIndexFieldNumber;
const int Mention::kEndIndexFieldNumber;
const int Mention::kHeadIndexFieldNumber;
const int Mention::kHeadStringFieldNumber;
const int Mention::kNerStringFieldNumber;
const int Mention::kOriginalRefFieldNumber;
const int Mention::kGoldCorefClusterIDFieldNumber;
const int Mention::kCorefClusterIDFieldNumber;
const int Mention::kMentionNumFieldNumber;
const int Mention::kSentNumFieldNumber;
const int Mention::kUtterFieldNumber;
const int Mention::kParagraphFieldNumber;
const int Mention::kIsSubjectFieldNumber;
const int Mention::kIsDirectObjectFieldNumber;
const int Mention::kIsIndirectObjectFieldNumber;
const int Mention::kIsPrepositionObjectFieldNumber;
const int Mention::kHasTwinFieldNumber;
const int Mention::kGenericFieldNumber;
const int Mention::kIsSingletonFieldNumber;
const int Mention::kHasBasicDependencyFieldNumber;
const int Mention::kHasCollapsedDependencyFieldNumber;
const int Mention::kHasContextParseTreeFieldNumber;
const int Mention::kHeadIndexedWordFieldNumber;
const int Mention::kDependingVerbFieldNumber;
const int Mention::kHeadWordFieldNumber;
const int Mention::kSpeakerInfoFieldNumber;
const int Mention::kSentenceWordsFieldNumber;
const int Mention::kOriginalSpanFieldNumber;
const int Mention::kDependentsFieldNumber;
const int Mention::kPreprocessedTermsFieldNumber;
const int Mention::kAppositionsFieldNumber;
const int Mention::kPredicateNominativesFieldNumber;
const int Mention::kRelativePronounsFieldNumber;
const int Mention::kListMembersFieldNumber;
const int Mention::kBelongToListsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Mention::Mention()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Mention)
}

void Mention::InitAsDefaultInstance() {
  headindexedword_ = const_cast< ::edu::stanford::nlp::pipeline::IndexedWord*>(&::edu::stanford::nlp::pipeline::IndexedWord::default_instance());
  dependingverb_ = const_cast< ::edu::stanford::nlp::pipeline::IndexedWord*>(&::edu::stanford::nlp::pipeline::IndexedWord::default_instance());
  headword_ = const_cast< ::edu::stanford::nlp::pipeline::IndexedWord*>(&::edu::stanford::nlp::pipeline::IndexedWord::default_instance());
  speakerinfo_ = const_cast< ::edu::stanford::nlp::pipeline::SpeakerInfo*>(&::edu::stanford::nlp::pipeline::SpeakerInfo::default_instance());
}

Mention::Mention(const Mention& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Mention)
}

void Mention::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mentionid_ = 0;
  mentiontype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gender_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  animacy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  person_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  startindex_ = 0u;
  endindex_ = 0u;
  headindex_ = 0u;
  headstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nerstring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  originalref_ = 0u;
  goldcorefclusterid_ = 0;
  corefclusterid_ = 0;
  mentionnum_ = 0u;
  sentnum_ = 0u;
  utter_ = 0u;
  paragraph_ = 0u;
  issubject_ = false;
  isdirectobject_ = false;
  isindirectobject_ = false;
  isprepositionobject_ = false;
  hastwin_ = false;
  generic_ = false;
  issingleton_ = false;
  hasbasicdependency_ = false;
  hascollapseddependency_ = false;
  hascontextparsetree_ = false;
  headindexedword_ = NULL;
  dependingverb_ = NULL;
  headword_ = NULL;
  speakerinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Mention::~Mention() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Mention)
  SharedDtor();
}

void Mention::SharedDtor() {
  mentiontype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gender_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  animacy_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  person_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  headstring_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nerstring_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete headindexedword_;
    delete dependingverb_;
    delete headword_;
    delete speakerinfo_;
  }
}

void Mention::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Mention::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Mention_descriptor_;
}

const Mention& Mention::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Mention* Mention::default_instance_ = NULL;

Mention* Mention::New(::google::protobuf::Arena* arena) const {
  Mention* n = new Mention;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Mention::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Mention*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(mentionid_, startindex_);
    if (has_mentiontype()) {
      mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_number()) {
      number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_gender()) {
      gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_animacy()) {
      animacy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_person()) {
      person_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    endindex_ = 0u;
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(originalref_, sentnum_);
    headindex_ = 0u;
    if (has_headstring()) {
      headstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_nerstring()) {
      nerstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    ZR_(utter_, generic_);
  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    ZR_(issingleton_, hascontextparsetree_);
    if (has_headindexedword()) {
      if (headindexedword_ != NULL) headindexedword_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
    }
    if (has_dependingverb()) {
      if (dependingverb_ != NULL) dependingverb_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
    }
    if (has_headword()) {
      if (headword_ != NULL) headword_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
    }
    if (has_speakerinfo()) {
      if (speakerinfo_ != NULL) speakerinfo_->::edu::stanford::nlp::pipeline::SpeakerInfo::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  sentencewords_.Clear();
  originalspan_.Clear();
  dependents_.Clear();
  preprocessedterms_.Clear();
  appositions_.Clear();
  predicatenominatives_.Clear();
  relativepronouns_.Clear();
  listmembers_.Clear();
  belongtolists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Mention::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Mention)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mentionID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mentionid_)));
          set_has_mentionid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_mentionType;
        break;
      }

      // optional string mentionType = 2;
      case 2: {
        if (tag == 18) {
         parse_mentionType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mentiontype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mentiontype().data(), this->mentiontype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.mentionType");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_number;
        break;
      }

      // optional string number = 3;
      case 3: {
        if (tag == 26) {
         parse_number:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_number()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->number().data(), this->number().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.number");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_gender;
        break;
      }

      // optional string gender = 4;
      case 4: {
        if (tag == 34) {
         parse_gender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gender()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->gender().data(), this->gender().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.gender");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_animacy;
        break;
      }

      // optional string animacy = 5;
      case 5: {
        if (tag == 42) {
         parse_animacy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_animacy()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->animacy().data(), this->animacy().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.animacy");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_person;
        break;
      }

      // optional string person = 6;
      case 6: {
        if (tag == 50) {
         parse_person:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_person()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->person().data(), this->person().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.person");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_startIndex;
        break;
      }

      // optional uint32 startIndex = 7;
      case 7: {
        if (tag == 56) {
         parse_startIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startindex_)));
          set_has_startindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_endIndex;
        break;
      }

      // optional uint32 endIndex = 9;
      case 9: {
        if (tag == 72) {
         parse_endIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endindex_)));
          set_has_endindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_headIndex;
        break;
      }

      // optional uint32 headIndex = 10;
      case 10: {
        if (tag == 80) {
         parse_headIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &headindex_)));
          set_has_headindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_headString;
        break;
      }

      // optional string headString = 11;
      case 11: {
        if (tag == 90) {
         parse_headString:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_headstring()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->headstring().data(), this->headstring().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.headString");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_nerString;
        break;
      }

      // optional string nerString = 12;
      case 12: {
        if (tag == 98) {
         parse_nerString:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nerstring()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->nerstring().data(), this->nerstring().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.nerString");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_originalRef;
        break;
      }

      // optional uint32 originalRef = 13;
      case 13: {
        if (tag == 104) {
         parse_originalRef:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &originalref_)));
          set_has_originalref();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_goldCorefClusterID;
        break;
      }

      // optional int32 goldCorefClusterID = 14;
      case 14: {
        if (tag == 112) {
         parse_goldCorefClusterID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &goldcorefclusterid_)));
          set_has_goldcorefclusterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_corefClusterID;
        break;
      }

      // optional int32 corefClusterID = 15;
      case 15: {
        if (tag == 120) {
         parse_corefClusterID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &corefclusterid_)));
          set_has_corefclusterid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_mentionNum;
        break;
      }

      // optional uint32 mentionNum = 16;
      case 16: {
        if (tag == 128) {
         parse_mentionNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mentionnum_)));
          set_has_mentionnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_sentNum;
        break;
      }

      // optional uint32 sentNum = 17;
      case 17: {
        if (tag == 136) {
         parse_sentNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentnum_)));
          set_has_sentnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_utter;
        break;
      }

      // optional uint32 utter = 18;
      case 18: {
        if (tag == 144) {
         parse_utter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &utter_)));
          set_has_utter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_paragraph;
        break;
      }

      // optional uint32 paragraph = 19;
      case 19: {
        if (tag == 152) {
         parse_paragraph:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &paragraph_)));
          set_has_paragraph();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_isSubject;
        break;
      }

      // optional bool isSubject = 20;
      case 20: {
        if (tag == 160) {
         parse_isSubject:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issubject_)));
          set_has_issubject();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_isDirectObject;
        break;
      }

      // optional bool isDirectObject = 21;
      case 21: {
        if (tag == 168) {
         parse_isDirectObject:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isdirectobject_)));
          set_has_isdirectobject();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_isIndirectObject;
        break;
      }

      // optional bool isIndirectObject = 22;
      case 22: {
        if (tag == 176) {
         parse_isIndirectObject:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isindirectobject_)));
          set_has_isindirectobject();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_isPrepositionObject;
        break;
      }

      // optional bool isPrepositionObject = 23;
      case 23: {
        if (tag == 184) {
         parse_isPrepositionObject:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isprepositionobject_)));
          set_has_isprepositionobject();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_hasTwin;
        break;
      }

      // optional bool hasTwin = 24;
      case 24: {
        if (tag == 192) {
         parse_hasTwin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hastwin_)));
          set_has_hastwin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_generic;
        break;
      }

      // optional bool generic = 25;
      case 25: {
        if (tag == 200) {
         parse_generic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &generic_)));
          set_has_generic();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_isSingleton;
        break;
      }

      // optional bool isSingleton = 26;
      case 26: {
        if (tag == 208) {
         parse_isSingleton:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issingleton_)));
          set_has_issingleton();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_hasBasicDependency;
        break;
      }

      // optional bool hasBasicDependency = 27;
      case 27: {
        if (tag == 216) {
         parse_hasBasicDependency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hasbasicdependency_)));
          set_has_hasbasicdependency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_hasCollapsedDependency;
        break;
      }

      // optional bool hasCollapsedDependency = 28;
      case 28: {
        if (tag == 224) {
         parse_hasCollapsedDependency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hascollapseddependency_)));
          set_has_hascollapseddependency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_hasContextParseTree;
        break;
      }

      // optional bool hasContextParseTree = 29;
      case 29: {
        if (tag == 232) {
         parse_hasContextParseTree:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hascontextparsetree_)));
          set_has_hascontextparsetree();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_headIndexedWord;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
      case 30: {
        if (tag == 242) {
         parse_headIndexedWord:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_headindexedword()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(250)) goto parse_dependingVerb;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
      case 31: {
        if (tag == 250) {
         parse_dependingVerb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dependingverb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_headWord;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
      case 32: {
        if (tag == 258) {
         parse_headWord:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_headword()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(266)) goto parse_speakerInfo;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
      case 33: {
        if (tag == 266) {
         parse_speakerInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_speakerinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(402)) goto parse_sentenceWords;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
      case 50: {
        if (tag == 402) {
         parse_sentenceWords:
          DO_(input->IncrementRecursionDepth());
         parse_loop_sentenceWords:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_sentencewords()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(402)) goto parse_loop_sentenceWords;
        if (input->ExpectTag(410)) goto parse_loop_originalSpan;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
      case 51: {
        if (tag == 410) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_originalSpan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_originalspan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(410)) goto parse_loop_originalSpan;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(418)) goto parse_dependents;
        break;
      }

      // repeated string dependents = 52;
      case 52: {
        if (tag == 418) {
         parse_dependents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_dependents()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->dependents(this->dependents_size() - 1).data(),
            this->dependents(this->dependents_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.dependents");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(418)) goto parse_dependents;
        if (input->ExpectTag(426)) goto parse_preprocessedTerms;
        break;
      }

      // repeated string preprocessedTerms = 53;
      case 53: {
        if (tag == 426) {
         parse_preprocessedTerms:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_preprocessedterms()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->preprocessedterms(this->preprocessedterms_size() - 1).data(),
            this->preprocessedterms(this->preprocessedterms_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Mention.preprocessedTerms");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(426)) goto parse_preprocessedTerms;
        if (input->ExpectTag(432)) goto parse_appositions;
        break;
      }

      // repeated int32 appositions = 54;
      case 54: {
        if (tag == 432) {
         parse_appositions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 2, 432, input, this->mutable_appositions())));
        } else if (tag == 434) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_appositions())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(432)) goto parse_appositions;
        if (input->ExpectTag(440)) goto parse_predicateNominatives;
        break;
      }

      // repeated int32 predicateNominatives = 55;
      case 55: {
        if (tag == 440) {
         parse_predicateNominatives:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 2, 440, input, this->mutable_predicatenominatives())));
        } else if (tag == 442) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_predicatenominatives())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(440)) goto parse_predicateNominatives;
        if (input->ExpectTag(448)) goto parse_relativePronouns;
        break;
      }

      // repeated int32 relativePronouns = 56;
      case 56: {
        if (tag == 448) {
         parse_relativePronouns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 2, 448, input, this->mutable_relativepronouns())));
        } else if (tag == 450) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_relativepronouns())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(448)) goto parse_relativePronouns;
        if (input->ExpectTag(456)) goto parse_listMembers;
        break;
      }

      // repeated int32 listMembers = 57;
      case 57: {
        if (tag == 456) {
         parse_listMembers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 2, 456, input, this->mutable_listmembers())));
        } else if (tag == 458) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_listmembers())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(456)) goto parse_listMembers;
        if (input->ExpectTag(464)) goto parse_belongToLists;
        break;
      }

      // repeated int32 belongToLists = 58;
      case 58: {
        if (tag == 464) {
         parse_belongToLists:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 2, 464, input, this->mutable_belongtolists())));
        } else if (tag == 466) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_belongtolists())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(464)) goto parse_belongToLists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Mention)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Mention)
  return false;
#undef DO_
}

void Mention::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Mention)
  // optional int32 mentionID = 1;
  if (has_mentionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mentionid(), output);
  }

  // optional string mentionType = 2;
  if (has_mentiontype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mentiontype().data(), this->mentiontype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.mentionType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mentiontype(), output);
  }

  // optional string number = 3;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.number");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->number(), output);
  }

  // optional string gender = 4;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gender().data(), this->gender().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.gender");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->gender(), output);
  }

  // optional string animacy = 5;
  if (has_animacy()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->animacy().data(), this->animacy().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.animacy");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->animacy(), output);
  }

  // optional string person = 6;
  if (has_person()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->person().data(), this->person().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.person");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->person(), output);
  }

  // optional uint32 startIndex = 7;
  if (has_startindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->startindex(), output);
  }

  // optional uint32 endIndex = 9;
  if (has_endindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->endindex(), output);
  }

  // optional uint32 headIndex = 10;
  if (has_headindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->headindex(), output);
  }

  // optional string headString = 11;
  if (has_headstring()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->headstring().data(), this->headstring().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.headString");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->headstring(), output);
  }

  // optional string nerString = 12;
  if (has_nerstring()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nerstring().data(), this->nerstring().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.nerString");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->nerstring(), output);
  }

  // optional uint32 originalRef = 13;
  if (has_originalref()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->originalref(), output);
  }

  // optional int32 goldCorefClusterID = 14;
  if (has_goldcorefclusterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->goldcorefclusterid(), output);
  }

  // optional int32 corefClusterID = 15;
  if (has_corefclusterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->corefclusterid(), output);
  }

  // optional uint32 mentionNum = 16;
  if (has_mentionnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->mentionnum(), output);
  }

  // optional uint32 sentNum = 17;
  if (has_sentnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->sentnum(), output);
  }

  // optional uint32 utter = 18;
  if (has_utter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(18, this->utter(), output);
  }

  // optional uint32 paragraph = 19;
  if (has_paragraph()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(19, this->paragraph(), output);
  }

  // optional bool isSubject = 20;
  if (has_issubject()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(20, this->issubject(), output);
  }

  // optional bool isDirectObject = 21;
  if (has_isdirectobject()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->isdirectobject(), output);
  }

  // optional bool isIndirectObject = 22;
  if (has_isindirectobject()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(22, this->isindirectobject(), output);
  }

  // optional bool isPrepositionObject = 23;
  if (has_isprepositionobject()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->isprepositionobject(), output);
  }

  // optional bool hasTwin = 24;
  if (has_hastwin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(24, this->hastwin(), output);
  }

  // optional bool generic = 25;
  if (has_generic()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(25, this->generic(), output);
  }

  // optional bool isSingleton = 26;
  if (has_issingleton()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(26, this->issingleton(), output);
  }

  // optional bool hasBasicDependency = 27;
  if (has_hasbasicdependency()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(27, this->hasbasicdependency(), output);
  }

  // optional bool hasCollapsedDependency = 28;
  if (has_hascollapseddependency()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(28, this->hascollapseddependency(), output);
  }

  // optional bool hasContextParseTree = 29;
  if (has_hascontextparsetree()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(29, this->hascontextparsetree(), output);
  }

  // optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
  if (has_headindexedword()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, *this->headindexedword_, output);
  }

  // optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
  if (has_dependingverb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      31, *this->dependingverb_, output);
  }

  // optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
  if (has_headword()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, *this->headword_, output);
  }

  // optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
  if (has_speakerinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      33, *this->speakerinfo_, output);
  }

  // repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
  for (unsigned int i = 0, n = this->sentencewords_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      50, this->sentencewords(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
  for (unsigned int i = 0, n = this->originalspan_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      51, this->originalspan(i), output);
  }

  // repeated string dependents = 52;
  for (int i = 0; i < this->dependents_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dependents(i).data(), this->dependents(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.dependents");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      52, this->dependents(i), output);
  }

  // repeated string preprocessedTerms = 53;
  for (int i = 0; i < this->preprocessedterms_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->preprocessedterms(i).data(), this->preprocessedterms(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.preprocessedTerms");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      53, this->preprocessedterms(i), output);
  }

  // repeated int32 appositions = 54;
  for (int i = 0; i < this->appositions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      54, this->appositions(i), output);
  }

  // repeated int32 predicateNominatives = 55;
  for (int i = 0; i < this->predicatenominatives_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      55, this->predicatenominatives(i), output);
  }

  // repeated int32 relativePronouns = 56;
  for (int i = 0; i < this->relativepronouns_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      56, this->relativepronouns(i), output);
  }

  // repeated int32 listMembers = 57;
  for (int i = 0; i < this->listmembers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      57, this->listmembers(i), output);
  }

  // repeated int32 belongToLists = 58;
  for (int i = 0; i < this->belongtolists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      58, this->belongtolists(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Mention)
}

::google::protobuf::uint8* Mention::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Mention)
  // optional int32 mentionID = 1;
  if (has_mentionid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mentionid(), target);
  }

  // optional string mentionType = 2;
  if (has_mentiontype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mentiontype().data(), this->mentiontype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.mentionType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->mentiontype(), target);
  }

  // optional string number = 3;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.number");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->number(), target);
  }

  // optional string gender = 4;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gender().data(), this->gender().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.gender");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->gender(), target);
  }

  // optional string animacy = 5;
  if (has_animacy()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->animacy().data(), this->animacy().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.animacy");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->animacy(), target);
  }

  // optional string person = 6;
  if (has_person()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->person().data(), this->person().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.person");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->person(), target);
  }

  // optional uint32 startIndex = 7;
  if (has_startindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->startindex(), target);
  }

  // optional uint32 endIndex = 9;
  if (has_endindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->endindex(), target);
  }

  // optional uint32 headIndex = 10;
  if (has_headindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->headindex(), target);
  }

  // optional string headString = 11;
  if (has_headstring()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->headstring().data(), this->headstring().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.headString");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->headstring(), target);
  }

  // optional string nerString = 12;
  if (has_nerstring()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->nerstring().data(), this->nerstring().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.nerString");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->nerstring(), target);
  }

  // optional uint32 originalRef = 13;
  if (has_originalref()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->originalref(), target);
  }

  // optional int32 goldCorefClusterID = 14;
  if (has_goldcorefclusterid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->goldcorefclusterid(), target);
  }

  // optional int32 corefClusterID = 15;
  if (has_corefclusterid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->corefclusterid(), target);
  }

  // optional uint32 mentionNum = 16;
  if (has_mentionnum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->mentionnum(), target);
  }

  // optional uint32 sentNum = 17;
  if (has_sentnum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(17, this->sentnum(), target);
  }

  // optional uint32 utter = 18;
  if (has_utter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(18, this->utter(), target);
  }

  // optional uint32 paragraph = 19;
  if (has_paragraph()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(19, this->paragraph(), target);
  }

  // optional bool isSubject = 20;
  if (has_issubject()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(20, this->issubject(), target);
  }

  // optional bool isDirectObject = 21;
  if (has_isdirectobject()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(21, this->isdirectobject(), target);
  }

  // optional bool isIndirectObject = 22;
  if (has_isindirectobject()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(22, this->isindirectobject(), target);
  }

  // optional bool isPrepositionObject = 23;
  if (has_isprepositionobject()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(23, this->isprepositionobject(), target);
  }

  // optional bool hasTwin = 24;
  if (has_hastwin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(24, this->hastwin(), target);
  }

  // optional bool generic = 25;
  if (has_generic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(25, this->generic(), target);
  }

  // optional bool isSingleton = 26;
  if (has_issingleton()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(26, this->issingleton(), target);
  }

  // optional bool hasBasicDependency = 27;
  if (has_hasbasicdependency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(27, this->hasbasicdependency(), target);
  }

  // optional bool hasCollapsedDependency = 28;
  if (has_hascollapseddependency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(28, this->hascollapseddependency(), target);
  }

  // optional bool hasContextParseTree = 29;
  if (has_hascontextparsetree()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(29, this->hascontextparsetree(), target);
  }

  // optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
  if (has_headindexedword()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        30, *this->headindexedword_, target);
  }

  // optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
  if (has_dependingverb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        31, *this->dependingverb_, target);
  }

  // optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
  if (has_headword()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        32, *this->headword_, target);
  }

  // optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
  if (has_speakerinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        33, *this->speakerinfo_, target);
  }

  // repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
  for (unsigned int i = 0, n = this->sentencewords_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        50, this->sentencewords(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
  for (unsigned int i = 0, n = this->originalspan_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        51, this->originalspan(i), target);
  }

  // repeated string dependents = 52;
  for (int i = 0; i < this->dependents_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dependents(i).data(), this->dependents(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.dependents");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(52, this->dependents(i), target);
  }

  // repeated string preprocessedTerms = 53;
  for (int i = 0; i < this->preprocessedterms_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->preprocessedterms(i).data(), this->preprocessedterms(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Mention.preprocessedTerms");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(53, this->preprocessedterms(i), target);
  }

  // repeated int32 appositions = 54;
  for (int i = 0; i < this->appositions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(54, this->appositions(i), target);
  }

  // repeated int32 predicateNominatives = 55;
  for (int i = 0; i < this->predicatenominatives_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(55, this->predicatenominatives(i), target);
  }

  // repeated int32 relativePronouns = 56;
  for (int i = 0; i < this->relativepronouns_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(56, this->relativepronouns(i), target);
  }

  // repeated int32 listMembers = 57;
  for (int i = 0; i < this->listmembers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(57, this->listmembers(i), target);
  }

  // repeated int32 belongToLists = 58;
  for (int i = 0; i < this->belongtolists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(58, this->belongtolists(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Mention)
  return target;
}

int Mention::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int32 mentionID = 1;
    if (has_mentionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mentionid());
    }

    // optional string mentionType = 2;
    if (has_mentiontype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mentiontype());
    }

    // optional string number = 3;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->number());
    }

    // optional string gender = 4;
    if (has_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gender());
    }

    // optional string animacy = 5;
    if (has_animacy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->animacy());
    }

    // optional string person = 6;
    if (has_person()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->person());
    }

    // optional uint32 startIndex = 7;
    if (has_startindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startindex());
    }

    // optional uint32 endIndex = 9;
    if (has_endindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endindex());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional uint32 headIndex = 10;
    if (has_headindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->headindex());
    }

    // optional string headString = 11;
    if (has_headstring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->headstring());
    }

    // optional string nerString = 12;
    if (has_nerstring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nerstring());
    }

    // optional uint32 originalRef = 13;
    if (has_originalref()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->originalref());
    }

    // optional int32 goldCorefClusterID = 14;
    if (has_goldcorefclusterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->goldcorefclusterid());
    }

    // optional int32 corefClusterID = 15;
    if (has_corefclusterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->corefclusterid());
    }

    // optional uint32 mentionNum = 16;
    if (has_mentionnum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mentionnum());
    }

    // optional uint32 sentNum = 17;
    if (has_sentnum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentnum());
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional uint32 utter = 18;
    if (has_utter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->utter());
    }

    // optional uint32 paragraph = 19;
    if (has_paragraph()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->paragraph());
    }

    // optional bool isSubject = 20;
    if (has_issubject()) {
      total_size += 2 + 1;
    }

    // optional bool isDirectObject = 21;
    if (has_isdirectobject()) {
      total_size += 2 + 1;
    }

    // optional bool isIndirectObject = 22;
    if (has_isindirectobject()) {
      total_size += 2 + 1;
    }

    // optional bool isPrepositionObject = 23;
    if (has_isprepositionobject()) {
      total_size += 2 + 1;
    }

    // optional bool hasTwin = 24;
    if (has_hastwin()) {
      total_size += 2 + 1;
    }

    // optional bool generic = 25;
    if (has_generic()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    // optional bool isSingleton = 26;
    if (has_issingleton()) {
      total_size += 2 + 1;
    }

    // optional bool hasBasicDependency = 27;
    if (has_hasbasicdependency()) {
      total_size += 2 + 1;
    }

    // optional bool hasCollapsedDependency = 28;
    if (has_hascollapseddependency()) {
      total_size += 2 + 1;
    }

    // optional bool hasContextParseTree = 29;
    if (has_hascontextparsetree()) {
      total_size += 2 + 1;
    }

    // optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
    if (has_headindexedword()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->headindexedword_);
    }

    // optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
    if (has_dependingverb()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->dependingverb_);
    }

    // optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
    if (has_headword()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->headword_);
    }

    // optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
    if (has_speakerinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->speakerinfo_);
    }

  }
  // repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
  total_size += 2 * this->sentencewords_size();
  for (int i = 0; i < this->sentencewords_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sentencewords(i));
  }

  // repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
  total_size += 2 * this->originalspan_size();
  for (int i = 0; i < this->originalspan_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->originalspan(i));
  }

  // repeated string dependents = 52;
  total_size += 2 * this->dependents_size();
  for (int i = 0; i < this->dependents_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->dependents(i));
  }

  // repeated string preprocessedTerms = 53;
  total_size += 2 * this->preprocessedterms_size();
  for (int i = 0; i < this->preprocessedterms_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->preprocessedterms(i));
  }

  // repeated int32 appositions = 54;
  {
    int data_size = 0;
    for (int i = 0; i < this->appositions_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->appositions(i));
    }
    total_size += 2 * this->appositions_size() + data_size;
  }

  // repeated int32 predicateNominatives = 55;
  {
    int data_size = 0;
    for (int i = 0; i < this->predicatenominatives_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->predicatenominatives(i));
    }
    total_size += 2 * this->predicatenominatives_size() + data_size;
  }

  // repeated int32 relativePronouns = 56;
  {
    int data_size = 0;
    for (int i = 0; i < this->relativepronouns_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->relativepronouns(i));
    }
    total_size += 2 * this->relativepronouns_size() + data_size;
  }

  // repeated int32 listMembers = 57;
  {
    int data_size = 0;
    for (int i = 0; i < this->listmembers_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->listmembers(i));
    }
    total_size += 2 * this->listmembers_size() + data_size;
  }

  // repeated int32 belongToLists = 58;
  {
    int data_size = 0;
    for (int i = 0; i < this->belongtolists_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->belongtolists(i));
    }
    total_size += 2 * this->belongtolists_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Mention::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Mention* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Mention>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Mention::MergeFrom(const Mention& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  sentencewords_.MergeFrom(from.sentencewords_);
  originalspan_.MergeFrom(from.originalspan_);
  dependents_.MergeFrom(from.dependents_);
  preprocessedterms_.MergeFrom(from.preprocessedterms_);
  appositions_.MergeFrom(from.appositions_);
  predicatenominatives_.MergeFrom(from.predicatenominatives_);
  relativepronouns_.MergeFrom(from.relativepronouns_);
  listmembers_.MergeFrom(from.listmembers_);
  belongtolists_.MergeFrom(from.belongtolists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mentionid()) {
      set_mentionid(from.mentionid());
    }
    if (from.has_mentiontype()) {
      set_has_mentiontype();
      mentiontype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mentiontype_);
    }
    if (from.has_number()) {
      set_has_number();
      number_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.number_);
    }
    if (from.has_gender()) {
      set_has_gender();
      gender_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gender_);
    }
    if (from.has_animacy()) {
      set_has_animacy();
      animacy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.animacy_);
    }
    if (from.has_person()) {
      set_has_person();
      person_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.person_);
    }
    if (from.has_startindex()) {
      set_startindex(from.startindex());
    }
    if (from.has_endindex()) {
      set_endindex(from.endindex());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_headindex()) {
      set_headindex(from.headindex());
    }
    if (from.has_headstring()) {
      set_has_headstring();
      headstring_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.headstring_);
    }
    if (from.has_nerstring()) {
      set_has_nerstring();
      nerstring_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nerstring_);
    }
    if (from.has_originalref()) {
      set_originalref(from.originalref());
    }
    if (from.has_goldcorefclusterid()) {
      set_goldcorefclusterid(from.goldcorefclusterid());
    }
    if (from.has_corefclusterid()) {
      set_corefclusterid(from.corefclusterid());
    }
    if (from.has_mentionnum()) {
      set_mentionnum(from.mentionnum());
    }
    if (from.has_sentnum()) {
      set_sentnum(from.sentnum());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_utter()) {
      set_utter(from.utter());
    }
    if (from.has_paragraph()) {
      set_paragraph(from.paragraph());
    }
    if (from.has_issubject()) {
      set_issubject(from.issubject());
    }
    if (from.has_isdirectobject()) {
      set_isdirectobject(from.isdirectobject());
    }
    if (from.has_isindirectobject()) {
      set_isindirectobject(from.isindirectobject());
    }
    if (from.has_isprepositionobject()) {
      set_isprepositionobject(from.isprepositionobject());
    }
    if (from.has_hastwin()) {
      set_hastwin(from.hastwin());
    }
    if (from.has_generic()) {
      set_generic(from.generic());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_issingleton()) {
      set_issingleton(from.issingleton());
    }
    if (from.has_hasbasicdependency()) {
      set_hasbasicdependency(from.hasbasicdependency());
    }
    if (from.has_hascollapseddependency()) {
      set_hascollapseddependency(from.hascollapseddependency());
    }
    if (from.has_hascontextparsetree()) {
      set_hascontextparsetree(from.hascontextparsetree());
    }
    if (from.has_headindexedword()) {
      mutable_headindexedword()->::edu::stanford::nlp::pipeline::IndexedWord::MergeFrom(from.headindexedword());
    }
    if (from.has_dependingverb()) {
      mutable_dependingverb()->::edu::stanford::nlp::pipeline::IndexedWord::MergeFrom(from.dependingverb());
    }
    if (from.has_headword()) {
      mutable_headword()->::edu::stanford::nlp::pipeline::IndexedWord::MergeFrom(from.headword());
    }
    if (from.has_speakerinfo()) {
      mutable_speakerinfo()->::edu::stanford::nlp::pipeline::SpeakerInfo::MergeFrom(from.speakerinfo());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Mention::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Mention::CopyFrom(const Mention& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mention::IsInitialized() const {

  return true;
}

void Mention::Swap(Mention* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Mention::InternalSwap(Mention* other) {
  std::swap(mentionid_, other->mentionid_);
  mentiontype_.Swap(&other->mentiontype_);
  number_.Swap(&other->number_);
  gender_.Swap(&other->gender_);
  animacy_.Swap(&other->animacy_);
  person_.Swap(&other->person_);
  std::swap(startindex_, other->startindex_);
  std::swap(endindex_, other->endindex_);
  std::swap(headindex_, other->headindex_);
  headstring_.Swap(&other->headstring_);
  nerstring_.Swap(&other->nerstring_);
  std::swap(originalref_, other->originalref_);
  std::swap(goldcorefclusterid_, other->goldcorefclusterid_);
  std::swap(corefclusterid_, other->corefclusterid_);
  std::swap(mentionnum_, other->mentionnum_);
  std::swap(sentnum_, other->sentnum_);
  std::swap(utter_, other->utter_);
  std::swap(paragraph_, other->paragraph_);
  std::swap(issubject_, other->issubject_);
  std::swap(isdirectobject_, other->isdirectobject_);
  std::swap(isindirectobject_, other->isindirectobject_);
  std::swap(isprepositionobject_, other->isprepositionobject_);
  std::swap(hastwin_, other->hastwin_);
  std::swap(generic_, other->generic_);
  std::swap(issingleton_, other->issingleton_);
  std::swap(hasbasicdependency_, other->hasbasicdependency_);
  std::swap(hascollapseddependency_, other->hascollapseddependency_);
  std::swap(hascontextparsetree_, other->hascontextparsetree_);
  std::swap(headindexedword_, other->headindexedword_);
  std::swap(dependingverb_, other->dependingverb_);
  std::swap(headword_, other->headword_);
  std::swap(speakerinfo_, other->speakerinfo_);
  sentencewords_.UnsafeArenaSwap(&other->sentencewords_);
  originalspan_.UnsafeArenaSwap(&other->originalspan_);
  dependents_.UnsafeArenaSwap(&other->dependents_);
  preprocessedterms_.UnsafeArenaSwap(&other->preprocessedterms_);
  appositions_.UnsafeArenaSwap(&other->appositions_);
  predicatenominatives_.UnsafeArenaSwap(&other->predicatenominatives_);
  relativepronouns_.UnsafeArenaSwap(&other->relativepronouns_);
  listmembers_.UnsafeArenaSwap(&other->listmembers_);
  belongtolists_.UnsafeArenaSwap(&other->belongtolists_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  std::swap(_has_bits_[1], other->_has_bits_[1]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Mention::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Mention_descriptor_;
  metadata.reflection = Mention_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Mention

// optional int32 mentionID = 1;
bool Mention::has_mentionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Mention::set_has_mentionid() {
  _has_bits_[0] |= 0x00000001u;
}
void Mention::clear_has_mentionid() {
  _has_bits_[0] &= ~0x00000001u;
}
void Mention::clear_mentionid() {
  mentionid_ = 0;
  clear_has_mentionid();
}
 ::google::protobuf::int32 Mention::mentionid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.mentionID)
  return mentionid_;
}
 void Mention::set_mentionid(::google::protobuf::int32 value) {
  set_has_mentionid();
  mentionid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.mentionID)
}

// optional string mentionType = 2;
bool Mention::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Mention::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000002u;
}
void Mention::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
void Mention::clear_mentiontype() {
  mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mentiontype();
}
 const ::std::string& Mention::mentiontype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.mentionType)
  return mentiontype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.mentionType)
}
 void Mention::set_mentiontype(const char* value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.mentionType)
}
 void Mention::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.mentionType)
}
 ::std::string* Mention::mutable_mentiontype() {
  set_has_mentiontype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.mentionType)
  return mentiontype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_mentiontype() {
  clear_has_mentiontype();
  return mentiontype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype != NULL) {
    set_has_mentiontype();
  } else {
    clear_has_mentiontype();
  }
  mentiontype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mentiontype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.mentionType)
}

// optional string number = 3;
bool Mention::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Mention::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
void Mention::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
void Mention::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_number();
}
 const ::std::string& Mention::number() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.number)
  return number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_number(const ::std::string& value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.number)
}
 void Mention::set_number(const char* value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.number)
}
 void Mention::set_number(const char* value, size_t size) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.number)
}
 ::std::string* Mention::mutable_number() {
  set_has_number();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_number() {
  clear_has_number();
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    set_has_number();
  } else {
    clear_has_number();
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.number)
}

// optional string gender = 4;
bool Mention::has_gender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Mention::set_has_gender() {
  _has_bits_[0] |= 0x00000008u;
}
void Mention::clear_has_gender() {
  _has_bits_[0] &= ~0x00000008u;
}
void Mention::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
 const ::std::string& Mention::gender() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.gender)
  return gender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.gender)
}
 void Mention::set_gender(const char* value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.gender)
}
 void Mention::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.gender)
}
 ::std::string* Mention::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_gender() {
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.gender)
}

// optional string animacy = 5;
bool Mention::has_animacy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Mention::set_has_animacy() {
  _has_bits_[0] |= 0x00000010u;
}
void Mention::clear_has_animacy() {
  _has_bits_[0] &= ~0x00000010u;
}
void Mention::clear_animacy() {
  animacy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_animacy();
}
 const ::std::string& Mention::animacy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.animacy)
  return animacy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_animacy(const ::std::string& value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.animacy)
}
 void Mention::set_animacy(const char* value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.animacy)
}
 void Mention::set_animacy(const char* value, size_t size) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.animacy)
}
 ::std::string* Mention::mutable_animacy() {
  set_has_animacy();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.animacy)
  return animacy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_animacy() {
  clear_has_animacy();
  return animacy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_animacy(::std::string* animacy) {
  if (animacy != NULL) {
    set_has_animacy();
  } else {
    clear_has_animacy();
  }
  animacy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), animacy);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.animacy)
}

// optional string person = 6;
bool Mention::has_person() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Mention::set_has_person() {
  _has_bits_[0] |= 0x00000020u;
}
void Mention::clear_has_person() {
  _has_bits_[0] &= ~0x00000020u;
}
void Mention::clear_person() {
  person_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_person();
}
 const ::std::string& Mention::person() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.person)
  return person_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_person(const ::std::string& value) {
  set_has_person();
  person_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.person)
}
 void Mention::set_person(const char* value) {
  set_has_person();
  person_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.person)
}
 void Mention::set_person(const char* value, size_t size) {
  set_has_person();
  person_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.person)
}
 ::std::string* Mention::mutable_person() {
  set_has_person();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.person)
  return person_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_person() {
  clear_has_person();
  return person_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_person(::std::string* person) {
  if (person != NULL) {
    set_has_person();
  } else {
    clear_has_person();
  }
  person_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), person);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.person)
}

// optional uint32 startIndex = 7;
bool Mention::has_startindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Mention::set_has_startindex() {
  _has_bits_[0] |= 0x00000040u;
}
void Mention::clear_has_startindex() {
  _has_bits_[0] &= ~0x00000040u;
}
void Mention::clear_startindex() {
  startindex_ = 0u;
  clear_has_startindex();
}
 ::google::protobuf::uint32 Mention::startindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.startIndex)
  return startindex_;
}
 void Mention::set_startindex(::google::protobuf::uint32 value) {
  set_has_startindex();
  startindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.startIndex)
}

// optional uint32 endIndex = 9;
bool Mention::has_endindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Mention::set_has_endindex() {
  _has_bits_[0] |= 0x00000080u;
}
void Mention::clear_has_endindex() {
  _has_bits_[0] &= ~0x00000080u;
}
void Mention::clear_endindex() {
  endindex_ = 0u;
  clear_has_endindex();
}
 ::google::protobuf::uint32 Mention::endindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.endIndex)
  return endindex_;
}
 void Mention::set_endindex(::google::protobuf::uint32 value) {
  set_has_endindex();
  endindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.endIndex)
}

// optional uint32 headIndex = 10;
bool Mention::has_headindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Mention::set_has_headindex() {
  _has_bits_[0] |= 0x00000100u;
}
void Mention::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000100u;
}
void Mention::clear_headindex() {
  headindex_ = 0u;
  clear_has_headindex();
}
 ::google::protobuf::uint32 Mention::headindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headIndex)
  return headindex_;
}
 void Mention::set_headindex(::google::protobuf::uint32 value) {
  set_has_headindex();
  headindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.headIndex)
}

// optional string headString = 11;
bool Mention::has_headstring() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Mention::set_has_headstring() {
  _has_bits_[0] |= 0x00000200u;
}
void Mention::clear_has_headstring() {
  _has_bits_[0] &= ~0x00000200u;
}
void Mention::clear_headstring() {
  headstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headstring();
}
 const ::std::string& Mention::headstring() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headString)
  return headstring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_headstring(const ::std::string& value) {
  set_has_headstring();
  headstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.headString)
}
 void Mention::set_headstring(const char* value) {
  set_has_headstring();
  headstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.headString)
}
 void Mention::set_headstring(const char* value, size_t size) {
  set_has_headstring();
  headstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.headString)
}
 ::std::string* Mention::mutable_headstring() {
  set_has_headstring();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.headString)
  return headstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_headstring() {
  clear_has_headstring();
  return headstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_headstring(::std::string* headstring) {
  if (headstring != NULL) {
    set_has_headstring();
  } else {
    clear_has_headstring();
  }
  headstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headstring);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.headString)
}

// optional string nerString = 12;
bool Mention::has_nerstring() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Mention::set_has_nerstring() {
  _has_bits_[0] |= 0x00000400u;
}
void Mention::clear_has_nerstring() {
  _has_bits_[0] &= ~0x00000400u;
}
void Mention::clear_nerstring() {
  nerstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nerstring();
}
 const ::std::string& Mention::nerstring() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.nerString)
  return nerstring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_nerstring(const ::std::string& value) {
  set_has_nerstring();
  nerstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.nerString)
}
 void Mention::set_nerstring(const char* value) {
  set_has_nerstring();
  nerstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.nerString)
}
 void Mention::set_nerstring(const char* value, size_t size) {
  set_has_nerstring();
  nerstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.nerString)
}
 ::std::string* Mention::mutable_nerstring() {
  set_has_nerstring();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.nerString)
  return nerstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Mention::release_nerstring() {
  clear_has_nerstring();
  return nerstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Mention::set_allocated_nerstring(::std::string* nerstring) {
  if (nerstring != NULL) {
    set_has_nerstring();
  } else {
    clear_has_nerstring();
  }
  nerstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nerstring);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.nerString)
}

// optional uint32 originalRef = 13;
bool Mention::has_originalref() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Mention::set_has_originalref() {
  _has_bits_[0] |= 0x00000800u;
}
void Mention::clear_has_originalref() {
  _has_bits_[0] &= ~0x00000800u;
}
void Mention::clear_originalref() {
  originalref_ = 0u;
  clear_has_originalref();
}
 ::google::protobuf::uint32 Mention::originalref() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.originalRef)
  return originalref_;
}
 void Mention::set_originalref(::google::protobuf::uint32 value) {
  set_has_originalref();
  originalref_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.originalRef)
}

// optional int32 goldCorefClusterID = 14;
bool Mention::has_goldcorefclusterid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Mention::set_has_goldcorefclusterid() {
  _has_bits_[0] |= 0x00001000u;
}
void Mention::clear_has_goldcorefclusterid() {
  _has_bits_[0] &= ~0x00001000u;
}
void Mention::clear_goldcorefclusterid() {
  goldcorefclusterid_ = 0;
  clear_has_goldcorefclusterid();
}
 ::google::protobuf::int32 Mention::goldcorefclusterid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.goldCorefClusterID)
  return goldcorefclusterid_;
}
 void Mention::set_goldcorefclusterid(::google::protobuf::int32 value) {
  set_has_goldcorefclusterid();
  goldcorefclusterid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.goldCorefClusterID)
}

// optional int32 corefClusterID = 15;
bool Mention::has_corefclusterid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Mention::set_has_corefclusterid() {
  _has_bits_[0] |= 0x00002000u;
}
void Mention::clear_has_corefclusterid() {
  _has_bits_[0] &= ~0x00002000u;
}
void Mention::clear_corefclusterid() {
  corefclusterid_ = 0;
  clear_has_corefclusterid();
}
 ::google::protobuf::int32 Mention::corefclusterid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.corefClusterID)
  return corefclusterid_;
}
 void Mention::set_corefclusterid(::google::protobuf::int32 value) {
  set_has_corefclusterid();
  corefclusterid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.corefClusterID)
}

// optional uint32 mentionNum = 16;
bool Mention::has_mentionnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Mention::set_has_mentionnum() {
  _has_bits_[0] |= 0x00004000u;
}
void Mention::clear_has_mentionnum() {
  _has_bits_[0] &= ~0x00004000u;
}
void Mention::clear_mentionnum() {
  mentionnum_ = 0u;
  clear_has_mentionnum();
}
 ::google::protobuf::uint32 Mention::mentionnum() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.mentionNum)
  return mentionnum_;
}
 void Mention::set_mentionnum(::google::protobuf::uint32 value) {
  set_has_mentionnum();
  mentionnum_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.mentionNum)
}

// optional uint32 sentNum = 17;
bool Mention::has_sentnum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void Mention::set_has_sentnum() {
  _has_bits_[0] |= 0x00008000u;
}
void Mention::clear_has_sentnum() {
  _has_bits_[0] &= ~0x00008000u;
}
void Mention::clear_sentnum() {
  sentnum_ = 0u;
  clear_has_sentnum();
}
 ::google::protobuf::uint32 Mention::sentnum() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.sentNum)
  return sentnum_;
}
 void Mention::set_sentnum(::google::protobuf::uint32 value) {
  set_has_sentnum();
  sentnum_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.sentNum)
}

// optional uint32 utter = 18;
bool Mention::has_utter() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void Mention::set_has_utter() {
  _has_bits_[0] |= 0x00010000u;
}
void Mention::clear_has_utter() {
  _has_bits_[0] &= ~0x00010000u;
}
void Mention::clear_utter() {
  utter_ = 0u;
  clear_has_utter();
}
 ::google::protobuf::uint32 Mention::utter() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.utter)
  return utter_;
}
 void Mention::set_utter(::google::protobuf::uint32 value) {
  set_has_utter();
  utter_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.utter)
}

// optional uint32 paragraph = 19;
bool Mention::has_paragraph() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void Mention::set_has_paragraph() {
  _has_bits_[0] |= 0x00020000u;
}
void Mention::clear_has_paragraph() {
  _has_bits_[0] &= ~0x00020000u;
}
void Mention::clear_paragraph() {
  paragraph_ = 0u;
  clear_has_paragraph();
}
 ::google::protobuf::uint32 Mention::paragraph() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.paragraph)
  return paragraph_;
}
 void Mention::set_paragraph(::google::protobuf::uint32 value) {
  set_has_paragraph();
  paragraph_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.paragraph)
}

// optional bool isSubject = 20;
bool Mention::has_issubject() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void Mention::set_has_issubject() {
  _has_bits_[0] |= 0x00040000u;
}
void Mention::clear_has_issubject() {
  _has_bits_[0] &= ~0x00040000u;
}
void Mention::clear_issubject() {
  issubject_ = false;
  clear_has_issubject();
}
 bool Mention::issubject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isSubject)
  return issubject_;
}
 void Mention::set_issubject(bool value) {
  set_has_issubject();
  issubject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isSubject)
}

// optional bool isDirectObject = 21;
bool Mention::has_isdirectobject() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void Mention::set_has_isdirectobject() {
  _has_bits_[0] |= 0x00080000u;
}
void Mention::clear_has_isdirectobject() {
  _has_bits_[0] &= ~0x00080000u;
}
void Mention::clear_isdirectobject() {
  isdirectobject_ = false;
  clear_has_isdirectobject();
}
 bool Mention::isdirectobject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isDirectObject)
  return isdirectobject_;
}
 void Mention::set_isdirectobject(bool value) {
  set_has_isdirectobject();
  isdirectobject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isDirectObject)
}

// optional bool isIndirectObject = 22;
bool Mention::has_isindirectobject() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void Mention::set_has_isindirectobject() {
  _has_bits_[0] |= 0x00100000u;
}
void Mention::clear_has_isindirectobject() {
  _has_bits_[0] &= ~0x00100000u;
}
void Mention::clear_isindirectobject() {
  isindirectobject_ = false;
  clear_has_isindirectobject();
}
 bool Mention::isindirectobject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isIndirectObject)
  return isindirectobject_;
}
 void Mention::set_isindirectobject(bool value) {
  set_has_isindirectobject();
  isindirectobject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isIndirectObject)
}

// optional bool isPrepositionObject = 23;
bool Mention::has_isprepositionobject() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void Mention::set_has_isprepositionobject() {
  _has_bits_[0] |= 0x00200000u;
}
void Mention::clear_has_isprepositionobject() {
  _has_bits_[0] &= ~0x00200000u;
}
void Mention::clear_isprepositionobject() {
  isprepositionobject_ = false;
  clear_has_isprepositionobject();
}
 bool Mention::isprepositionobject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isPrepositionObject)
  return isprepositionobject_;
}
 void Mention::set_isprepositionobject(bool value) {
  set_has_isprepositionobject();
  isprepositionobject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isPrepositionObject)
}

// optional bool hasTwin = 24;
bool Mention::has_hastwin() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void Mention::set_has_hastwin() {
  _has_bits_[0] |= 0x00400000u;
}
void Mention::clear_has_hastwin() {
  _has_bits_[0] &= ~0x00400000u;
}
void Mention::clear_hastwin() {
  hastwin_ = false;
  clear_has_hastwin();
}
 bool Mention::hastwin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasTwin)
  return hastwin_;
}
 void Mention::set_hastwin(bool value) {
  set_has_hastwin();
  hastwin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasTwin)
}

// optional bool generic = 25;
bool Mention::has_generic() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void Mention::set_has_generic() {
  _has_bits_[0] |= 0x00800000u;
}
void Mention::clear_has_generic() {
  _has_bits_[0] &= ~0x00800000u;
}
void Mention::clear_generic() {
  generic_ = false;
  clear_has_generic();
}
 bool Mention::generic() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.generic)
  return generic_;
}
 void Mention::set_generic(bool value) {
  set_has_generic();
  generic_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.generic)
}

// optional bool isSingleton = 26;
bool Mention::has_issingleton() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void Mention::set_has_issingleton() {
  _has_bits_[0] |= 0x01000000u;
}
void Mention::clear_has_issingleton() {
  _has_bits_[0] &= ~0x01000000u;
}
void Mention::clear_issingleton() {
  issingleton_ = false;
  clear_has_issingleton();
}
 bool Mention::issingleton() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isSingleton)
  return issingleton_;
}
 void Mention::set_issingleton(bool value) {
  set_has_issingleton();
  issingleton_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isSingleton)
}

// optional bool hasBasicDependency = 27;
bool Mention::has_hasbasicdependency() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void Mention::set_has_hasbasicdependency() {
  _has_bits_[0] |= 0x02000000u;
}
void Mention::clear_has_hasbasicdependency() {
  _has_bits_[0] &= ~0x02000000u;
}
void Mention::clear_hasbasicdependency() {
  hasbasicdependency_ = false;
  clear_has_hasbasicdependency();
}
 bool Mention::hasbasicdependency() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasBasicDependency)
  return hasbasicdependency_;
}
 void Mention::set_hasbasicdependency(bool value) {
  set_has_hasbasicdependency();
  hasbasicdependency_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasBasicDependency)
}

// optional bool hasCollapsedDependency = 28;
bool Mention::has_hascollapseddependency() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void Mention::set_has_hascollapseddependency() {
  _has_bits_[0] |= 0x04000000u;
}
void Mention::clear_has_hascollapseddependency() {
  _has_bits_[0] &= ~0x04000000u;
}
void Mention::clear_hascollapseddependency() {
  hascollapseddependency_ = false;
  clear_has_hascollapseddependency();
}
 bool Mention::hascollapseddependency() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasCollapsedDependency)
  return hascollapseddependency_;
}
 void Mention::set_hascollapseddependency(bool value) {
  set_has_hascollapseddependency();
  hascollapseddependency_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasCollapsedDependency)
}

// optional bool hasContextParseTree = 29;
bool Mention::has_hascontextparsetree() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void Mention::set_has_hascontextparsetree() {
  _has_bits_[0] |= 0x08000000u;
}
void Mention::clear_has_hascontextparsetree() {
  _has_bits_[0] &= ~0x08000000u;
}
void Mention::clear_hascontextparsetree() {
  hascontextparsetree_ = false;
  clear_has_hascontextparsetree();
}
 bool Mention::hascontextparsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasContextParseTree)
  return hascontextparsetree_;
}
 void Mention::set_hascontextparsetree(bool value) {
  set_has_hascontextparsetree();
  hascontextparsetree_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasContextParseTree)
}

// optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
bool Mention::has_headindexedword() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
void Mention::set_has_headindexedword() {
  _has_bits_[0] |= 0x10000000u;
}
void Mention::clear_has_headindexedword() {
  _has_bits_[0] &= ~0x10000000u;
}
void Mention::clear_headindexedword() {
  if (headindexedword_ != NULL) headindexedword_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
  clear_has_headindexedword();
}
const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::headindexedword() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headIndexedWord)
  return headindexedword_ != NULL ? *headindexedword_ : *default_instance_->headindexedword_;
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_headindexedword() {
  set_has_headindexedword();
  if (headindexedword_ == NULL) {
    headindexedword_ = new ::edu::stanford::nlp::pipeline::IndexedWord;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.headIndexedWord)
  return headindexedword_;
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::release_headindexedword() {
  clear_has_headindexedword();
  ::edu::stanford::nlp::pipeline::IndexedWord* temp = headindexedword_;
  headindexedword_ = NULL;
  return temp;
}
void Mention::set_allocated_headindexedword(::edu::stanford::nlp::pipeline::IndexedWord* headindexedword) {
  delete headindexedword_;
  headindexedword_ = headindexedword;
  if (headindexedword) {
    set_has_headindexedword();
  } else {
    clear_has_headindexedword();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.headIndexedWord)
}

// optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
bool Mention::has_dependingverb() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
void Mention::set_has_dependingverb() {
  _has_bits_[0] |= 0x20000000u;
}
void Mention::clear_has_dependingverb() {
  _has_bits_[0] &= ~0x20000000u;
}
void Mention::clear_dependingverb() {
  if (dependingverb_ != NULL) dependingverb_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
  clear_has_dependingverb();
}
const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::dependingverb() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.dependingVerb)
  return dependingverb_ != NULL ? *dependingverb_ : *default_instance_->dependingverb_;
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_dependingverb() {
  set_has_dependingverb();
  if (dependingverb_ == NULL) {
    dependingverb_ = new ::edu::stanford::nlp::pipeline::IndexedWord;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.dependingVerb)
  return dependingverb_;
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::release_dependingverb() {
  clear_has_dependingverb();
  ::edu::stanford::nlp::pipeline::IndexedWord* temp = dependingverb_;
  dependingverb_ = NULL;
  return temp;
}
void Mention::set_allocated_dependingverb(::edu::stanford::nlp::pipeline::IndexedWord* dependingverb) {
  delete dependingverb_;
  dependingverb_ = dependingverb;
  if (dependingverb) {
    set_has_dependingverb();
  } else {
    clear_has_dependingverb();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.dependingVerb)
}

// optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
bool Mention::has_headword() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
void Mention::set_has_headword() {
  _has_bits_[0] |= 0x40000000u;
}
void Mention::clear_has_headword() {
  _has_bits_[0] &= ~0x40000000u;
}
void Mention::clear_headword() {
  if (headword_ != NULL) headword_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
  clear_has_headword();
}
const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::headword() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headWord)
  return headword_ != NULL ? *headword_ : *default_instance_->headword_;
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_headword() {
  set_has_headword();
  if (headword_ == NULL) {
    headword_ = new ::edu::stanford::nlp::pipeline::IndexedWord;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.headWord)
  return headword_;
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::release_headword() {
  clear_has_headword();
  ::edu::stanford::nlp::pipeline::IndexedWord* temp = headword_;
  headword_ = NULL;
  return temp;
}
void Mention::set_allocated_headword(::edu::stanford::nlp::pipeline::IndexedWord* headword) {
  delete headword_;
  headword_ = headword;
  if (headword) {
    set_has_headword();
  } else {
    clear_has_headword();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.headWord)
}

// optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
bool Mention::has_speakerinfo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
void Mention::set_has_speakerinfo() {
  _has_bits_[0] |= 0x80000000u;
}
void Mention::clear_has_speakerinfo() {
  _has_bits_[0] &= ~0x80000000u;
}
void Mention::clear_speakerinfo() {
  if (speakerinfo_ != NULL) speakerinfo_->::edu::stanford::nlp::pipeline::SpeakerInfo::Clear();
  clear_has_speakerinfo();
}
const ::edu::stanford::nlp::pipeline::SpeakerInfo& Mention::speakerinfo() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.speakerInfo)
  return speakerinfo_ != NULL ? *speakerinfo_ : *default_instance_->speakerinfo_;
}
::edu::stanford::nlp::pipeline::SpeakerInfo* Mention::mutable_speakerinfo() {
  set_has_speakerinfo();
  if (speakerinfo_ == NULL) {
    speakerinfo_ = new ::edu::stanford::nlp::pipeline::SpeakerInfo;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.speakerInfo)
  return speakerinfo_;
}
::edu::stanford::nlp::pipeline::SpeakerInfo* Mention::release_speakerinfo() {
  clear_has_speakerinfo();
  ::edu::stanford::nlp::pipeline::SpeakerInfo* temp = speakerinfo_;
  speakerinfo_ = NULL;
  return temp;
}
void Mention::set_allocated_speakerinfo(::edu::stanford::nlp::pipeline::SpeakerInfo* speakerinfo) {
  delete speakerinfo_;
  speakerinfo_ = speakerinfo;
  if (speakerinfo) {
    set_has_speakerinfo();
  } else {
    clear_has_speakerinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.speakerInfo)
}

// repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
int Mention::sentencewords_size() const {
  return sentencewords_.size();
}
void Mention::clear_sentencewords() {
  sentencewords_.Clear();
}
const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::sentencewords(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_.Get(index);
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_sentencewords(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_.Mutable(index);
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::add_sentencewords() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >*
Mention::mutable_sentencewords() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return &sentencewords_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >&
Mention::sentencewords() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_;
}

// repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
int Mention::originalspan_size() const {
  return originalspan_.size();
}
void Mention::clear_originalspan() {
  originalspan_.Clear();
}
const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::originalspan(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_.Get(index);
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_originalspan(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_.Mutable(index);
}
::edu::stanford::nlp::pipeline::IndexedWord* Mention::add_originalspan() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >*
Mention::mutable_originalspan() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return &originalspan_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >&
Mention::originalspan() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_;
}

// repeated string dependents = 52;
int Mention::dependents_size() const {
  return dependents_.size();
}
void Mention::clear_dependents() {
  dependents_.Clear();
}
 const ::std::string& Mention::dependents(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.dependents)
  return dependents_.Get(index);
}
 ::std::string* Mention::mutable_dependents(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.dependents)
  return dependents_.Mutable(index);
}
 void Mention::set_dependents(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.dependents)
  dependents_.Mutable(index)->assign(value);
}
 void Mention::set_dependents(int index, const char* value) {
  dependents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.dependents)
}
 void Mention::set_dependents(int index, const char* value, size_t size) {
  dependents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.dependents)
}
 ::std::string* Mention::add_dependents() {
  return dependents_.Add();
}
 void Mention::add_dependents(const ::std::string& value) {
  dependents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.dependents)
}
 void Mention::add_dependents(const char* value) {
  dependents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Mention.dependents)
}
 void Mention::add_dependents(const char* value, size_t size) {
  dependents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Mention.dependents)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mention::dependents() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.dependents)
  return dependents_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Mention::mutable_dependents() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.dependents)
  return &dependents_;
}

// repeated string preprocessedTerms = 53;
int Mention::preprocessedterms_size() const {
  return preprocessedterms_.size();
}
void Mention::clear_preprocessedterms() {
  preprocessedterms_.Clear();
}
 const ::std::string& Mention::preprocessedterms(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return preprocessedterms_.Get(index);
}
 ::std::string* Mention::mutable_preprocessedterms(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return preprocessedterms_.Mutable(index);
}
 void Mention::set_preprocessedterms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  preprocessedterms_.Mutable(index)->assign(value);
}
 void Mention::set_preprocessedterms(int index, const char* value) {
  preprocessedterms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
 void Mention::set_preprocessedterms(int index, const char* value, size_t size) {
  preprocessedterms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
 ::std::string* Mention::add_preprocessedterms() {
  return preprocessedterms_.Add();
}
 void Mention::add_preprocessedterms(const ::std::string& value) {
  preprocessedterms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
 void Mention::add_preprocessedterms(const char* value) {
  preprocessedterms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
 void Mention::add_preprocessedterms(const char* value, size_t size) {
  preprocessedterms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mention::preprocessedterms() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return preprocessedterms_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Mention::mutable_preprocessedterms() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return &preprocessedterms_;
}

// repeated int32 appositions = 54;
int Mention::appositions_size() const {
  return appositions_.size();
}
void Mention::clear_appositions() {
  appositions_.Clear();
}
 ::google::protobuf::int32 Mention::appositions(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.appositions)
  return appositions_.Get(index);
}
 void Mention::set_appositions(int index, ::google::protobuf::int32 value) {
  appositions_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.appositions)
}
 void Mention::add_appositions(::google::protobuf::int32 value) {
  appositions_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.appositions)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::appositions() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.appositions)
  return appositions_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_appositions() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.appositions)
  return &appositions_;
}

// repeated int32 predicateNominatives = 55;
int Mention::predicatenominatives_size() const {
  return predicatenominatives_.size();
}
void Mention::clear_predicatenominatives() {
  predicatenominatives_.Clear();
}
 ::google::protobuf::int32 Mention::predicatenominatives(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
  return predicatenominatives_.Get(index);
}
 void Mention::set_predicatenominatives(int index, ::google::protobuf::int32 value) {
  predicatenominatives_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
}
 void Mention::add_predicatenominatives(::google::protobuf::int32 value) {
  predicatenominatives_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::predicatenominatives() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
  return predicatenominatives_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_predicatenominatives() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
  return &predicatenominatives_;
}

// repeated int32 relativePronouns = 56;
int Mention::relativepronouns_size() const {
  return relativepronouns_.size();
}
void Mention::clear_relativepronouns() {
  relativepronouns_.Clear();
}
 ::google::protobuf::int32 Mention::relativepronouns(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.relativePronouns)
  return relativepronouns_.Get(index);
}
 void Mention::set_relativepronouns(int index, ::google::protobuf::int32 value) {
  relativepronouns_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.relativePronouns)
}
 void Mention::add_relativepronouns(::google::protobuf::int32 value) {
  relativepronouns_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.relativePronouns)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::relativepronouns() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.relativePronouns)
  return relativepronouns_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_relativepronouns() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.relativePronouns)
  return &relativepronouns_;
}

// repeated int32 listMembers = 57;
int Mention::listmembers_size() const {
  return listmembers_.size();
}
void Mention::clear_listmembers() {
  listmembers_.Clear();
}
 ::google::protobuf::int32 Mention::listmembers(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.listMembers)
  return listmembers_.Get(index);
}
 void Mention::set_listmembers(int index, ::google::protobuf::int32 value) {
  listmembers_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.listMembers)
}
 void Mention::add_listmembers(::google::protobuf::int32 value) {
  listmembers_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.listMembers)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::listmembers() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.listMembers)
  return listmembers_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_listmembers() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.listMembers)
  return &listmembers_;
}

// repeated int32 belongToLists = 58;
int Mention::belongtolists_size() const {
  return belongtolists_.size();
}
void Mention::clear_belongtolists() {
  belongtolists_.Clear();
}
 ::google::protobuf::int32 Mention::belongtolists(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.belongToLists)
  return belongtolists_.Get(index);
}
 void Mention::set_belongtolists(int index, ::google::protobuf::int32 value) {
  belongtolists_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.belongToLists)
}
 void Mention::add_belongtolists(::google::protobuf::int32 value) {
  belongtolists_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.belongToLists)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::belongtolists() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.belongToLists)
  return belongtolists_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_belongtolists() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.belongToLists)
  return &belongtolists_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IndexedWord::kSentenceNumFieldNumber;
const int IndexedWord::kTokenIndexFieldNumber;
const int IndexedWord::kDocIDFieldNumber;
const int IndexedWord::kCopyCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IndexedWord::IndexedWord()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.IndexedWord)
}

void IndexedWord::InitAsDefaultInstance() {
}

IndexedWord::IndexedWord(const IndexedWord& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.IndexedWord)
}

void IndexedWord::SharedCtor() {
  _cached_size_ = 0;
  sentencenum_ = 0u;
  tokenindex_ = 0u;
  docid_ = 0u;
  copycount_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IndexedWord::~IndexedWord() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.IndexedWord)
  SharedDtor();
}

void IndexedWord::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IndexedWord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IndexedWord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IndexedWord_descriptor_;
}

const IndexedWord& IndexedWord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

IndexedWord* IndexedWord::default_instance_ = NULL;

IndexedWord* IndexedWord::New(::google::protobuf::Arena* arena) const {
  IndexedWord* n = new IndexedWord;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IndexedWord::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IndexedWord*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(sentencenum_, copycount_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IndexedWord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.IndexedWord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sentenceNum = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentencenum_)));
          set_has_sentencenum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_tokenIndex;
        break;
      }

      // optional uint32 tokenIndex = 2;
      case 2: {
        if (tag == 16) {
         parse_tokenIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenindex_)));
          set_has_tokenindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_docID;
        break;
      }

      // optional uint32 docID = 3;
      case 3: {
        if (tag == 24) {
         parse_docID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &docid_)));
          set_has_docid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_copyCount;
        break;
      }

      // optional uint32 copyCount = 4;
      case 4: {
        if (tag == 32) {
         parse_copyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &copycount_)));
          set_has_copycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.IndexedWord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.IndexedWord)
  return false;
#undef DO_
}

void IndexedWord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.IndexedWord)
  // optional uint32 sentenceNum = 1;
  if (has_sentencenum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sentencenum(), output);
  }

  // optional uint32 tokenIndex = 2;
  if (has_tokenindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tokenindex(), output);
  }

  // optional uint32 docID = 3;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->docid(), output);
  }

  // optional uint32 copyCount = 4;
  if (has_copycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->copycount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.IndexedWord)
}

::google::protobuf::uint8* IndexedWord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.IndexedWord)
  // optional uint32 sentenceNum = 1;
  if (has_sentencenum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sentencenum(), target);
  }

  // optional uint32 tokenIndex = 2;
  if (has_tokenindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->tokenindex(), target);
  }

  // optional uint32 docID = 3;
  if (has_docid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->docid(), target);
  }

  // optional uint32 copyCount = 4;
  if (has_copycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->copycount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.IndexedWord)
  return target;
}

int IndexedWord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional uint32 sentenceNum = 1;
    if (has_sentencenum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentencenum());
    }

    // optional uint32 tokenIndex = 2;
    if (has_tokenindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tokenindex());
    }

    // optional uint32 docID = 3;
    if (has_docid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->docid());
    }

    // optional uint32 copyCount = 4;
    if (has_copycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->copycount());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IndexedWord::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IndexedWord* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IndexedWord>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IndexedWord::MergeFrom(const IndexedWord& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sentencenum()) {
      set_sentencenum(from.sentencenum());
    }
    if (from.has_tokenindex()) {
      set_tokenindex(from.tokenindex());
    }
    if (from.has_docid()) {
      set_docid(from.docid());
    }
    if (from.has_copycount()) {
      set_copycount(from.copycount());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IndexedWord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IndexedWord::CopyFrom(const IndexedWord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexedWord::IsInitialized() const {

  return true;
}

void IndexedWord::Swap(IndexedWord* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IndexedWord::InternalSwap(IndexedWord* other) {
  std::swap(sentencenum_, other->sentencenum_);
  std::swap(tokenindex_, other->tokenindex_);
  std::swap(docid_, other->docid_);
  std::swap(copycount_, other->copycount_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IndexedWord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IndexedWord_descriptor_;
  metadata.reflection = IndexedWord_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IndexedWord

// optional uint32 sentenceNum = 1;
bool IndexedWord::has_sentencenum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IndexedWord::set_has_sentencenum() {
  _has_bits_[0] |= 0x00000001u;
}
void IndexedWord::clear_has_sentencenum() {
  _has_bits_[0] &= ~0x00000001u;
}
void IndexedWord::clear_sentencenum() {
  sentencenum_ = 0u;
  clear_has_sentencenum();
}
 ::google::protobuf::uint32 IndexedWord::sentencenum() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.sentenceNum)
  return sentencenum_;
}
 void IndexedWord::set_sentencenum(::google::protobuf::uint32 value) {
  set_has_sentencenum();
  sentencenum_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.sentenceNum)
}

// optional uint32 tokenIndex = 2;
bool IndexedWord::has_tokenindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IndexedWord::set_has_tokenindex() {
  _has_bits_[0] |= 0x00000002u;
}
void IndexedWord::clear_has_tokenindex() {
  _has_bits_[0] &= ~0x00000002u;
}
void IndexedWord::clear_tokenindex() {
  tokenindex_ = 0u;
  clear_has_tokenindex();
}
 ::google::protobuf::uint32 IndexedWord::tokenindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.tokenIndex)
  return tokenindex_;
}
 void IndexedWord::set_tokenindex(::google::protobuf::uint32 value) {
  set_has_tokenindex();
  tokenindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.tokenIndex)
}

// optional uint32 docID = 3;
bool IndexedWord::has_docid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IndexedWord::set_has_docid() {
  _has_bits_[0] |= 0x00000004u;
}
void IndexedWord::clear_has_docid() {
  _has_bits_[0] &= ~0x00000004u;
}
void IndexedWord::clear_docid() {
  docid_ = 0u;
  clear_has_docid();
}
 ::google::protobuf::uint32 IndexedWord::docid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.docID)
  return docid_;
}
 void IndexedWord::set_docid(::google::protobuf::uint32 value) {
  set_has_docid();
  docid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.docID)
}

// optional uint32 copyCount = 4;
bool IndexedWord::has_copycount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IndexedWord::set_has_copycount() {
  _has_bits_[0] |= 0x00000008u;
}
void IndexedWord::clear_has_copycount() {
  _has_bits_[0] &= ~0x00000008u;
}
void IndexedWord::clear_copycount() {
  copycount_ = 0u;
  clear_has_copycount();
}
 ::google::protobuf::uint32 IndexedWord::copycount() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.copyCount)
  return copycount_;
}
 void IndexedWord::set_copycount(::google::protobuf::uint32 value) {
  set_has_copycount();
  copycount_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.copyCount)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SpeakerInfo::kSpeakerNameFieldNumber;
const int SpeakerInfo::kMentionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SpeakerInfo::SpeakerInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.SpeakerInfo)
}

void SpeakerInfo::InitAsDefaultInstance() {
}

SpeakerInfo::SpeakerInfo(const SpeakerInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.SpeakerInfo)
}

void SpeakerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  speakername_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpeakerInfo::~SpeakerInfo() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.SpeakerInfo)
  SharedDtor();
}

void SpeakerInfo::SharedDtor() {
  speakername_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SpeakerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SpeakerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SpeakerInfo_descriptor_;
}

const SpeakerInfo& SpeakerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

SpeakerInfo* SpeakerInfo::default_instance_ = NULL;

SpeakerInfo* SpeakerInfo::New(::google::protobuf::Arena* arena) const {
  SpeakerInfo* n = new SpeakerInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SpeakerInfo::Clear() {
  if (has_speakername()) {
    speakername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  mentions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SpeakerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.SpeakerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string speakerName = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_speakername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->speakername().data(), this->speakername().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.SpeakerInfo.speakerName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mentions;
        break;
      }

      // repeated int32 mentions = 2;
      case 2: {
        if (tag == 16) {
         parse_mentions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 16, input, this->mutable_mentions())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_mentions())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mentions;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.SpeakerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.SpeakerInfo)
  return false;
#undef DO_
}

void SpeakerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.SpeakerInfo)
  // optional string speakerName = 1;
  if (has_speakername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->speakername().data(), this->speakername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.SpeakerInfo.speakerName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->speakername(), output);
  }

  // repeated int32 mentions = 2;
  for (int i = 0; i < this->mentions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      2, this->mentions(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.SpeakerInfo)
}

::google::protobuf::uint8* SpeakerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.SpeakerInfo)
  // optional string speakerName = 1;
  if (has_speakername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->speakername().data(), this->speakername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.SpeakerInfo.speakerName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->speakername(), target);
  }

  // repeated int32 mentions = 2;
  for (int i = 0; i < this->mentions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(2, this->mentions(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.SpeakerInfo)
  return target;
}

int SpeakerInfo::ByteSize() const {
  int total_size = 0;

  // optional string speakerName = 1;
  if (has_speakername()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->speakername());
  }

  // repeated int32 mentions = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->mentions_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->mentions(i));
    }
    total_size += 1 * this->mentions_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpeakerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SpeakerInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SpeakerInfo>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SpeakerInfo::MergeFrom(const SpeakerInfo& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  mentions_.MergeFrom(from.mentions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_speakername()) {
      set_has_speakername();
      speakername_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.speakername_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SpeakerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpeakerInfo::CopyFrom(const SpeakerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeakerInfo::IsInitialized() const {

  return true;
}

void SpeakerInfo::Swap(SpeakerInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SpeakerInfo::InternalSwap(SpeakerInfo* other) {
  speakername_.Swap(&other->speakername_);
  mentions_.UnsafeArenaSwap(&other->mentions_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SpeakerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SpeakerInfo_descriptor_;
  metadata.reflection = SpeakerInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SpeakerInfo

// optional string speakerName = 1;
bool SpeakerInfo::has_speakername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SpeakerInfo::set_has_speakername() {
  _has_bits_[0] |= 0x00000001u;
}
void SpeakerInfo::clear_has_speakername() {
  _has_bits_[0] &= ~0x00000001u;
}
void SpeakerInfo::clear_speakername() {
  speakername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_speakername();
}
 const ::std::string& SpeakerInfo::speakername() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
  return speakername_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SpeakerInfo::set_speakername(const ::std::string& value) {
  set_has_speakername();
  speakername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}
 void SpeakerInfo::set_speakername(const char* value) {
  set_has_speakername();
  speakername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}
 void SpeakerInfo::set_speakername(const char* value, size_t size) {
  set_has_speakername();
  speakername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}
 ::std::string* SpeakerInfo::mutable_speakername() {
  set_has_speakername();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
  return speakername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SpeakerInfo::release_speakername() {
  clear_has_speakername();
  return speakername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SpeakerInfo::set_allocated_speakername(::std::string* speakername) {
  if (speakername != NULL) {
    set_has_speakername();
  } else {
    clear_has_speakername();
  }
  speakername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), speakername);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}

// repeated int32 mentions = 2;
int SpeakerInfo::mentions_size() const {
  return mentions_.size();
}
void SpeakerInfo::clear_mentions() {
  mentions_.Clear();
}
 ::google::protobuf::int32 SpeakerInfo::mentions(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
  return mentions_.Get(index);
}
 void SpeakerInfo::set_mentions(int index, ::google::protobuf::int32 value) {
  mentions_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
}
 void SpeakerInfo::add_mentions(::google::protobuf::int32 value) {
  mentions_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SpeakerInfo::mentions() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
  return mentions_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SpeakerInfo::mutable_mentions() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
  return &mentions_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Span::kBeginFieldNumber;
const int Span::kEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Span::Span()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Span)
}

void Span::InitAsDefaultInstance() {
}

Span::Span(const Span& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Span)
}

void Span::SharedCtor() {
  _cached_size_ = 0;
  begin_ = 0u;
  end_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Span::~Span() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Span)
  SharedDtor();
}

void Span::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Span::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Span::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Span_descriptor_;
}

const Span& Span::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Span* Span::default_instance_ = NULL;

Span* Span::New(::google::protobuf::Arena* arena) const {
  Span* n = new Span;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Span::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Span*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(begin_, end_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Span::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Span)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 begin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_)));
          set_has_begin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_end;
        break;
      }

      // required uint32 end = 2;
      case 2: {
        if (tag == 16) {
         parse_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_)));
          set_has_end();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Span)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Span)
  return false;
#undef DO_
}

void Span::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Span)
  // required uint32 begin = 1;
  if (has_begin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->begin(), output);
  }

  // required uint32 end = 2;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->end(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Span)
}

::google::protobuf::uint8* Span::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Span)
  // required uint32 begin = 1;
  if (has_begin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->begin(), target);
  }

  // required uint32 end = 2;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->end(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Span)
  return target;
}

int Span::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_begin()) {
    // required uint32 begin = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->begin());
  }

  if (has_end()) {
    // required uint32 end = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->end());
  }

  return total_size;
}
int Span::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 begin = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->begin());

    // required uint32 end = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->end());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Span::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Span* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Span>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Span::MergeFrom(const Span& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin()) {
      set_begin(from.begin());
    }
    if (from.has_end()) {
      set_end(from.end());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Span::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Span::CopyFrom(const Span& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Span::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Span::Swap(Span* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Span::InternalSwap(Span* other) {
  std::swap(begin_, other->begin_);
  std::swap(end_, other->end_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Span::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Span_descriptor_;
  metadata.reflection = Span_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Span

// required uint32 begin = 1;
bool Span::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Span::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
void Span::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
void Span::clear_begin() {
  begin_ = 0u;
  clear_has_begin();
}
 ::google::protobuf::uint32 Span::begin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Span.begin)
  return begin_;
}
 void Span::set_begin(::google::protobuf::uint32 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Span.begin)
}

// required uint32 end = 2;
bool Span::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Span::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
void Span::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
void Span::clear_end() {
  end_ = 0u;
  clear_has_end();
}
 ::google::protobuf::uint32 Span::end() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Span.end)
  return end_;
}
 void Span::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Span.end)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Timex::kValueFieldNumber;
const int Timex::kAltValueFieldNumber;
const int Timex::kTextFieldNumber;
const int Timex::kTypeFieldNumber;
const int Timex::kTidFieldNumber;
const int Timex::kBeginPointFieldNumber;
const int Timex::kEndPointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Timex::Timex()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Timex)
}

void Timex::InitAsDefaultInstance() {
}

Timex::Timex(const Timex& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Timex)
}

void Timex::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  altvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  beginpoint_ = 0u;
  endpoint_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Timex::~Timex() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Timex)
  SharedDtor();
}

void Timex::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  altvalue_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Timex::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Timex::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Timex_descriptor_;
}

const Timex& Timex::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Timex* Timex::default_instance_ = NULL;

Timex* Timex::New(::google::protobuf::Arena* arena) const {
  Timex* n = new Timex;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Timex::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Timex*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(beginpoint_, endpoint_);
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_altvalue()) {
      altvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_text()) {
      text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_tid()) {
      tid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Timex::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Timex)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Timex.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_altValue;
        break;
      }

      // optional string altValue = 2;
      case 2: {
        if (tag == 18) {
         parse_altValue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_altvalue()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->altvalue().data(), this->altvalue().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Timex.altValue");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_text;
        break;
      }

      // optional string text = 3;
      case 3: {
        if (tag == 26) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Timex.text");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_type;
        break;
      }

      // optional string type = 4;
      case 4: {
        if (tag == 34) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Timex.type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_tid;
        break;
      }

      // optional string tid = 5;
      case 5: {
        if (tag == 42) {
         parse_tid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->tid().data(), this->tid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Timex.tid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_beginPoint;
        break;
      }

      // optional uint32 beginPoint = 6;
      case 6: {
        if (tag == 48) {
         parse_beginPoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &beginpoint_)));
          set_has_beginpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_endPoint;
        break;
      }

      // optional uint32 endPoint = 7;
      case 7: {
        if (tag == 56) {
         parse_endPoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endpoint_)));
          set_has_endpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Timex)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Timex)
  return false;
#undef DO_
}

void Timex::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Timex)
  // optional string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  // optional string altValue = 2;
  if (has_altvalue()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->altvalue().data(), this->altvalue().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.altValue");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->altvalue(), output);
  }

  // optional string text = 3;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->text(), output);
  }

  // optional string type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->type(), output);
  }

  // optional string tid = 5;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tid().data(), this->tid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.tid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->tid(), output);
  }

  // optional uint32 beginPoint = 6;
  if (has_beginpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->beginpoint(), output);
  }

  // optional uint32 endPoint = 7;
  if (has_endpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->endpoint(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Timex)
}

::google::protobuf::uint8* Timex::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Timex)
  // optional string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  // optional string altValue = 2;
  if (has_altvalue()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->altvalue().data(), this->altvalue().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.altValue");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->altvalue(), target);
  }

  // optional string text = 3;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->text(), target);
  }

  // optional string type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->type(), target);
  }

  // optional string tid = 5;
  if (has_tid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tid().data(), this->tid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Timex.tid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->tid(), target);
  }

  // optional uint32 beginPoint = 6;
  if (has_beginpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->beginpoint(), target);
  }

  // optional uint32 endPoint = 7;
  if (has_endpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->endpoint(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Timex)
  return target;
}

int Timex::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional string value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional string altValue = 2;
    if (has_altvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->altvalue());
    }

    // optional string text = 3;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional string type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string tid = 5;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tid());
    }

    // optional uint32 beginPoint = 6;
    if (has_beginpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->beginpoint());
    }

    // optional uint32 endPoint = 7;
    if (has_endpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endpoint());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Timex::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Timex* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Timex>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Timex::MergeFrom(const Timex& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_altvalue()) {
      set_has_altvalue();
      altvalue_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.altvalue_);
    }
    if (from.has_text()) {
      set_has_text();
      text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
    if (from.has_tid()) {
      set_has_tid();
      tid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.tid_);
    }
    if (from.has_beginpoint()) {
      set_beginpoint(from.beginpoint());
    }
    if (from.has_endpoint()) {
      set_endpoint(from.endpoint());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Timex::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timex::CopyFrom(const Timex& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timex::IsInitialized() const {

  return true;
}

void Timex::Swap(Timex* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Timex::InternalSwap(Timex* other) {
  value_.Swap(&other->value_);
  altvalue_.Swap(&other->altvalue_);
  text_.Swap(&other->text_);
  type_.Swap(&other->type_);
  tid_.Swap(&other->tid_);
  std::swap(beginpoint_, other->beginpoint_);
  std::swap(endpoint_, other->endpoint_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Timex::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Timex_descriptor_;
  metadata.reflection = Timex_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Timex

// optional string value = 1;
bool Timex::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Timex::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void Timex::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void Timex::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Timex::value() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.value)
}
 void Timex::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.value)
}
 void Timex::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.value)
}
 ::std::string* Timex::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Timex::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.value)
}

// optional string altValue = 2;
bool Timex::has_altvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Timex::set_has_altvalue() {
  _has_bits_[0] |= 0x00000002u;
}
void Timex::clear_has_altvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
void Timex::clear_altvalue() {
  altvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_altvalue();
}
 const ::std::string& Timex::altvalue() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.altValue)
  return altvalue_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_altvalue(const ::std::string& value) {
  set_has_altvalue();
  altvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.altValue)
}
 void Timex::set_altvalue(const char* value) {
  set_has_altvalue();
  altvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.altValue)
}
 void Timex::set_altvalue(const char* value, size_t size) {
  set_has_altvalue();
  altvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.altValue)
}
 ::std::string* Timex::mutable_altvalue() {
  set_has_altvalue();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.altValue)
  return altvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Timex::release_altvalue() {
  clear_has_altvalue();
  return altvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_allocated_altvalue(::std::string* altvalue) {
  if (altvalue != NULL) {
    set_has_altvalue();
  } else {
    clear_has_altvalue();
  }
  altvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), altvalue);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.altValue)
}

// optional string text = 3;
bool Timex::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Timex::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
void Timex::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
void Timex::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
 const ::std::string& Timex::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.text)
}
 void Timex::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.text)
}
 void Timex::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.text)
}
 ::std::string* Timex::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Timex::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.text)
}

// optional string type = 4;
bool Timex::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Timex::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
void Timex::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void Timex::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& Timex::type() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.type)
}
 void Timex::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.type)
}
 void Timex::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.type)
}
 ::std::string* Timex::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Timex::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.type)
}

// optional string tid = 5;
bool Timex::has_tid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Timex::set_has_tid() {
  _has_bits_[0] |= 0x00000010u;
}
void Timex::clear_has_tid() {
  _has_bits_[0] &= ~0x00000010u;
}
void Timex::clear_tid() {
  tid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tid();
}
 const ::std::string& Timex::tid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.tid)
  return tid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_tid(const ::std::string& value) {
  set_has_tid();
  tid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.tid)
}
 void Timex::set_tid(const char* value) {
  set_has_tid();
  tid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.tid)
}
 void Timex::set_tid(const char* value, size_t size) {
  set_has_tid();
  tid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.tid)
}
 ::std::string* Timex::mutable_tid() {
  set_has_tid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.tid)
  return tid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Timex::release_tid() {
  clear_has_tid();
  return tid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Timex::set_allocated_tid(::std::string* tid) {
  if (tid != NULL) {
    set_has_tid();
  } else {
    clear_has_tid();
  }
  tid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.tid)
}

// optional uint32 beginPoint = 6;
bool Timex::has_beginpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Timex::set_has_beginpoint() {
  _has_bits_[0] |= 0x00000020u;
}
void Timex::clear_has_beginpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
void Timex::clear_beginpoint() {
  beginpoint_ = 0u;
  clear_has_beginpoint();
}
 ::google::protobuf::uint32 Timex::beginpoint() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.beginPoint)
  return beginpoint_;
}
 void Timex::set_beginpoint(::google::protobuf::uint32 value) {
  set_has_beginpoint();
  beginpoint_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.beginPoint)
}

// optional uint32 endPoint = 7;
bool Timex::has_endpoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Timex::set_has_endpoint() {
  _has_bits_[0] |= 0x00000040u;
}
void Timex::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000040u;
}
void Timex::clear_endpoint() {
  endpoint_ = 0u;
  clear_has_endpoint();
}
 ::google::protobuf::uint32 Timex::endpoint() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.endPoint)
  return endpoint_;
}
 void Timex::set_endpoint(::google::protobuf::uint32 value) {
  set_has_endpoint();
  endpoint_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.endPoint)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Entity::kHeadStartFieldNumber;
const int Entity::kHeadEndFieldNumber;
const int Entity::kMentionTypeFieldNumber;
const int Entity::kNormalizedNameFieldNumber;
const int Entity::kHeadTokenIndexFieldNumber;
const int Entity::kCorefIDFieldNumber;
const int Entity::kObjectIDFieldNumber;
const int Entity::kExtentStartFieldNumber;
const int Entity::kExtentEndFieldNumber;
const int Entity::kTypeFieldNumber;
const int Entity::kSubtypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Entity::Entity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Entity)
}

void Entity::InitAsDefaultInstance() {
}

Entity::Entity(const Entity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Entity)
}

void Entity::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  headstart_ = 0u;
  headend_ = 0u;
  mentiontype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  normalizedname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  headtokenindex_ = 0u;
  corefid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  objectid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  extentstart_ = 0u;
  extentend_ = 0u;
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  subtype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entity::~Entity() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Entity)
  SharedDtor();
}

void Entity::SharedDtor() {
  mentiontype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  normalizedname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  corefid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  objectid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  subtype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Entity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entity_descriptor_;
}

const Entity& Entity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Entity* Entity::default_instance_ = NULL;

Entity* Entity::New(::google::protobuf::Arena* arena) const {
  Entity* n = new Entity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Entity::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Entity*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(headstart_, headend_);
    ZR_(headtokenindex_, extentstart_);
    if (has_mentiontype()) {
      mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_normalizedname()) {
      normalizedname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_corefid()) {
      corefid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_objectid()) {
      objectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 1792u) {
    extentend_ = 0u;
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_subtype()) {
      subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Entity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Entity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string objectID = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_objectid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->objectid().data(), this->objectid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Entity.objectID");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_extentStart;
        break;
      }

      // optional uint32 extentStart = 2;
      case 2: {
        if (tag == 16) {
         parse_extentStart:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extentstart_)));
          set_has_extentstart();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_extentEnd;
        break;
      }

      // optional uint32 extentEnd = 3;
      case 3: {
        if (tag == 24) {
         parse_extentEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extentend_)));
          set_has_extentend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_type;
        break;
      }

      // optional string type = 4;
      case 4: {
        if (tag == 34) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Entity.type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_subtype;
        break;
      }

      // optional string subtype = 5;
      case 5: {
        if (tag == 42) {
         parse_subtype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->subtype().data(), this->subtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Entity.subtype");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_headStart;
        break;
      }

      // optional uint32 headStart = 6;
      case 6: {
        if (tag == 48) {
         parse_headStart:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &headstart_)));
          set_has_headstart();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_headEnd;
        break;
      }

      // optional uint32 headEnd = 7;
      case 7: {
        if (tag == 56) {
         parse_headEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &headend_)));
          set_has_headend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_mentionType;
        break;
      }

      // optional string mentionType = 8;
      case 8: {
        if (tag == 66) {
         parse_mentionType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mentiontype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mentiontype().data(), this->mentiontype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Entity.mentionType");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_normalizedName;
        break;
      }

      // optional string normalizedName = 9;
      case 9: {
        if (tag == 74) {
         parse_normalizedName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_normalizedname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->normalizedname().data(), this->normalizedname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Entity.normalizedName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_headTokenIndex;
        break;
      }

      // optional uint32 headTokenIndex = 10;
      case 10: {
        if (tag == 80) {
         parse_headTokenIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &headtokenindex_)));
          set_has_headtokenindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_corefID;
        break;
      }

      // optional string corefID = 11;
      case 11: {
        if (tag == 90) {
         parse_corefID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_corefid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->corefid().data(), this->corefid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Entity.corefID");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Entity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Entity)
  return false;
#undef DO_
}

void Entity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Entity)
  // optional string objectID = 1;
  if (has_objectid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->objectid().data(), this->objectid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.objectID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->objectid(), output);
  }

  // optional uint32 extentStart = 2;
  if (has_extentstart()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->extentstart(), output);
  }

  // optional uint32 extentEnd = 3;
  if (has_extentend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->extentend(), output);
  }

  // optional string type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->type(), output);
  }

  // optional string subtype = 5;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.subtype");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->subtype(), output);
  }

  // optional uint32 headStart = 6;
  if (has_headstart()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->headstart(), output);
  }

  // optional uint32 headEnd = 7;
  if (has_headend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->headend(), output);
  }

  // optional string mentionType = 8;
  if (has_mentiontype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mentiontype().data(), this->mentiontype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.mentionType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->mentiontype(), output);
  }

  // optional string normalizedName = 9;
  if (has_normalizedname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->normalizedname().data(), this->normalizedname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.normalizedName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->normalizedname(), output);
  }

  // optional uint32 headTokenIndex = 10;
  if (has_headtokenindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->headtokenindex(), output);
  }

  // optional string corefID = 11;
  if (has_corefid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->corefid().data(), this->corefid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.corefID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->corefid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Entity)
}

::google::protobuf::uint8* Entity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Entity)
  // optional string objectID = 1;
  if (has_objectid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->objectid().data(), this->objectid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.objectID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->objectid(), target);
  }

  // optional uint32 extentStart = 2;
  if (has_extentstart()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->extentstart(), target);
  }

  // optional uint32 extentEnd = 3;
  if (has_extentend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->extentend(), target);
  }

  // optional string type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->type(), target);
  }

  // optional string subtype = 5;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.subtype");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->subtype(), target);
  }

  // optional uint32 headStart = 6;
  if (has_headstart()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->headstart(), target);
  }

  // optional uint32 headEnd = 7;
  if (has_headend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->headend(), target);
  }

  // optional string mentionType = 8;
  if (has_mentiontype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mentiontype().data(), this->mentiontype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.mentionType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->mentiontype(), target);
  }

  // optional string normalizedName = 9;
  if (has_normalizedname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->normalizedname().data(), this->normalizedname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.normalizedName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->normalizedname(), target);
  }

  // optional uint32 headTokenIndex = 10;
  if (has_headtokenindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->headtokenindex(), target);
  }

  // optional string corefID = 11;
  if (has_corefid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->corefid().data(), this->corefid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Entity.corefID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->corefid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Entity)
  return target;
}

int Entity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional uint32 headStart = 6;
    if (has_headstart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->headstart());
    }

    // optional uint32 headEnd = 7;
    if (has_headend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->headend());
    }

    // optional string mentionType = 8;
    if (has_mentiontype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mentiontype());
    }

    // optional string normalizedName = 9;
    if (has_normalizedname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->normalizedname());
    }

    // optional uint32 headTokenIndex = 10;
    if (has_headtokenindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->headtokenindex());
    }

    // optional string corefID = 11;
    if (has_corefid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->corefid());
    }

    // optional string objectID = 1;
    if (has_objectid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->objectid());
    }

    // optional uint32 extentStart = 2;
    if (has_extentstart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extentstart());
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional uint32 extentEnd = 3;
    if (has_extentend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extentend());
    }

    // optional string type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string subtype = 5;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entity::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Entity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Entity>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entity::MergeFrom(const Entity& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_headstart()) {
      set_headstart(from.headstart());
    }
    if (from.has_headend()) {
      set_headend(from.headend());
    }
    if (from.has_mentiontype()) {
      set_has_mentiontype();
      mentiontype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mentiontype_);
    }
    if (from.has_normalizedname()) {
      set_has_normalizedname();
      normalizedname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.normalizedname_);
    }
    if (from.has_headtokenindex()) {
      set_headtokenindex(from.headtokenindex());
    }
    if (from.has_corefid()) {
      set_has_corefid();
      corefid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.corefid_);
    }
    if (from.has_objectid()) {
      set_has_objectid();
      objectid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.objectid_);
    }
    if (from.has_extentstart()) {
      set_extentstart(from.extentstart());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_extentend()) {
      set_extentend(from.extentend());
    }
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
    if (from.has_subtype()) {
      set_has_subtype();
      subtype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.subtype_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Entity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entity::CopyFrom(const Entity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entity::IsInitialized() const {

  return true;
}

void Entity::Swap(Entity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Entity::InternalSwap(Entity* other) {
  std::swap(headstart_, other->headstart_);
  std::swap(headend_, other->headend_);
  mentiontype_.Swap(&other->mentiontype_);
  normalizedname_.Swap(&other->normalizedname_);
  std::swap(headtokenindex_, other->headtokenindex_);
  corefid_.Swap(&other->corefid_);
  objectid_.Swap(&other->objectid_);
  std::swap(extentstart_, other->extentstart_);
  std::swap(extentend_, other->extentend_);
  type_.Swap(&other->type_);
  subtype_.Swap(&other->subtype_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entity_descriptor_;
  metadata.reflection = Entity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Entity

// optional uint32 headStart = 6;
bool Entity::has_headstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Entity::set_has_headstart() {
  _has_bits_[0] |= 0x00000001u;
}
void Entity::clear_has_headstart() {
  _has_bits_[0] &= ~0x00000001u;
}
void Entity::clear_headstart() {
  headstart_ = 0u;
  clear_has_headstart();
}
 ::google::protobuf::uint32 Entity::headstart() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.headStart)
  return headstart_;
}
 void Entity::set_headstart(::google::protobuf::uint32 value) {
  set_has_headstart();
  headstart_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.headStart)
}

// optional uint32 headEnd = 7;
bool Entity::has_headend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Entity::set_has_headend() {
  _has_bits_[0] |= 0x00000002u;
}
void Entity::clear_has_headend() {
  _has_bits_[0] &= ~0x00000002u;
}
void Entity::clear_headend() {
  headend_ = 0u;
  clear_has_headend();
}
 ::google::protobuf::uint32 Entity::headend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.headEnd)
  return headend_;
}
 void Entity::set_headend(::google::protobuf::uint32 value) {
  set_has_headend();
  headend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.headEnd)
}

// optional string mentionType = 8;
bool Entity::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Entity::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000004u;
}
void Entity::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
void Entity::clear_mentiontype() {
  mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mentiontype();
}
 const ::std::string& Entity::mentiontype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.mentionType)
  return mentiontype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.mentionType)
}
 void Entity::set_mentiontype(const char* value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.mentionType)
}
 void Entity::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.mentionType)
}
 ::std::string* Entity::mutable_mentiontype() {
  set_has_mentiontype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.mentionType)
  return mentiontype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entity::release_mentiontype() {
  clear_has_mentiontype();
  return mentiontype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype != NULL) {
    set_has_mentiontype();
  } else {
    clear_has_mentiontype();
  }
  mentiontype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mentiontype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.mentionType)
}

// optional string normalizedName = 9;
bool Entity::has_normalizedname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Entity::set_has_normalizedname() {
  _has_bits_[0] |= 0x00000008u;
}
void Entity::clear_has_normalizedname() {
  _has_bits_[0] &= ~0x00000008u;
}
void Entity::clear_normalizedname() {
  normalizedname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_normalizedname();
}
 const ::std::string& Entity::normalizedname() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.normalizedName)
  return normalizedname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_normalizedname(const ::std::string& value) {
  set_has_normalizedname();
  normalizedname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.normalizedName)
}
 void Entity::set_normalizedname(const char* value) {
  set_has_normalizedname();
  normalizedname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.normalizedName)
}
 void Entity::set_normalizedname(const char* value, size_t size) {
  set_has_normalizedname();
  normalizedname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.normalizedName)
}
 ::std::string* Entity::mutable_normalizedname() {
  set_has_normalizedname();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.normalizedName)
  return normalizedname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entity::release_normalizedname() {
  clear_has_normalizedname();
  return normalizedname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_allocated_normalizedname(::std::string* normalizedname) {
  if (normalizedname != NULL) {
    set_has_normalizedname();
  } else {
    clear_has_normalizedname();
  }
  normalizedname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normalizedname);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.normalizedName)
}

// optional uint32 headTokenIndex = 10;
bool Entity::has_headtokenindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Entity::set_has_headtokenindex() {
  _has_bits_[0] |= 0x00000010u;
}
void Entity::clear_has_headtokenindex() {
  _has_bits_[0] &= ~0x00000010u;
}
void Entity::clear_headtokenindex() {
  headtokenindex_ = 0u;
  clear_has_headtokenindex();
}
 ::google::protobuf::uint32 Entity::headtokenindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.headTokenIndex)
  return headtokenindex_;
}
 void Entity::set_headtokenindex(::google::protobuf::uint32 value) {
  set_has_headtokenindex();
  headtokenindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.headTokenIndex)
}

// optional string corefID = 11;
bool Entity::has_corefid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Entity::set_has_corefid() {
  _has_bits_[0] |= 0x00000020u;
}
void Entity::clear_has_corefid() {
  _has_bits_[0] &= ~0x00000020u;
}
void Entity::clear_corefid() {
  corefid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_corefid();
}
 const ::std::string& Entity::corefid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.corefID)
  return corefid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_corefid(const ::std::string& value) {
  set_has_corefid();
  corefid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.corefID)
}
 void Entity::set_corefid(const char* value) {
  set_has_corefid();
  corefid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.corefID)
}
 void Entity::set_corefid(const char* value, size_t size) {
  set_has_corefid();
  corefid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.corefID)
}
 ::std::string* Entity::mutable_corefid() {
  set_has_corefid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.corefID)
  return corefid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entity::release_corefid() {
  clear_has_corefid();
  return corefid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_allocated_corefid(::std::string* corefid) {
  if (corefid != NULL) {
    set_has_corefid();
  } else {
    clear_has_corefid();
  }
  corefid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), corefid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.corefID)
}

// optional string objectID = 1;
bool Entity::has_objectid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Entity::set_has_objectid() {
  _has_bits_[0] |= 0x00000040u;
}
void Entity::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000040u;
}
void Entity::clear_objectid() {
  objectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_objectid();
}
 const ::std::string& Entity::objectid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.objectID)
  return objectid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_objectid(const ::std::string& value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.objectID)
}
 void Entity::set_objectid(const char* value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.objectID)
}
 void Entity::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.objectID)
}
 ::std::string* Entity::mutable_objectid() {
  set_has_objectid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.objectID)
  return objectid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entity::release_objectid() {
  clear_has_objectid();
  return objectid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_allocated_objectid(::std::string* objectid) {
  if (objectid != NULL) {
    set_has_objectid();
  } else {
    clear_has_objectid();
  }
  objectid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), objectid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.objectID)
}

// optional uint32 extentStart = 2;
bool Entity::has_extentstart() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Entity::set_has_extentstart() {
  _has_bits_[0] |= 0x00000080u;
}
void Entity::clear_has_extentstart() {
  _has_bits_[0] &= ~0x00000080u;
}
void Entity::clear_extentstart() {
  extentstart_ = 0u;
  clear_has_extentstart();
}
 ::google::protobuf::uint32 Entity::extentstart() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.extentStart)
  return extentstart_;
}
 void Entity::set_extentstart(::google::protobuf::uint32 value) {
  set_has_extentstart();
  extentstart_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.extentStart)
}

// optional uint32 extentEnd = 3;
bool Entity::has_extentend() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Entity::set_has_extentend() {
  _has_bits_[0] |= 0x00000100u;
}
void Entity::clear_has_extentend() {
  _has_bits_[0] &= ~0x00000100u;
}
void Entity::clear_extentend() {
  extentend_ = 0u;
  clear_has_extentend();
}
 ::google::protobuf::uint32 Entity::extentend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.extentEnd)
  return extentend_;
}
 void Entity::set_extentend(::google::protobuf::uint32 value) {
  set_has_extentend();
  extentend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.extentEnd)
}

// optional string type = 4;
bool Entity::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Entity::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
void Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
void Entity::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& Entity::type() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.type)
}
 void Entity::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.type)
}
 void Entity::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.type)
}
 ::std::string* Entity::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entity::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.type)
}

// optional string subtype = 5;
bool Entity::has_subtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Entity::set_has_subtype() {
  _has_bits_[0] |= 0x00000400u;
}
void Entity::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000400u;
}
void Entity::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subtype();
}
 const ::std::string& Entity::subtype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.subtype)
  return subtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_subtype(const ::std::string& value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.subtype)
}
 void Entity::set_subtype(const char* value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.subtype)
}
 void Entity::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.subtype)
}
 ::std::string* Entity::mutable_subtype() {
  set_has_subtype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.subtype)
  return subtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Entity::release_subtype() {
  clear_has_subtype();
  return subtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Entity::set_allocated_subtype(::std::string* subtype) {
  if (subtype != NULL) {
    set_has_subtype();
  } else {
    clear_has_subtype();
  }
  subtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.subtype)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Relation::kArgNameFieldNumber;
const int Relation::kArgFieldNumber;
const int Relation::kSignatureFieldNumber;
const int Relation::kObjectIDFieldNumber;
const int Relation::kExtentStartFieldNumber;
const int Relation::kExtentEndFieldNumber;
const int Relation::kTypeFieldNumber;
const int Relation::kSubtypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Relation::Relation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Relation)
}

void Relation::InitAsDefaultInstance() {
}

Relation::Relation(const Relation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Relation)
}

void Relation::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  objectid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  extentstart_ = 0u;
  extentend_ = 0u;
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  subtype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Relation::~Relation() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Relation)
  SharedDtor();
}

void Relation::SharedDtor() {
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  objectid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  subtype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Relation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Relation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Relation_descriptor_;
}

const Relation& Relation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Relation* Relation::default_instance_ = NULL;

Relation* Relation::New(::google::protobuf::Arena* arena) const {
  Relation* n = new Relation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Relation::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Relation*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 252u) {
    ZR_(extentstart_, extentend_);
    if (has_signature()) {
      signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_objectid()) {
      objectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_subtype()) {
      subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  argname_.Clear();
  arg_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Relation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Relation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string objectID = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_objectid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->objectid().data(), this->objectid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Relation.objectID");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_extentStart;
        break;
      }

      // optional uint32 extentStart = 2;
      case 2: {
        if (tag == 16) {
         parse_extentStart:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extentstart_)));
          set_has_extentstart();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_extentEnd;
        break;
      }

      // optional uint32 extentEnd = 3;
      case 3: {
        if (tag == 24) {
         parse_extentEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &extentend_)));
          set_has_extentend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_type;
        break;
      }

      // optional string type = 4;
      case 4: {
        if (tag == 34) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Relation.type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_subtype;
        break;
      }

      // optional string subtype = 5;
      case 5: {
        if (tag == 42) {
         parse_subtype:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->subtype().data(), this->subtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Relation.subtype");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_argName;
        break;
      }

      // repeated string argName = 6;
      case 6: {
        if (tag == 50) {
         parse_argName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_argname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->argname(this->argname_size() - 1).data(),
            this->argname(this->argname_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Relation.argName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_argName;
        if (input->ExpectTag(58)) goto parse_arg;
        break;
      }

      // repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
      case 7: {
        if (tag == 58) {
         parse_arg:
          DO_(input->IncrementRecursionDepth());
         parse_loop_arg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_arg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_arg;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(66)) goto parse_signature;
        break;
      }

      // optional string signature = 8;
      case 8: {
        if (tag == 66) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->signature().data(), this->signature().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Relation.signature");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Relation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Relation)
  return false;
#undef DO_
}

void Relation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Relation)
  // optional string objectID = 1;
  if (has_objectid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->objectid().data(), this->objectid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.objectID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->objectid(), output);
  }

  // optional uint32 extentStart = 2;
  if (has_extentstart()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->extentstart(), output);
  }

  // optional uint32 extentEnd = 3;
  if (has_extentend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->extentend(), output);
  }

  // optional string type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->type(), output);
  }

  // optional string subtype = 5;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.subtype");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->subtype(), output);
  }

  // repeated string argName = 6;
  for (int i = 0; i < this->argname_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->argname(i).data(), this->argname(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.argName");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->argname(i), output);
  }

  // repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
  for (unsigned int i = 0, n = this->arg_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->arg(i), output);
  }

  // optional string signature = 8;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->signature().data(), this->signature().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.signature");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Relation)
}

::google::protobuf::uint8* Relation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Relation)
  // optional string objectID = 1;
  if (has_objectid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->objectid().data(), this->objectid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.objectID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->objectid(), target);
  }

  // optional uint32 extentStart = 2;
  if (has_extentstart()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->extentstart(), target);
  }

  // optional uint32 extentEnd = 3;
  if (has_extentend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->extentend(), target);
  }

  // optional string type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->type(), target);
  }

  // optional string subtype = 5;
  if (has_subtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->subtype().data(), this->subtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.subtype");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->subtype(), target);
  }

  // repeated string argName = 6;
  for (int i = 0; i < this->argname_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->argname(i).data(), this->argname(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.argName");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->argname(i), target);
  }

  // repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
  for (unsigned int i = 0, n = this->arg_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->arg(i), target);
  }

  // optional string signature = 8;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->signature().data(), this->signature().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Relation.signature");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Relation)
  return target;
}

int Relation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & 252u) {
    // optional string signature = 8;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

    // optional string objectID = 1;
    if (has_objectid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->objectid());
    }

    // optional uint32 extentStart = 2;
    if (has_extentstart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extentstart());
    }

    // optional uint32 extentEnd = 3;
    if (has_extentend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->extentend());
    }

    // optional string type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional string subtype = 5;
    if (has_subtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subtype());
    }

  }
  // repeated string argName = 6;
  total_size += 1 * this->argname_size();
  for (int i = 0; i < this->argname_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->argname(i));
  }

  // repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
  total_size += 1 * this->arg_size();
  for (int i = 0; i < this->arg_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->arg(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Relation::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Relation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Relation>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Relation::MergeFrom(const Relation& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  argname_.MergeFrom(from.argname_);
  arg_.MergeFrom(from.arg_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_signature()) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (from.has_objectid()) {
      set_has_objectid();
      objectid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.objectid_);
    }
    if (from.has_extentstart()) {
      set_extentstart(from.extentstart());
    }
    if (from.has_extentend()) {
      set_extentend(from.extentend());
    }
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
    if (from.has_subtype()) {
      set_has_subtype();
      subtype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.subtype_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Relation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Relation::CopyFrom(const Relation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Relation::IsInitialized() const {

  return true;
}

void Relation::Swap(Relation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Relation::InternalSwap(Relation* other) {
  argname_.UnsafeArenaSwap(&other->argname_);
  arg_.UnsafeArenaSwap(&other->arg_);
  signature_.Swap(&other->signature_);
  objectid_.Swap(&other->objectid_);
  std::swap(extentstart_, other->extentstart_);
  std::swap(extentend_, other->extentend_);
  type_.Swap(&other->type_);
  subtype_.Swap(&other->subtype_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Relation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Relation_descriptor_;
  metadata.reflection = Relation_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Relation

// repeated string argName = 6;
int Relation::argname_size() const {
  return argname_.size();
}
void Relation::clear_argname() {
  argname_.Clear();
}
 const ::std::string& Relation::argname(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.argName)
  return argname_.Get(index);
}
 ::std::string* Relation::mutable_argname(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.argName)
  return argname_.Mutable(index);
}
 void Relation::set_argname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.argName)
  argname_.Mutable(index)->assign(value);
}
 void Relation::set_argname(int index, const char* value) {
  argname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.argName)
}
 void Relation::set_argname(int index, const char* value, size_t size) {
  argname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.argName)
}
 ::std::string* Relation::add_argname() {
  return argname_.Add();
}
 void Relation::add_argname(const ::std::string& value) {
  argname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Relation.argName)
}
 void Relation::add_argname(const char* value) {
  argname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Relation.argName)
}
 void Relation::add_argname(const char* value, size_t size) {
  argname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Relation.argName)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Relation::argname() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Relation.argName)
  return argname_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Relation::mutable_argname() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Relation.argName)
  return &argname_;
}

// repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
int Relation::arg_size() const {
  return arg_.size();
}
void Relation::clear_arg() {
  arg_.Clear();
}
const ::edu::stanford::nlp::pipeline::Entity& Relation::arg(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_.Get(index);
}
::edu::stanford::nlp::pipeline::Entity* Relation::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_.Mutable(index);
}
::edu::stanford::nlp::pipeline::Entity* Relation::add_arg() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_.Add();
}
::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >*
Relation::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Relation.arg)
  return &arg_;
}
const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >&
Relation::arg() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_;
}

// optional string signature = 8;
bool Relation::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Relation::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
void Relation::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
void Relation::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
 const ::std::string& Relation::signature() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.signature)
}
 void Relation::set_signature(const char* value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.signature)
}
 void Relation::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.signature)
}
 ::std::string* Relation::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Relation::release_signature() {
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.signature)
}

// optional string objectID = 1;
bool Relation::has_objectid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Relation::set_has_objectid() {
  _has_bits_[0] |= 0x00000008u;
}
void Relation::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000008u;
}
void Relation::clear_objectid() {
  objectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_objectid();
}
 const ::std::string& Relation::objectid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.objectID)
  return objectid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_objectid(const ::std::string& value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.objectID)
}
 void Relation::set_objectid(const char* value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.objectID)
}
 void Relation::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.objectID)
}
 ::std::string* Relation::mutable_objectid() {
  set_has_objectid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.objectID)
  return objectid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Relation::release_objectid() {
  clear_has_objectid();
  return objectid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_allocated_objectid(::std::string* objectid) {
  if (objectid != NULL) {
    set_has_objectid();
  } else {
    clear_has_objectid();
  }
  objectid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), objectid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.objectID)
}

// optional uint32 extentStart = 2;
bool Relation::has_extentstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Relation::set_has_extentstart() {
  _has_bits_[0] |= 0x00000010u;
}
void Relation::clear_has_extentstart() {
  _has_bits_[0] &= ~0x00000010u;
}
void Relation::clear_extentstart() {
  extentstart_ = 0u;
  clear_has_extentstart();
}
 ::google::protobuf::uint32 Relation::extentstart() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.extentStart)
  return extentstart_;
}
 void Relation::set_extentstart(::google::protobuf::uint32 value) {
  set_has_extentstart();
  extentstart_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.extentStart)
}

// optional uint32 extentEnd = 3;
bool Relation::has_extentend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Relation::set_has_extentend() {
  _has_bits_[0] |= 0x00000020u;
}
void Relation::clear_has_extentend() {
  _has_bits_[0] &= ~0x00000020u;
}
void Relation::clear_extentend() {
  extentend_ = 0u;
  clear_has_extentend();
}
 ::google::protobuf::uint32 Relation::extentend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.extentEnd)
  return extentend_;
}
 void Relation::set_extentend(::google::protobuf::uint32 value) {
  set_has_extentend();
  extentend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.extentEnd)
}

// optional string type = 4;
bool Relation::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Relation::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
void Relation::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
void Relation::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& Relation::type() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.type)
}
 void Relation::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.type)
}
 void Relation::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.type)
}
 ::std::string* Relation::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Relation::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.type)
}

// optional string subtype = 5;
bool Relation::has_subtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Relation::set_has_subtype() {
  _has_bits_[0] |= 0x00000080u;
}
void Relation::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000080u;
}
void Relation::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subtype();
}
 const ::std::string& Relation::subtype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.subtype)
  return subtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_subtype(const ::std::string& value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.subtype)
}
 void Relation::set_subtype(const char* value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.subtype)
}
 void Relation::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.subtype)
}
 ::std::string* Relation::mutable_subtype() {
  set_has_subtype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.subtype)
  return subtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Relation::release_subtype() {
  clear_has_subtype();
  return subtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Relation::set_allocated_subtype(::std::string* subtype) {
  if (subtype != NULL) {
    set_has_subtype();
  } else {
    clear_has_subtype();
  }
  subtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.subtype)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Operator::kNameFieldNumber;
const int Operator::kQuantifierSpanBeginFieldNumber;
const int Operator::kQuantifierSpanEndFieldNumber;
const int Operator::kSubjectSpanBeginFieldNumber;
const int Operator::kSubjectSpanEndFieldNumber;
const int Operator::kObjectSpanBeginFieldNumber;
const int Operator::kObjectSpanEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Operator::Operator()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Operator)
}

void Operator::InitAsDefaultInstance() {
}

Operator::Operator(const Operator& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Operator)
}

void Operator::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quantifierspanbegin_ = 0;
  quantifierspanend_ = 0;
  subjectspanbegin_ = 0;
  subjectspanend_ = 0;
  objectspanbegin_ = 0;
  objectspanend_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Operator::~Operator() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Operator)
  SharedDtor();
}

void Operator::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Operator::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Operator::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Operator_descriptor_;
}

const Operator& Operator::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Operator* Operator::default_instance_ = NULL;

Operator* Operator::New(::google::protobuf::Arena* arena) const {
  Operator* n = new Operator;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Operator::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Operator*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(quantifierspanbegin_, objectspanend_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Operator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Operator)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.Operator.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_quantifierSpanBegin;
        break;
      }

      // required int32 quantifierSpanBegin = 2;
      case 2: {
        if (tag == 16) {
         parse_quantifierSpanBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quantifierspanbegin_)));
          set_has_quantifierspanbegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_quantifierSpanEnd;
        break;
      }

      // required int32 quantifierSpanEnd = 3;
      case 3: {
        if (tag == 24) {
         parse_quantifierSpanEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quantifierspanend_)));
          set_has_quantifierspanend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_subjectSpanBegin;
        break;
      }

      // required int32 subjectSpanBegin = 4;
      case 4: {
        if (tag == 32) {
         parse_subjectSpanBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &subjectspanbegin_)));
          set_has_subjectspanbegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_subjectSpanEnd;
        break;
      }

      // required int32 subjectSpanEnd = 5;
      case 5: {
        if (tag == 40) {
         parse_subjectSpanEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &subjectspanend_)));
          set_has_subjectspanend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_objectSpanBegin;
        break;
      }

      // required int32 objectSpanBegin = 6;
      case 6: {
        if (tag == 48) {
         parse_objectSpanBegin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &objectspanbegin_)));
          set_has_objectspanbegin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_objectSpanEnd;
        break;
      }

      // required int32 objectSpanEnd = 7;
      case 7: {
        if (tag == 56) {
         parse_objectSpanEnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &objectspanend_)));
          set_has_objectspanend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Operator)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Operator)
  return false;
#undef DO_
}

void Operator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Operator)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Operator.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required int32 quantifierSpanBegin = 2;
  if (has_quantifierspanbegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->quantifierspanbegin(), output);
  }

  // required int32 quantifierSpanEnd = 3;
  if (has_quantifierspanend()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->quantifierspanend(), output);
  }

  // required int32 subjectSpanBegin = 4;
  if (has_subjectspanbegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->subjectspanbegin(), output);
  }

  // required int32 subjectSpanEnd = 5;
  if (has_subjectspanend()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->subjectspanend(), output);
  }

  // required int32 objectSpanBegin = 6;
  if (has_objectspanbegin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->objectspanbegin(), output);
  }

  // required int32 objectSpanEnd = 7;
  if (has_objectspanend()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->objectspanend(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Operator)
}

::google::protobuf::uint8* Operator::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Operator)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.Operator.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required int32 quantifierSpanBegin = 2;
  if (has_quantifierspanbegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->quantifierspanbegin(), target);
  }

  // required int32 quantifierSpanEnd = 3;
  if (has_quantifierspanend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->quantifierspanend(), target);
  }

  // required int32 subjectSpanBegin = 4;
  if (has_subjectspanbegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->subjectspanbegin(), target);
  }

  // required int32 subjectSpanEnd = 5;
  if (has_subjectspanend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->subjectspanend(), target);
  }

  // required int32 objectSpanBegin = 6;
  if (has_objectspanbegin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->objectspanbegin(), target);
  }

  // required int32 objectSpanEnd = 7;
  if (has_objectspanend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->objectspanend(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Operator)
  return target;
}

int Operator::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_quantifierspanbegin()) {
    // required int32 quantifierSpanBegin = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->quantifierspanbegin());
  }

  if (has_quantifierspanend()) {
    // required int32 quantifierSpanEnd = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->quantifierspanend());
  }

  if (has_subjectspanbegin()) {
    // required int32 subjectSpanBegin = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->subjectspanbegin());
  }

  if (has_subjectspanend()) {
    // required int32 subjectSpanEnd = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->subjectspanend());
  }

  if (has_objectspanbegin()) {
    // required int32 objectSpanBegin = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->objectspanbegin());
  }

  if (has_objectspanend()) {
    // required int32 objectSpanEnd = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->objectspanend());
  }

  return total_size;
}
int Operator::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required int32 quantifierSpanBegin = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->quantifierspanbegin());

    // required int32 quantifierSpanEnd = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->quantifierspanend());

    // required int32 subjectSpanBegin = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->subjectspanbegin());

    // required int32 subjectSpanEnd = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->subjectspanend());

    // required int32 objectSpanBegin = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->objectspanbegin());

    // required int32 objectSpanEnd = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->objectspanend());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Operator::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Operator* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Operator>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Operator::MergeFrom(const Operator& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_quantifierspanbegin()) {
      set_quantifierspanbegin(from.quantifierspanbegin());
    }
    if (from.has_quantifierspanend()) {
      set_quantifierspanend(from.quantifierspanend());
    }
    if (from.has_subjectspanbegin()) {
      set_subjectspanbegin(from.subjectspanbegin());
    }
    if (from.has_subjectspanend()) {
      set_subjectspanend(from.subjectspanend());
    }
    if (from.has_objectspanbegin()) {
      set_objectspanbegin(from.objectspanbegin());
    }
    if (from.has_objectspanend()) {
      set_objectspanend(from.objectspanend());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Operator::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Operator::CopyFrom(const Operator& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operator::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void Operator::Swap(Operator* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Operator::InternalSwap(Operator* other) {
  name_.Swap(&other->name_);
  std::swap(quantifierspanbegin_, other->quantifierspanbegin_);
  std::swap(quantifierspanend_, other->quantifierspanend_);
  std::swap(subjectspanbegin_, other->subjectspanbegin_);
  std::swap(subjectspanend_, other->subjectspanend_);
  std::swap(objectspanbegin_, other->objectspanbegin_);
  std::swap(objectspanend_, other->objectspanend_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Operator::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Operator_descriptor_;
  metadata.reflection = Operator_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Operator

// required string name = 1;
bool Operator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Operator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Operator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Operator::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Operator::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.name)
}
 void Operator::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Operator.name)
}
 void Operator::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Operator.name)
}
 ::std::string* Operator::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Operator.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Operator::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Operator::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Operator.name)
}

// required int32 quantifierSpanBegin = 2;
bool Operator::has_quantifierspanbegin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Operator::set_has_quantifierspanbegin() {
  _has_bits_[0] |= 0x00000002u;
}
void Operator::clear_has_quantifierspanbegin() {
  _has_bits_[0] &= ~0x00000002u;
}
void Operator::clear_quantifierspanbegin() {
  quantifierspanbegin_ = 0;
  clear_has_quantifierspanbegin();
}
 ::google::protobuf::int32 Operator::quantifierspanbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.quantifierSpanBegin)
  return quantifierspanbegin_;
}
 void Operator::set_quantifierspanbegin(::google::protobuf::int32 value) {
  set_has_quantifierspanbegin();
  quantifierspanbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.quantifierSpanBegin)
}

// required int32 quantifierSpanEnd = 3;
bool Operator::has_quantifierspanend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Operator::set_has_quantifierspanend() {
  _has_bits_[0] |= 0x00000004u;
}
void Operator::clear_has_quantifierspanend() {
  _has_bits_[0] &= ~0x00000004u;
}
void Operator::clear_quantifierspanend() {
  quantifierspanend_ = 0;
  clear_has_quantifierspanend();
}
 ::google::protobuf::int32 Operator::quantifierspanend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.quantifierSpanEnd)
  return quantifierspanend_;
}
 void Operator::set_quantifierspanend(::google::protobuf::int32 value) {
  set_has_quantifierspanend();
  quantifierspanend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.quantifierSpanEnd)
}

// required int32 subjectSpanBegin = 4;
bool Operator::has_subjectspanbegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Operator::set_has_subjectspanbegin() {
  _has_bits_[0] |= 0x00000008u;
}
void Operator::clear_has_subjectspanbegin() {
  _has_bits_[0] &= ~0x00000008u;
}
void Operator::clear_subjectspanbegin() {
  subjectspanbegin_ = 0;
  clear_has_subjectspanbegin();
}
 ::google::protobuf::int32 Operator::subjectspanbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.subjectSpanBegin)
  return subjectspanbegin_;
}
 void Operator::set_subjectspanbegin(::google::protobuf::int32 value) {
  set_has_subjectspanbegin();
  subjectspanbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.subjectSpanBegin)
}

// required int32 subjectSpanEnd = 5;
bool Operator::has_subjectspanend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Operator::set_has_subjectspanend() {
  _has_bits_[0] |= 0x00000010u;
}
void Operator::clear_has_subjectspanend() {
  _has_bits_[0] &= ~0x00000010u;
}
void Operator::clear_subjectspanend() {
  subjectspanend_ = 0;
  clear_has_subjectspanend();
}
 ::google::protobuf::int32 Operator::subjectspanend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.subjectSpanEnd)
  return subjectspanend_;
}
 void Operator::set_subjectspanend(::google::protobuf::int32 value) {
  set_has_subjectspanend();
  subjectspanend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.subjectSpanEnd)
}

// required int32 objectSpanBegin = 6;
bool Operator::has_objectspanbegin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Operator::set_has_objectspanbegin() {
  _has_bits_[0] |= 0x00000020u;
}
void Operator::clear_has_objectspanbegin() {
  _has_bits_[0] &= ~0x00000020u;
}
void Operator::clear_objectspanbegin() {
  objectspanbegin_ = 0;
  clear_has_objectspanbegin();
}
 ::google::protobuf::int32 Operator::objectspanbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.objectSpanBegin)
  return objectspanbegin_;
}
 void Operator::set_objectspanbegin(::google::protobuf::int32 value) {
  set_has_objectspanbegin();
  objectspanbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.objectSpanBegin)
}

// required int32 objectSpanEnd = 7;
bool Operator::has_objectspanend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Operator::set_has_objectspanend() {
  _has_bits_[0] |= 0x00000040u;
}
void Operator::clear_has_objectspanend() {
  _has_bits_[0] &= ~0x00000040u;
}
void Operator::clear_objectspanend() {
  objectspanend_ = 0;
  clear_has_objectspanend();
}
 ::google::protobuf::int32 Operator::objectspanend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.objectSpanEnd)
  return objectspanend_;
}
 void Operator::set_objectspanend(::google::protobuf::int32 value) {
  set_has_objectspanend();
  objectspanend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.objectSpanEnd)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Polarity::kProjectEquivalenceFieldNumber;
const int Polarity::kProjectForwardEntailmentFieldNumber;
const int Polarity::kProjectReverseEntailmentFieldNumber;
const int Polarity::kProjectNegationFieldNumber;
const int Polarity::kProjectAlternationFieldNumber;
const int Polarity::kProjectCoverFieldNumber;
const int Polarity::kProjectIndependenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Polarity::Polarity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.Polarity)
}

void Polarity::InitAsDefaultInstance() {
}

Polarity::Polarity(const Polarity& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.Polarity)
}

void Polarity::SharedCtor() {
  _cached_size_ = 0;
  projectequivalence_ = 0;
  projectforwardentailment_ = 0;
  projectreverseentailment_ = 0;
  projectnegation_ = 0;
  projectalternation_ = 0;
  projectcover_ = 0;
  projectindependence_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polarity::~Polarity() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.Polarity)
  SharedDtor();
}

void Polarity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Polarity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Polarity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Polarity_descriptor_;
}

const Polarity& Polarity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

Polarity* Polarity::default_instance_ = NULL;

Polarity* Polarity::New(::google::protobuf::Arena* arena) const {
  Polarity* n = new Polarity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Polarity::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Polarity*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(projectequivalence_, projectindependence_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Polarity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.Polarity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectequivalence(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_projectForwardEntailment;
        break;
      }

      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
      case 2: {
        if (tag == 16) {
         parse_projectForwardEntailment:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectforwardentailment(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_projectReverseEntailment;
        break;
      }

      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
      case 3: {
        if (tag == 24) {
         parse_projectReverseEntailment:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectreverseentailment(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_projectNegation;
        break;
      }

      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
      case 4: {
        if (tag == 32) {
         parse_projectNegation:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectnegation(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_projectAlternation;
        break;
      }

      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
      case 5: {
        if (tag == 40) {
         parse_projectAlternation:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectalternation(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_projectCover;
        break;
      }

      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
      case 6: {
        if (tag == 48) {
         parse_projectCover:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectcover(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_projectIndependence;
        break;
      }

      // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
      case 7: {
        if (tag == 56) {
         parse_projectIndependence:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value)) {
            set_projectindependence(static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.Polarity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.Polarity)
  return false;
#undef DO_
}

void Polarity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.Polarity)
  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
  if (has_projectequivalence()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->projectequivalence(), output);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
  if (has_projectforwardentailment()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->projectforwardentailment(), output);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
  if (has_projectreverseentailment()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->projectreverseentailment(), output);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
  if (has_projectnegation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->projectnegation(), output);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
  if (has_projectalternation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->projectalternation(), output);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
  if (has_projectcover()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->projectcover(), output);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
  if (has_projectindependence()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->projectindependence(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.Polarity)
}

::google::protobuf::uint8* Polarity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.Polarity)
  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
  if (has_projectequivalence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->projectequivalence(), target);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
  if (has_projectforwardentailment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->projectforwardentailment(), target);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
  if (has_projectreverseentailment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->projectreverseentailment(), target);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
  if (has_projectnegation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->projectnegation(), target);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
  if (has_projectalternation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->projectalternation(), target);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
  if (has_projectcover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->projectcover(), target);
  }

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
  if (has_projectindependence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->projectindependence(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.Polarity)
  return target;
}

int Polarity::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_projectequivalence()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectequivalence());
  }

  if (has_projectforwardentailment()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectforwardentailment());
  }

  if (has_projectreverseentailment()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectreverseentailment());
  }

  if (has_projectnegation()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectnegation());
  }

  if (has_projectalternation()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectalternation());
  }

  if (has_projectcover()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectcover());
  }

  if (has_projectindependence()) {
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectindependence());
  }

  return total_size;
}
int Polarity::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectequivalence());

    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectforwardentailment());

    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectreverseentailment());

    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectnegation());

    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectalternation());

    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectcover());

    // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->projectindependence());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polarity::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Polarity* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Polarity>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Polarity::MergeFrom(const Polarity& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_projectequivalence()) {
      set_projectequivalence(from.projectequivalence());
    }
    if (from.has_projectforwardentailment()) {
      set_projectforwardentailment(from.projectforwardentailment());
    }
    if (from.has_projectreverseentailment()) {
      set_projectreverseentailment(from.projectreverseentailment());
    }
    if (from.has_projectnegation()) {
      set_projectnegation(from.projectnegation());
    }
    if (from.has_projectalternation()) {
      set_projectalternation(from.projectalternation());
    }
    if (from.has_projectcover()) {
      set_projectcover(from.projectcover());
    }
    if (from.has_projectindependence()) {
      set_projectindependence(from.projectindependence());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Polarity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polarity::CopyFrom(const Polarity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polarity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void Polarity::Swap(Polarity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Polarity::InternalSwap(Polarity* other) {
  std::swap(projectequivalence_, other->projectequivalence_);
  std::swap(projectforwardentailment_, other->projectforwardentailment_);
  std::swap(projectreverseentailment_, other->projectreverseentailment_);
  std::swap(projectnegation_, other->projectnegation_);
  std::swap(projectalternation_, other->projectalternation_);
  std::swap(projectcover_, other->projectcover_);
  std::swap(projectindependence_, other->projectindependence_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Polarity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Polarity_descriptor_;
  metadata.reflection = Polarity_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Polarity

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
bool Polarity::has_projectequivalence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Polarity::set_has_projectequivalence() {
  _has_bits_[0] |= 0x00000001u;
}
void Polarity::clear_has_projectequivalence() {
  _has_bits_[0] &= ~0x00000001u;
}
void Polarity::clear_projectequivalence() {
  projectequivalence_ = 0;
  clear_has_projectequivalence();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectequivalence() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectEquivalence)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectequivalence_);
}
 void Polarity::set_projectequivalence(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectequivalence();
  projectequivalence_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectEquivalence)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
bool Polarity::has_projectforwardentailment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Polarity::set_has_projectforwardentailment() {
  _has_bits_[0] |= 0x00000002u;
}
void Polarity::clear_has_projectforwardentailment() {
  _has_bits_[0] &= ~0x00000002u;
}
void Polarity::clear_projectforwardentailment() {
  projectforwardentailment_ = 0;
  clear_has_projectforwardentailment();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectforwardentailment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectForwardEntailment)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectforwardentailment_);
}
 void Polarity::set_projectforwardentailment(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectforwardentailment();
  projectforwardentailment_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectForwardEntailment)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
bool Polarity::has_projectreverseentailment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Polarity::set_has_projectreverseentailment() {
  _has_bits_[0] |= 0x00000004u;
}
void Polarity::clear_has_projectreverseentailment() {
  _has_bits_[0] &= ~0x00000004u;
}
void Polarity::clear_projectreverseentailment() {
  projectreverseentailment_ = 0;
  clear_has_projectreverseentailment();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectreverseentailment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectReverseEntailment)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectreverseentailment_);
}
 void Polarity::set_projectreverseentailment(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectreverseentailment();
  projectreverseentailment_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectReverseEntailment)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
bool Polarity::has_projectnegation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Polarity::set_has_projectnegation() {
  _has_bits_[0] |= 0x00000008u;
}
void Polarity::clear_has_projectnegation() {
  _has_bits_[0] &= ~0x00000008u;
}
void Polarity::clear_projectnegation() {
  projectnegation_ = 0;
  clear_has_projectnegation();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectnegation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectNegation)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectnegation_);
}
 void Polarity::set_projectnegation(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectnegation();
  projectnegation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectNegation)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
bool Polarity::has_projectalternation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Polarity::set_has_projectalternation() {
  _has_bits_[0] |= 0x00000010u;
}
void Polarity::clear_has_projectalternation() {
  _has_bits_[0] &= ~0x00000010u;
}
void Polarity::clear_projectalternation() {
  projectalternation_ = 0;
  clear_has_projectalternation();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectalternation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectAlternation)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectalternation_);
}
 void Polarity::set_projectalternation(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectalternation();
  projectalternation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectAlternation)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
bool Polarity::has_projectcover() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Polarity::set_has_projectcover() {
  _has_bits_[0] |= 0x00000020u;
}
void Polarity::clear_has_projectcover() {
  _has_bits_[0] &= ~0x00000020u;
}
void Polarity::clear_projectcover() {
  projectcover_ = 0;
  clear_has_projectcover();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectcover() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectCover)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectcover_);
}
 void Polarity::set_projectcover(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectcover();
  projectcover_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectCover)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
bool Polarity::has_projectindependence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Polarity::set_has_projectindependence() {
  _has_bits_[0] |= 0x00000040u;
}
void Polarity::clear_has_projectindependence() {
  _has_bits_[0] &= ~0x00000040u;
}
void Polarity::clear_projectindependence() {
  projectindependence_ = 0;
  clear_has_projectindependence();
}
 ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectindependence() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectIndependence)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectindependence_);
}
 void Polarity::set_projectindependence(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectindependence();
  projectindependence_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectIndependence)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NERMention::kSentenceIndexFieldNumber;
const int NERMention::kTokenStartInSentenceInclusiveFieldNumber;
const int NERMention::kTokenEndInSentenceExclusiveFieldNumber;
const int NERMention::kNerFieldNumber;
const int NERMention::kNormalizedNERFieldNumber;
const int NERMention::kEntityTypeFieldNumber;
const int NERMention::kTimexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NERMention::NERMention()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.NERMention)
}

void NERMention::InitAsDefaultInstance() {
  timex_ = const_cast< ::edu::stanford::nlp::pipeline::Timex*>(&::edu::stanford::nlp::pipeline::Timex::default_instance());
}

NERMention::NERMention(const NERMention& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.NERMention)
}

void NERMention::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sentenceindex_ = 0u;
  tokenstartinsentenceinclusive_ = 0u;
  tokenendinsentenceexclusive_ = 0u;
  ner_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  normalizedner_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  entitytype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timex_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NERMention::~NERMention() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.NERMention)
  SharedDtor();
}

void NERMention::SharedDtor() {
  ner_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  normalizedner_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  entitytype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete timex_;
  }
}

void NERMention::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NERMention::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NERMention_descriptor_;
}

const NERMention& NERMention::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

NERMention* NERMention::default_instance_ = NULL;

NERMention* NERMention::New(::google::protobuf::Arena* arena) const {
  NERMention* n = new NERMention;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NERMention::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<NERMention*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(sentenceindex_, tokenstartinsentenceinclusive_);
    tokenendinsentenceexclusive_ = 0u;
    if (has_ner()) {
      ner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_normalizedner()) {
      normalizedner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_entitytype()) {
      entitytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_timex()) {
      if (timex_ != NULL) timex_->::edu::stanford::nlp::pipeline::Timex::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NERMention::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.NERMention)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sentenceIndex = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sentenceindex_)));
          set_has_sentenceindex();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_tokenStartInSentenceInclusive;
        break;
      }

      // required uint32 tokenStartInSentenceInclusive = 2;
      case 2: {
        if (tag == 16) {
         parse_tokenStartInSentenceInclusive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenstartinsentenceinclusive_)));
          set_has_tokenstartinsentenceinclusive();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_tokenEndInSentenceExclusive;
        break;
      }

      // required uint32 tokenEndInSentenceExclusive = 3;
      case 3: {
        if (tag == 24) {
         parse_tokenEndInSentenceExclusive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tokenendinsentenceexclusive_)));
          set_has_tokenendinsentenceexclusive();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ner;
        break;
      }

      // required string ner = 4;
      case 4: {
        if (tag == 34) {
         parse_ner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ner().data(), this->ner().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.NERMention.ner");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_normalizedNER;
        break;
      }

      // optional string normalizedNER = 5;
      case 5: {
        if (tag == 42) {
         parse_normalizedNER:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_normalizedner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->normalizedner().data(), this->normalizedner().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.NERMention.normalizedNER");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_entityType;
        break;
      }

      // optional string entityType = 6;
      case 6: {
        if (tag == 50) {
         parse_entityType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_entitytype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->entitytype().data(), this->entitytype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.NERMention.entityType");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_timex;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.Timex timex = 7;
      case 7: {
        if (tag == 58) {
         parse_timex:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timex()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.NERMention)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.NERMention)
  return false;
#undef DO_
}

void NERMention::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.NERMention)
  // optional uint32 sentenceIndex = 1;
  if (has_sentenceindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sentenceindex(), output);
  }

  // required uint32 tokenStartInSentenceInclusive = 2;
  if (has_tokenstartinsentenceinclusive()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tokenstartinsentenceinclusive(), output);
  }

  // required uint32 tokenEndInSentenceExclusive = 3;
  if (has_tokenendinsentenceexclusive()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->tokenendinsentenceexclusive(), output);
  }

  // required string ner = 4;
  if (has_ner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ner().data(), this->ner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.NERMention.ner");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->ner(), output);
  }

  // optional string normalizedNER = 5;
  if (has_normalizedner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->normalizedner().data(), this->normalizedner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.NERMention.normalizedNER");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->normalizedner(), output);
  }

  // optional string entityType = 6;
  if (has_entitytype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->entitytype().data(), this->entitytype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.NERMention.entityType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->entitytype(), output);
  }

  // optional .edu.stanford.nlp.pipeline.Timex timex = 7;
  if (has_timex()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->timex_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.NERMention)
}

::google::protobuf::uint8* NERMention::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.NERMention)
  // optional uint32 sentenceIndex = 1;
  if (has_sentenceindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sentenceindex(), target);
  }

  // required uint32 tokenStartInSentenceInclusive = 2;
  if (has_tokenstartinsentenceinclusive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->tokenstartinsentenceinclusive(), target);
  }

  // required uint32 tokenEndInSentenceExclusive = 3;
  if (has_tokenendinsentenceexclusive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->tokenendinsentenceexclusive(), target);
  }

  // required string ner = 4;
  if (has_ner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ner().data(), this->ner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.NERMention.ner");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->ner(), target);
  }

  // optional string normalizedNER = 5;
  if (has_normalizedner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->normalizedner().data(), this->normalizedner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.NERMention.normalizedNER");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->normalizedner(), target);
  }

  // optional string entityType = 6;
  if (has_entitytype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->entitytype().data(), this->entitytype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.NERMention.entityType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->entitytype(), target);
  }

  // optional .edu.stanford.nlp.pipeline.Timex timex = 7;
  if (has_timex()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->timex_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.NERMention)
  return target;
}

int NERMention::RequiredFieldsByteSizeFallback() const {
  int total_size = 0;

  if (has_tokenstartinsentenceinclusive()) {
    // required uint32 tokenStartInSentenceInclusive = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenstartinsentenceinclusive());
  }

  if (has_tokenendinsentenceexclusive()) {
    // required uint32 tokenEndInSentenceExclusive = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenendinsentenceexclusive());
  }

  if (has_ner()) {
    // required string ner = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ner());
  }

  return total_size;
}
int NERMention::ByteSize() const {
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required uint32 tokenStartInSentenceInclusive = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenstartinsentenceinclusive());

    // required uint32 tokenEndInSentenceExclusive = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tokenendinsentenceexclusive());

    // required string ner = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ner());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 113u) {
    // optional uint32 sentenceIndex = 1;
    if (has_sentenceindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sentenceindex());
    }

    // optional string normalizedNER = 5;
    if (has_normalizedner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->normalizedner());
    }

    // optional string entityType = 6;
    if (has_entitytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->entitytype());
    }

    // optional .edu.stanford.nlp.pipeline.Timex timex = 7;
    if (has_timex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timex_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NERMention::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NERMention* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NERMention>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NERMention::MergeFrom(const NERMention& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sentenceindex()) {
      set_sentenceindex(from.sentenceindex());
    }
    if (from.has_tokenstartinsentenceinclusive()) {
      set_tokenstartinsentenceinclusive(from.tokenstartinsentenceinclusive());
    }
    if (from.has_tokenendinsentenceexclusive()) {
      set_tokenendinsentenceexclusive(from.tokenendinsentenceexclusive());
    }
    if (from.has_ner()) {
      set_has_ner();
      ner_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ner_);
    }
    if (from.has_normalizedner()) {
      set_has_normalizedner();
      normalizedner_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.normalizedner_);
    }
    if (from.has_entitytype()) {
      set_has_entitytype();
      entitytype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entitytype_);
    }
    if (from.has_timex()) {
      mutable_timex()->::edu::stanford::nlp::pipeline::Timex::MergeFrom(from.timex());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NERMention::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NERMention::CopyFrom(const NERMention& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NERMention::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  return true;
}

void NERMention::Swap(NERMention* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NERMention::InternalSwap(NERMention* other) {
  std::swap(sentenceindex_, other->sentenceindex_);
  std::swap(tokenstartinsentenceinclusive_, other->tokenstartinsentenceinclusive_);
  std::swap(tokenendinsentenceexclusive_, other->tokenendinsentenceexclusive_);
  ner_.Swap(&other->ner_);
  normalizedner_.Swap(&other->normalizedner_);
  entitytype_.Swap(&other->entitytype_);
  std::swap(timex_, other->timex_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NERMention::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NERMention_descriptor_;
  metadata.reflection = NERMention_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NERMention

// optional uint32 sentenceIndex = 1;
bool NERMention::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NERMention::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000001u;
}
void NERMention::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000001u;
}
void NERMention::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
 ::google::protobuf::uint32 NERMention::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.sentenceIndex)
  return sentenceindex_;
}
 void NERMention::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.sentenceIndex)
}

// required uint32 tokenStartInSentenceInclusive = 2;
bool NERMention::has_tokenstartinsentenceinclusive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NERMention::set_has_tokenstartinsentenceinclusive() {
  _has_bits_[0] |= 0x00000002u;
}
void NERMention::clear_has_tokenstartinsentenceinclusive() {
  _has_bits_[0] &= ~0x00000002u;
}
void NERMention::clear_tokenstartinsentenceinclusive() {
  tokenstartinsentenceinclusive_ = 0u;
  clear_has_tokenstartinsentenceinclusive();
}
 ::google::protobuf::uint32 NERMention::tokenstartinsentenceinclusive() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.tokenStartInSentenceInclusive)
  return tokenstartinsentenceinclusive_;
}
 void NERMention::set_tokenstartinsentenceinclusive(::google::protobuf::uint32 value) {
  set_has_tokenstartinsentenceinclusive();
  tokenstartinsentenceinclusive_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.tokenStartInSentenceInclusive)
}

// required uint32 tokenEndInSentenceExclusive = 3;
bool NERMention::has_tokenendinsentenceexclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void NERMention::set_has_tokenendinsentenceexclusive() {
  _has_bits_[0] |= 0x00000004u;
}
void NERMention::clear_has_tokenendinsentenceexclusive() {
  _has_bits_[0] &= ~0x00000004u;
}
void NERMention::clear_tokenendinsentenceexclusive() {
  tokenendinsentenceexclusive_ = 0u;
  clear_has_tokenendinsentenceexclusive();
}
 ::google::protobuf::uint32 NERMention::tokenendinsentenceexclusive() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.tokenEndInSentenceExclusive)
  return tokenendinsentenceexclusive_;
}
 void NERMention::set_tokenendinsentenceexclusive(::google::protobuf::uint32 value) {
  set_has_tokenendinsentenceexclusive();
  tokenendinsentenceexclusive_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.tokenEndInSentenceExclusive)
}

// required string ner = 4;
bool NERMention::has_ner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void NERMention::set_has_ner() {
  _has_bits_[0] |= 0x00000008u;
}
void NERMention::clear_has_ner() {
  _has_bits_[0] &= ~0x00000008u;
}
void NERMention::clear_ner() {
  ner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ner();
}
 const ::std::string& NERMention::ner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.ner)
  return ner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NERMention::set_ner(const ::std::string& value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.ner)
}
 void NERMention::set_ner(const char* value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.NERMention.ner)
}
 void NERMention::set_ner(const char* value, size_t size) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.NERMention.ner)
}
 ::std::string* NERMention::mutable_ner() {
  set_has_ner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.ner)
  return ner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NERMention::release_ner() {
  clear_has_ner();
  return ner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NERMention::set_allocated_ner(::std::string* ner) {
  if (ner != NULL) {
    set_has_ner();
  } else {
    clear_has_ner();
  }
  ner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.ner)
}

// optional string normalizedNER = 5;
bool NERMention::has_normalizedner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void NERMention::set_has_normalizedner() {
  _has_bits_[0] |= 0x00000010u;
}
void NERMention::clear_has_normalizedner() {
  _has_bits_[0] &= ~0x00000010u;
}
void NERMention::clear_normalizedner() {
  normalizedner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_normalizedner();
}
 const ::std::string& NERMention::normalizedner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
  return normalizedner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NERMention::set_normalizedner(const ::std::string& value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}
 void NERMention::set_normalizedner(const char* value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}
 void NERMention::set_normalizedner(const char* value, size_t size) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}
 ::std::string* NERMention::mutable_normalizedner() {
  set_has_normalizedner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
  return normalizedner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NERMention::release_normalizedner() {
  clear_has_normalizedner();
  return normalizedner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NERMention::set_allocated_normalizedner(::std::string* normalizedner) {
  if (normalizedner != NULL) {
    set_has_normalizedner();
  } else {
    clear_has_normalizedner();
  }
  normalizedner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normalizedner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}

// optional string entityType = 6;
bool NERMention::has_entitytype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void NERMention::set_has_entitytype() {
  _has_bits_[0] |= 0x00000020u;
}
void NERMention::clear_has_entitytype() {
  _has_bits_[0] &= ~0x00000020u;
}
void NERMention::clear_entitytype() {
  entitytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entitytype();
}
 const ::std::string& NERMention::entitytype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.entityType)
  return entitytype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NERMention::set_entitytype(const ::std::string& value) {
  set_has_entitytype();
  entitytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.entityType)
}
 void NERMention::set_entitytype(const char* value) {
  set_has_entitytype();
  entitytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.NERMention.entityType)
}
 void NERMention::set_entitytype(const char* value, size_t size) {
  set_has_entitytype();
  entitytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.NERMention.entityType)
}
 ::std::string* NERMention::mutable_entitytype() {
  set_has_entitytype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.entityType)
  return entitytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NERMention::release_entitytype() {
  clear_has_entitytype();
  return entitytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NERMention::set_allocated_entitytype(::std::string* entitytype) {
  if (entitytype != NULL) {
    set_has_entitytype();
  } else {
    clear_has_entitytype();
  }
  entitytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entitytype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.entityType)
}

// optional .edu.stanford.nlp.pipeline.Timex timex = 7;
bool NERMention::has_timex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void NERMention::set_has_timex() {
  _has_bits_[0] |= 0x00000040u;
}
void NERMention::clear_has_timex() {
  _has_bits_[0] &= ~0x00000040u;
}
void NERMention::clear_timex() {
  if (timex_ != NULL) timex_->::edu::stanford::nlp::pipeline::Timex::Clear();
  clear_has_timex();
}
const ::edu::stanford::nlp::pipeline::Timex& NERMention::timex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.timex)
  return timex_ != NULL ? *timex_ : *default_instance_->timex_;
}
::edu::stanford::nlp::pipeline::Timex* NERMention::mutable_timex() {
  set_has_timex();
  if (timex_ == NULL) {
    timex_ = new ::edu::stanford::nlp::pipeline::Timex;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.timex)
  return timex_;
}
::edu::stanford::nlp::pipeline::Timex* NERMention::release_timex() {
  clear_has_timex();
  ::edu::stanford::nlp::pipeline::Timex* temp = timex_;
  timex_ = NULL;
  return temp;
}
void NERMention::set_allocated_timex(::edu::stanford::nlp::pipeline::Timex* timex) {
  delete timex_;
  timex_ = timex;
  if (timex) {
    set_has_timex();
  } else {
    clear_has_timex();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.timex)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SentenceFragment::kTokenIndexFieldNumber;
const int SentenceFragment::kRootFieldNumber;
const int SentenceFragment::kAssumedTruthFieldNumber;
const int SentenceFragment::kScoreFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SentenceFragment::SentenceFragment()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.SentenceFragment)
}

void SentenceFragment::InitAsDefaultInstance() {
}

SentenceFragment::SentenceFragment(const SentenceFragment& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.SentenceFragment)
}

void SentenceFragment::SharedCtor() {
  _cached_size_ = 0;
  root_ = 0u;
  assumedtruth_ = false;
  score_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SentenceFragment::~SentenceFragment() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.SentenceFragment)
  SharedDtor();
}

void SentenceFragment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SentenceFragment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SentenceFragment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SentenceFragment_descriptor_;
}

const SentenceFragment& SentenceFragment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

SentenceFragment* SentenceFragment::default_instance_ = NULL;

SentenceFragment* SentenceFragment::New(::google::protobuf::Arena* arena) const {
  SentenceFragment* n = new SentenceFragment;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SentenceFragment::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SentenceFragment*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(root_, score_);

#undef ZR_HELPER_
#undef ZR_

  tokenindex_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SentenceFragment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.SentenceFragment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 tokenIndex = 1;
      case 1: {
        if (tag == 8) {
         parse_tokenIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_tokenindex())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_tokenindex())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_tokenIndex;
        if (input->ExpectTag(16)) goto parse_root;
        break;
      }

      // optional uint32 root = 2;
      case 2: {
        if (tag == 16) {
         parse_root:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &root_)));
          set_has_root();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_assumedTruth;
        break;
      }

      // optional bool assumedTruth = 3;
      case 3: {
        if (tag == 24) {
         parse_assumedTruth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &assumedtruth_)));
          set_has_assumedtruth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_score;
        break;
      }

      // optional double score = 4;
      case 4: {
        if (tag == 33) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.SentenceFragment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.SentenceFragment)
  return false;
#undef DO_
}

void SentenceFragment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.SentenceFragment)
  // repeated uint32 tokenIndex = 1;
  for (int i = 0; i < this->tokenindex_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->tokenindex(i), output);
  }

  // optional uint32 root = 2;
  if (has_root()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->root(), output);
  }

  // optional bool assumedTruth = 3;
  if (has_assumedtruth()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->assumedtruth(), output);
  }

  // optional double score = 4;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->score(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.SentenceFragment)
}

::google::protobuf::uint8* SentenceFragment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.SentenceFragment)
  // repeated uint32 tokenIndex = 1;
  for (int i = 0; i < this->tokenindex_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->tokenindex(i), target);
  }

  // optional uint32 root = 2;
  if (has_root()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->root(), target);
  }

  // optional bool assumedTruth = 3;
  if (has_assumedtruth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->assumedtruth(), target);
  }

  // optional double score = 4;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->score(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.SentenceFragment)
  return target;
}

int SentenceFragment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & 14u) {
    // optional uint32 root = 2;
    if (has_root()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->root());
    }

    // optional bool assumedTruth = 3;
    if (has_assumedtruth()) {
      total_size += 1 + 1;
    }

    // optional double score = 4;
    if (has_score()) {
      total_size += 1 + 8;
    }

  }
  // repeated uint32 tokenIndex = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->tokenindex_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->tokenindex(i));
    }
    total_size += 1 * this->tokenindex_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SentenceFragment::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SentenceFragment* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SentenceFragment>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SentenceFragment::MergeFrom(const SentenceFragment& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  tokenindex_.MergeFrom(from.tokenindex_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_root()) {
      set_root(from.root());
    }
    if (from.has_assumedtruth()) {
      set_assumedtruth(from.assumedtruth());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SentenceFragment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SentenceFragment::CopyFrom(const SentenceFragment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SentenceFragment::IsInitialized() const {

  return true;
}

void SentenceFragment::Swap(SentenceFragment* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SentenceFragment::InternalSwap(SentenceFragment* other) {
  tokenindex_.UnsafeArenaSwap(&other->tokenindex_);
  std::swap(root_, other->root_);
  std::swap(assumedtruth_, other->assumedtruth_);
  std::swap(score_, other->score_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SentenceFragment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SentenceFragment_descriptor_;
  metadata.reflection = SentenceFragment_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SentenceFragment

// repeated uint32 tokenIndex = 1;
int SentenceFragment::tokenindex_size() const {
  return tokenindex_.size();
}
void SentenceFragment::clear_tokenindex() {
  tokenindex_.Clear();
}
 ::google::protobuf::uint32 SentenceFragment::tokenindex(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
  return tokenindex_.Get(index);
}
 void SentenceFragment::set_tokenindex(int index, ::google::protobuf::uint32 value) {
  tokenindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
}
 void SentenceFragment::add_tokenindex(::google::protobuf::uint32 value) {
  tokenindex_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SentenceFragment::tokenindex() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
  return tokenindex_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SentenceFragment::mutable_tokenindex() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
  return &tokenindex_;
}

// optional uint32 root = 2;
bool SentenceFragment::has_root() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SentenceFragment::set_has_root() {
  _has_bits_[0] |= 0x00000002u;
}
void SentenceFragment::clear_has_root() {
  _has_bits_[0] &= ~0x00000002u;
}
void SentenceFragment::clear_root() {
  root_ = 0u;
  clear_has_root();
}
 ::google::protobuf::uint32 SentenceFragment::root() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.root)
  return root_;
}
 void SentenceFragment::set_root(::google::protobuf::uint32 value) {
  set_has_root();
  root_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.root)
}

// optional bool assumedTruth = 3;
bool SentenceFragment::has_assumedtruth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SentenceFragment::set_has_assumedtruth() {
  _has_bits_[0] |= 0x00000004u;
}
void SentenceFragment::clear_has_assumedtruth() {
  _has_bits_[0] &= ~0x00000004u;
}
void SentenceFragment::clear_assumedtruth() {
  assumedtruth_ = false;
  clear_has_assumedtruth();
}
 bool SentenceFragment::assumedtruth() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.assumedTruth)
  return assumedtruth_;
}
 void SentenceFragment::set_assumedtruth(bool value) {
  set_has_assumedtruth();
  assumedtruth_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.assumedTruth)
}

// optional double score = 4;
bool SentenceFragment::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SentenceFragment::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
void SentenceFragment::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
void SentenceFragment::clear_score() {
  score_ = 0;
  clear_has_score();
}
 double SentenceFragment::score() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.score)
  return score_;
}
 void SentenceFragment::set_score(double value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.score)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RelationTriple::kSubjectFieldNumber;
const int RelationTriple::kRelationFieldNumber;
const int RelationTriple::kObjectFieldNumber;
const int RelationTriple::kConfidenceFieldNumber;
const int RelationTriple::kSubjectTokensFieldNumber;
const int RelationTriple::kRelationTokensFieldNumber;
const int RelationTriple::kObjectTokensFieldNumber;
const int RelationTriple::kTreeFieldNumber;
const int RelationTriple::kIstmodFieldNumber;
const int RelationTriple::kPrefixBeFieldNumber;
const int RelationTriple::kSuffixBeFieldNumber;
const int RelationTriple::kSuffixOfFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RelationTriple::RelationTriple()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.RelationTriple)
}

void RelationTriple::InitAsDefaultInstance() {
  tree_ = const_cast< ::edu::stanford::nlp::pipeline::DependencyGraph*>(&::edu::stanford::nlp::pipeline::DependencyGraph::default_instance());
}

RelationTriple::RelationTriple(const RelationTriple& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.RelationTriple)
}

void RelationTriple::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  subject_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  relation_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  object_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  confidence_ = 0;
  tree_ = NULL;
  istmod_ = false;
  prefixbe_ = false;
  suffixbe_ = false;
  suffixof_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RelationTriple::~RelationTriple() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.RelationTriple)
  SharedDtor();
}

void RelationTriple::SharedDtor() {
  subject_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  relation_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  object_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete tree_;
  }
}

void RelationTriple::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RelationTriple::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RelationTriple_descriptor_;
}

const RelationTriple& RelationTriple::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

RelationTriple* RelationTriple::default_instance_ = NULL;

RelationTriple* RelationTriple::New(::google::protobuf::Arena* arena) const {
  RelationTriple* n = new RelationTriple;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RelationTriple::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RelationTriple*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 143u) {
    if (has_subject()) {
      subject_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_relation()) {
      relation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_object()) {
      object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    confidence_ = 0;
    if (has_tree()) {
      if (tree_ != NULL) tree_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
    }
  }
  ZR_(istmod_, suffixof_);

#undef ZR_HELPER_
#undef ZR_

  subjecttokens_.Clear();
  relationtokens_.Clear();
  objecttokens_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RelationTriple::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.RelationTriple)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string subject = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subject()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->subject().data(), this->subject().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.RelationTriple.subject");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_relation;
        break;
      }

      // optional string relation = 2;
      case 2: {
        if (tag == 18) {
         parse_relation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_relation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->relation().data(), this->relation().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.RelationTriple.relation");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_object;
        break;
      }

      // optional string object = 3;
      case 3: {
        if (tag == 26) {
         parse_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_object()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->object().data(), this->object().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.RelationTriple.object");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_confidence;
        break;
      }

      // optional double confidence = 4;
      case 4: {
        if (tag == 33) {
         parse_confidence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &confidence_)));
          set_has_confidence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_subjectTokens;
        break;
      }

      // repeated uint32 subjectTokens = 5;
      case 5: {
        if (tag == 40) {
         parse_subjectTokens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_subjecttokens())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_subjecttokens())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_subjectTokens;
        if (input->ExpectTag(48)) goto parse_relationTokens;
        break;
      }

      // repeated uint32 relationTokens = 6;
      case 6: {
        if (tag == 48) {
         parse_relationTokens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_relationtokens())));
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_relationtokens())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_relationTokens;
        if (input->ExpectTag(56)) goto parse_objectTokens;
        break;
      }

      // repeated uint32 objectTokens = 7;
      case 7: {
        if (tag == 56) {
         parse_objectTokens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_objecttokens())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_objecttokens())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_objectTokens;
        if (input->ExpectTag(66)) goto parse_tree;
        break;
      }

      // optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
      case 8: {
        if (tag == 66) {
         parse_tree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tree()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_istmod;
        break;
      }

      // optional bool istmod = 9;
      case 9: {
        if (tag == 72) {
         parse_istmod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &istmod_)));
          set_has_istmod();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_prefixBe;
        break;
      }

      // optional bool prefixBe = 10;
      case 10: {
        if (tag == 80) {
         parse_prefixBe:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &prefixbe_)));
          set_has_prefixbe();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_suffixBe;
        break;
      }

      // optional bool suffixBe = 11;
      case 11: {
        if (tag == 88) {
         parse_suffixBe:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &suffixbe_)));
          set_has_suffixbe();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_suffixOf;
        break;
      }

      // optional bool suffixOf = 12;
      case 12: {
        if (tag == 96) {
         parse_suffixOf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &suffixof_)));
          set_has_suffixof();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.RelationTriple)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.RelationTriple)
  return false;
#undef DO_
}

void RelationTriple::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.RelationTriple)
  // optional string subject = 1;
  if (has_subject()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->subject().data(), this->subject().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.RelationTriple.subject");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->subject(), output);
  }

  // optional string relation = 2;
  if (has_relation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->relation().data(), this->relation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.RelationTriple.relation");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->relation(), output);
  }

  // optional string object = 3;
  if (has_object()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->object().data(), this->object().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.RelationTriple.object");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->object(), output);
  }

  // optional double confidence = 4;
  if (has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->confidence(), output);
  }

  // repeated uint32 subjectTokens = 5;
  for (int i = 0; i < this->subjecttokens_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->subjecttokens(i), output);
  }

  // repeated uint32 relationTokens = 6;
  for (int i = 0; i < this->relationtokens_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->relationtokens(i), output);
  }

  // repeated uint32 objectTokens = 7;
  for (int i = 0; i < this->objecttokens_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->objecttokens(i), output);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
  if (has_tree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->tree_, output);
  }

  // optional bool istmod = 9;
  if (has_istmod()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->istmod(), output);
  }

  // optional bool prefixBe = 10;
  if (has_prefixbe()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->prefixbe(), output);
  }

  // optional bool suffixBe = 11;
  if (has_suffixbe()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->suffixbe(), output);
  }

  // optional bool suffixOf = 12;
  if (has_suffixof()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->suffixof(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.RelationTriple)
}

::google::protobuf::uint8* RelationTriple::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.RelationTriple)
  // optional string subject = 1;
  if (has_subject()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->subject().data(), this->subject().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.RelationTriple.subject");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->subject(), target);
  }

  // optional string relation = 2;
  if (has_relation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->relation().data(), this->relation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.RelationTriple.relation");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->relation(), target);
  }

  // optional string object = 3;
  if (has_object()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->object().data(), this->object().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.RelationTriple.object");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->object(), target);
  }

  // optional double confidence = 4;
  if (has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->confidence(), target);
  }

  // repeated uint32 subjectTokens = 5;
  for (int i = 0; i < this->subjecttokens_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(5, this->subjecttokens(i), target);
  }

  // repeated uint32 relationTokens = 6;
  for (int i = 0; i < this->relationtokens_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(6, this->relationtokens(i), target);
  }

  // repeated uint32 objectTokens = 7;
  for (int i = 0; i < this->objecttokens_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(7, this->objecttokens(i), target);
  }

  // optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
  if (has_tree()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->tree_, target);
  }

  // optional bool istmod = 9;
  if (has_istmod()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->istmod(), target);
  }

  // optional bool prefixBe = 10;
  if (has_prefixbe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->prefixbe(), target);
  }

  // optional bool suffixBe = 11;
  if (has_suffixbe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->suffixbe(), target);
  }

  // optional bool suffixOf = 12;
  if (has_suffixof()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->suffixof(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.RelationTriple)
  return target;
}

int RelationTriple::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 143u) {
    // optional string subject = 1;
    if (has_subject()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subject());
    }

    // optional string relation = 2;
    if (has_relation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->relation());
    }

    // optional string object = 3;
    if (has_object()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->object());
    }

    // optional double confidence = 4;
    if (has_confidence()) {
      total_size += 1 + 8;
    }

    // optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
    if (has_tree()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->tree_);
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional bool istmod = 9;
    if (has_istmod()) {
      total_size += 1 + 1;
    }

    // optional bool prefixBe = 10;
    if (has_prefixbe()) {
      total_size += 1 + 1;
    }

    // optional bool suffixBe = 11;
    if (has_suffixbe()) {
      total_size += 1 + 1;
    }

    // optional bool suffixOf = 12;
    if (has_suffixof()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 subjectTokens = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->subjecttokens_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->subjecttokens(i));
    }
    total_size += 1 * this->subjecttokens_size() + data_size;
  }

  // repeated uint32 relationTokens = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->relationtokens_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->relationtokens(i));
    }
    total_size += 1 * this->relationtokens_size() + data_size;
  }

  // repeated uint32 objectTokens = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->objecttokens_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->objecttokens(i));
    }
    total_size += 1 * this->objecttokens_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RelationTriple::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RelationTriple* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RelationTriple>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RelationTriple::MergeFrom(const RelationTriple& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  subjecttokens_.MergeFrom(from.subjecttokens_);
  relationtokens_.MergeFrom(from.relationtokens_);
  objecttokens_.MergeFrom(from.objecttokens_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_subject()) {
      set_has_subject();
      subject_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.subject_);
    }
    if (from.has_relation()) {
      set_has_relation();
      relation_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.relation_);
    }
    if (from.has_object()) {
      set_has_object();
      object_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.object_);
    }
    if (from.has_confidence()) {
      set_confidence(from.confidence());
    }
    if (from.has_tree()) {
      mutable_tree()->::edu::stanford::nlp::pipeline::DependencyGraph::MergeFrom(from.tree());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_istmod()) {
      set_istmod(from.istmod());
    }
    if (from.has_prefixbe()) {
      set_prefixbe(from.prefixbe());
    }
    if (from.has_suffixbe()) {
      set_suffixbe(from.suffixbe());
    }
    if (from.has_suffixof()) {
      set_suffixof(from.suffixof());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RelationTriple::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RelationTriple::CopyFrom(const RelationTriple& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RelationTriple::IsInitialized() const {

  if (has_tree()) {
    if (!this->tree_->IsInitialized()) return false;
  }
  return true;
}

void RelationTriple::Swap(RelationTriple* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RelationTriple::InternalSwap(RelationTriple* other) {
  subject_.Swap(&other->subject_);
  relation_.Swap(&other->relation_);
  object_.Swap(&other->object_);
  std::swap(confidence_, other->confidence_);
  subjecttokens_.UnsafeArenaSwap(&other->subjecttokens_);
  relationtokens_.UnsafeArenaSwap(&other->relationtokens_);
  objecttokens_.UnsafeArenaSwap(&other->objecttokens_);
  std::swap(tree_, other->tree_);
  std::swap(istmod_, other->istmod_);
  std::swap(prefixbe_, other->prefixbe_);
  std::swap(suffixbe_, other->suffixbe_);
  std::swap(suffixof_, other->suffixof_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RelationTriple::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RelationTriple_descriptor_;
  metadata.reflection = RelationTriple_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RelationTriple

// optional string subject = 1;
bool RelationTriple::has_subject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RelationTriple::set_has_subject() {
  _has_bits_[0] |= 0x00000001u;
}
void RelationTriple::clear_has_subject() {
  _has_bits_[0] &= ~0x00000001u;
}
void RelationTriple::clear_subject() {
  subject_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subject();
}
 const ::std::string& RelationTriple::subject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.subject)
  return subject_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RelationTriple::set_subject(const ::std::string& value) {
  set_has_subject();
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.subject)
}
 void RelationTriple::set_subject(const char* value) {
  set_has_subject();
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.RelationTriple.subject)
}
 void RelationTriple::set_subject(const char* value, size_t size) {
  set_has_subject();
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.RelationTriple.subject)
}
 ::std::string* RelationTriple::mutable_subject() {
  set_has_subject();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.subject)
  return subject_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RelationTriple::release_subject() {
  clear_has_subject();
  return subject_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RelationTriple::set_allocated_subject(::std::string* subject) {
  if (subject != NULL) {
    set_has_subject();
  } else {
    clear_has_subject();
  }
  subject_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subject);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.subject)
}

// optional string relation = 2;
bool RelationTriple::has_relation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RelationTriple::set_has_relation() {
  _has_bits_[0] |= 0x00000002u;
}
void RelationTriple::clear_has_relation() {
  _has_bits_[0] &= ~0x00000002u;
}
void RelationTriple::clear_relation() {
  relation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_relation();
}
 const ::std::string& RelationTriple::relation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.relation)
  return relation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RelationTriple::set_relation(const ::std::string& value) {
  set_has_relation();
  relation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.relation)
}
 void RelationTriple::set_relation(const char* value) {
  set_has_relation();
  relation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.RelationTriple.relation)
}
 void RelationTriple::set_relation(const char* value, size_t size) {
  set_has_relation();
  relation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.RelationTriple.relation)
}
 ::std::string* RelationTriple::mutable_relation() {
  set_has_relation();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.relation)
  return relation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RelationTriple::release_relation() {
  clear_has_relation();
  return relation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RelationTriple::set_allocated_relation(::std::string* relation) {
  if (relation != NULL) {
    set_has_relation();
  } else {
    clear_has_relation();
  }
  relation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relation);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.relation)
}

// optional string object = 3;
bool RelationTriple::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RelationTriple::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
void RelationTriple::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
void RelationTriple::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
 const ::std::string& RelationTriple::object() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.object)
  return object_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RelationTriple::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.object)
}
 void RelationTriple::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.RelationTriple.object)
}
 void RelationTriple::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.RelationTriple.object)
}
 ::std::string* RelationTriple::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RelationTriple::release_object() {
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RelationTriple::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.object)
}

// optional double confidence = 4;
bool RelationTriple::has_confidence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RelationTriple::set_has_confidence() {
  _has_bits_[0] |= 0x00000008u;
}
void RelationTriple::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000008u;
}
void RelationTriple::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
 double RelationTriple::confidence() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.confidence)
  return confidence_;
}
 void RelationTriple::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.confidence)
}

// repeated uint32 subjectTokens = 5;
int RelationTriple::subjecttokens_size() const {
  return subjecttokens_.size();
}
void RelationTriple::clear_subjecttokens() {
  subjecttokens_.Clear();
}
 ::google::protobuf::uint32 RelationTriple::subjecttokens(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
  return subjecttokens_.Get(index);
}
 void RelationTriple::set_subjecttokens(int index, ::google::protobuf::uint32 value) {
  subjecttokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
}
 void RelationTriple::add_subjecttokens(::google::protobuf::uint32 value) {
  subjecttokens_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RelationTriple::subjecttokens() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
  return subjecttokens_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RelationTriple::mutable_subjecttokens() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
  return &subjecttokens_;
}

// repeated uint32 relationTokens = 6;
int RelationTriple::relationtokens_size() const {
  return relationtokens_.size();
}
void RelationTriple::clear_relationtokens() {
  relationtokens_.Clear();
}
 ::google::protobuf::uint32 RelationTriple::relationtokens(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
  return relationtokens_.Get(index);
}
 void RelationTriple::set_relationtokens(int index, ::google::protobuf::uint32 value) {
  relationtokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
}
 void RelationTriple::add_relationtokens(::google::protobuf::uint32 value) {
  relationtokens_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RelationTriple::relationtokens() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
  return relationtokens_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RelationTriple::mutable_relationtokens() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
  return &relationtokens_;
}

// repeated uint32 objectTokens = 7;
int RelationTriple::objecttokens_size() const {
  return objecttokens_.size();
}
void RelationTriple::clear_objecttokens() {
  objecttokens_.Clear();
}
 ::google::protobuf::uint32 RelationTriple::objecttokens(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
  return objecttokens_.Get(index);
}
 void RelationTriple::set_objecttokens(int index, ::google::protobuf::uint32 value) {
  objecttokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
}
 void RelationTriple::add_objecttokens(::google::protobuf::uint32 value) {
  objecttokens_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RelationTriple::objecttokens() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
  return objecttokens_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RelationTriple::mutable_objecttokens() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
  return &objecttokens_;
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
bool RelationTriple::has_tree() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RelationTriple::set_has_tree() {
  _has_bits_[0] |= 0x00000080u;
}
void RelationTriple::clear_has_tree() {
  _has_bits_[0] &= ~0x00000080u;
}
void RelationTriple::clear_tree() {
  if (tree_ != NULL) tree_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_tree();
}
const ::edu::stanford::nlp::pipeline::DependencyGraph& RelationTriple::tree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.tree)
  return tree_ != NULL ? *tree_ : *default_instance_->tree_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* RelationTriple::mutable_tree() {
  set_has_tree();
  if (tree_ == NULL) {
    tree_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.tree)
  return tree_;
}
::edu::stanford::nlp::pipeline::DependencyGraph* RelationTriple::release_tree() {
  clear_has_tree();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = tree_;
  tree_ = NULL;
  return temp;
}
void RelationTriple::set_allocated_tree(::edu::stanford::nlp::pipeline::DependencyGraph* tree) {
  delete tree_;
  tree_ = tree;
  if (tree) {
    set_has_tree();
  } else {
    clear_has_tree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.tree)
}

// optional bool istmod = 9;
bool RelationTriple::has_istmod() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RelationTriple::set_has_istmod() {
  _has_bits_[0] |= 0x00000100u;
}
void RelationTriple::clear_has_istmod() {
  _has_bits_[0] &= ~0x00000100u;
}
void RelationTriple::clear_istmod() {
  istmod_ = false;
  clear_has_istmod();
}
 bool RelationTriple::istmod() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.istmod)
  return istmod_;
}
 void RelationTriple::set_istmod(bool value) {
  set_has_istmod();
  istmod_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.istmod)
}

// optional bool prefixBe = 10;
bool RelationTriple::has_prefixbe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void RelationTriple::set_has_prefixbe() {
  _has_bits_[0] |= 0x00000200u;
}
void RelationTriple::clear_has_prefixbe() {
  _has_bits_[0] &= ~0x00000200u;
}
void RelationTriple::clear_prefixbe() {
  prefixbe_ = false;
  clear_has_prefixbe();
}
 bool RelationTriple::prefixbe() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.prefixBe)
  return prefixbe_;
}
 void RelationTriple::set_prefixbe(bool value) {
  set_has_prefixbe();
  prefixbe_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.prefixBe)
}

// optional bool suffixBe = 11;
bool RelationTriple::has_suffixbe() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void RelationTriple::set_has_suffixbe() {
  _has_bits_[0] |= 0x00000400u;
}
void RelationTriple::clear_has_suffixbe() {
  _has_bits_[0] &= ~0x00000400u;
}
void RelationTriple::clear_suffixbe() {
  suffixbe_ = false;
  clear_has_suffixbe();
}
 bool RelationTriple::suffixbe() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.suffixBe)
  return suffixbe_;
}
 void RelationTriple::set_suffixbe(bool value) {
  set_has_suffixbe();
  suffixbe_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.suffixBe)
}

// optional bool suffixOf = 12;
bool RelationTriple::has_suffixof() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void RelationTriple::set_has_suffixof() {
  _has_bits_[0] |= 0x00000800u;
}
void RelationTriple::clear_has_suffixof() {
  _has_bits_[0] &= ~0x00000800u;
}
void RelationTriple::clear_suffixof() {
  suffixof_ = false;
  clear_has_suffixof();
}
 bool RelationTriple::suffixof() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.suffixOf)
  return suffixof_;
}
 void RelationTriple::set_suffixof(bool value) {
  set_has_suffixof();
  suffixof_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.suffixOf)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapStringString::kKeyFieldNumber;
const int MapStringString::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapStringString::MapStringString()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.MapStringString)
}

void MapStringString::InitAsDefaultInstance() {
}

MapStringString::MapStringString(const MapStringString& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.MapStringString)
}

void MapStringString::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapStringString::~MapStringString() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.MapStringString)
  SharedDtor();
}

void MapStringString::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapStringString::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapStringString::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapStringString_descriptor_;
}

const MapStringString& MapStringString::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

MapStringString* MapStringString::default_instance_ = NULL;

MapStringString* MapStringString::New(::google::protobuf::Arena* arena) const {
  MapStringString* n = new MapStringString;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapStringString::Clear() {
  key_.Clear();
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MapStringString::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.MapStringString)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string key = 1;
      case 1: {
        if (tag == 10) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key(this->key_size() - 1).data(),
            this->key(this->key_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.MapStringString.key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_key;
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // repeated string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value(this->value_size() - 1).data(),
            this->value(this->value_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.MapStringString.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.MapStringString)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.MapStringString)
  return false;
#undef DO_
}

void MapStringString::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.MapStringString)
  // repeated string key = 1;
  for (int i = 0; i < this->key_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key(i).data(), this->key(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.MapStringString.key");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(i), output);
  }

  // repeated string value = 2;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value(i).data(), this->value(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.MapStringString.value");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.MapStringString)
}

::google::protobuf::uint8* MapStringString::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.MapStringString)
  // repeated string key = 1;
  for (int i = 0; i < this->key_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key(i).data(), this->key(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.MapStringString.key");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->key(i), target);
  }

  // repeated string value = 2;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value(i).data(), this->value(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.MapStringString.value");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->value(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.MapStringString)
  return target;
}

int MapStringString::ByteSize() const {
  int total_size = 0;

  // repeated string key = 1;
  total_size += 1 * this->key_size();
  for (int i = 0; i < this->key_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->key(i));
  }

  // repeated string value = 2;
  total_size += 1 * this->value_size();
  for (int i = 0; i < this->value_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->value(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapStringString::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MapStringString* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MapStringString>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapStringString::MergeFrom(const MapStringString& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  key_.MergeFrom(from.key_);
  value_.MergeFrom(from.value_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MapStringString::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapStringString::CopyFrom(const MapStringString& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapStringString::IsInitialized() const {

  return true;
}

void MapStringString::Swap(MapStringString* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapStringString::InternalSwap(MapStringString* other) {
  key_.UnsafeArenaSwap(&other->key_);
  value_.UnsafeArenaSwap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapStringString::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapStringString_descriptor_;
  metadata.reflection = MapStringString_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MapStringString

// repeated string key = 1;
int MapStringString::key_size() const {
  return key_.size();
}
void MapStringString::clear_key() {
  key_.Clear();
}
 const ::std::string& MapStringString::key(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapStringString.key)
  return key_.Get(index);
}
 ::std::string* MapStringString::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.MapStringString.key)
  return key_.Mutable(index);
}
 void MapStringString::set_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapStringString.key)
  key_.Mutable(index)->assign(value);
}
 void MapStringString::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.MapStringString.key)
}
 void MapStringString::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.MapStringString.key)
}
 ::std::string* MapStringString::add_key() {
  return key_.Add();
}
 void MapStringString::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapStringString.key)
}
 void MapStringString::add_key(const char* value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.MapStringString.key)
}
 void MapStringString::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.MapStringString.key)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapStringString::key() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapStringString.key)
  return key_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
MapStringString::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapStringString.key)
  return &key_;
}

// repeated string value = 2;
int MapStringString::value_size() const {
  return value_.size();
}
void MapStringString::clear_value() {
  value_.Clear();
}
 const ::std::string& MapStringString::value(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapStringString.value)
  return value_.Get(index);
}
 ::std::string* MapStringString::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.MapStringString.value)
  return value_.Mutable(index);
}
 void MapStringString::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapStringString.value)
  value_.Mutable(index)->assign(value);
}
 void MapStringString::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.MapStringString.value)
}
 void MapStringString::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.MapStringString.value)
}
 ::std::string* MapStringString::add_value() {
  return value_.Add();
}
 void MapStringString::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapStringString.value)
}
 void MapStringString::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.MapStringString.value)
}
 void MapStringString::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.MapStringString.value)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapStringString::value() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapStringString.value)
  return value_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
MapStringString::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapStringString.value)
  return &value_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapIntString::kKeyFieldNumber;
const int MapIntString::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapIntString::MapIntString()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:edu.stanford.nlp.pipeline.MapIntString)
}

void MapIntString::InitAsDefaultInstance() {
}

MapIntString::MapIntString(const MapIntString& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:edu.stanford.nlp.pipeline.MapIntString)
}

void MapIntString::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapIntString::~MapIntString() {
  // @@protoc_insertion_point(destructor:edu.stanford.nlp.pipeline.MapIntString)
  SharedDtor();
}

void MapIntString::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapIntString::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapIntString::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapIntString_descriptor_;
}

const MapIntString& MapIntString::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CoreNLP_2eproto();
  return *default_instance_;
}

MapIntString* MapIntString::default_instance_ = NULL;

MapIntString* MapIntString::New(::google::protobuf::Arena* arena) const {
  MapIntString* n = new MapIntString;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapIntString::Clear() {
  key_.Clear();
  value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MapIntString::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:edu.stanford.nlp.pipeline.MapIntString)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 key = 1;
      case 1: {
        if (tag == 8) {
         parse_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_key())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_key())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_key;
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // repeated string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value(this->value_size() - 1).data(),
            this->value(this->value_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "edu.stanford.nlp.pipeline.MapIntString.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:edu.stanford.nlp.pipeline.MapIntString)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:edu.stanford.nlp.pipeline.MapIntString)
  return false;
#undef DO_
}

void MapIntString::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:edu.stanford.nlp.pipeline.MapIntString)
  // repeated uint32 key = 1;
  for (int i = 0; i < this->key_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->key(i), output);
  }

  // repeated string value = 2;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value(i).data(), this->value(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.MapIntString.value");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:edu.stanford.nlp.pipeline.MapIntString)
}

::google::protobuf::uint8* MapIntString::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:edu.stanford.nlp.pipeline.MapIntString)
  // repeated uint32 key = 1;
  for (int i = 0; i < this->key_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->key(i), target);
  }

  // repeated string value = 2;
  for (int i = 0; i < this->value_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value(i).data(), this->value(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "edu.stanford.nlp.pipeline.MapIntString.value");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->value(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:edu.stanford.nlp.pipeline.MapIntString)
  return target;
}

int MapIntString::ByteSize() const {
  int total_size = 0;

  // repeated uint32 key = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->key_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->key(i));
    }
    total_size += 1 * this->key_size() + data_size;
  }

  // repeated string value = 2;
  total_size += 1 * this->value_size();
  for (int i = 0; i < this->value_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->value(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapIntString::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MapIntString* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MapIntString>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapIntString::MergeFrom(const MapIntString& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  key_.MergeFrom(from.key_);
  value_.MergeFrom(from.value_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MapIntString::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapIntString::CopyFrom(const MapIntString& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapIntString::IsInitialized() const {

  return true;
}

void MapIntString::Swap(MapIntString* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapIntString::InternalSwap(MapIntString* other) {
  key_.UnsafeArenaSwap(&other->key_);
  value_.UnsafeArenaSwap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapIntString::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapIntString_descriptor_;
  metadata.reflection = MapIntString_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MapIntString

// repeated uint32 key = 1;
int MapIntString::key_size() const {
  return key_.size();
}
void MapIntString::clear_key() {
  key_.Clear();
}
 ::google::protobuf::uint32 MapIntString::key(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapIntString.key)
  return key_.Get(index);
}
 void MapIntString::set_key(int index, ::google::protobuf::uint32 value) {
  key_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapIntString.key)
}
 void MapIntString::add_key(::google::protobuf::uint32 value) {
  key_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapIntString.key)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MapIntString::key() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapIntString.key)
  return key_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MapIntString::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapIntString.key)
  return &key_;
}

// repeated string value = 2;
int MapIntString::value_size() const {
  return value_.size();
}
void MapIntString::clear_value() {
  value_.Clear();
}
 const ::std::string& MapIntString::value(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapIntString.value)
  return value_.Get(index);
}
 ::std::string* MapIntString::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.MapIntString.value)
  return value_.Mutable(index);
}
 void MapIntString::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapIntString.value)
  value_.Mutable(index)->assign(value);
}
 void MapIntString::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.MapIntString.value)
}
 void MapIntString::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.MapIntString.value)
}
 ::std::string* MapIntString::add_value() {
  return value_.Add();
}
 void MapIntString::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapIntString.value)
}
 void MapIntString::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.MapIntString.value)
}
 void MapIntString::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.MapIntString.value)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapIntString::value() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapIntString.value)
  return value_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
MapIntString::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapIntString.value)
  return &value_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace pipeline
}  // namespace nlp
}  // namespace stanford
}  // namespace edu

// @@protoc_insertion_point(global_scope)
