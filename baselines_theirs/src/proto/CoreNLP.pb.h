// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CoreNLP.proto

#ifndef PROTOBUF_CoreNLP_2eproto__INCLUDED
#define PROTOBUF_CoreNLP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace edu {
namespace stanford {
namespace nlp {
namespace pipeline {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_CoreNLP_2eproto();
void protobuf_AssignDesc_CoreNLP_2eproto();
void protobuf_ShutdownFile_CoreNLP_2eproto();

class CorefChain;
class CorefChain_CorefMention;
class DependencyGraph;
class DependencyGraph_Edge;
class DependencyGraph_Node;
class Document;
class Entity;
class IndexedWord;
class MapIntString;
class MapStringString;
class Mention;
class NERMention;
class Operator;
class ParseTree;
class Polarity;
class Quote;
class Relation;
class RelationTriple;
class Sentence;
class SentenceFragment;
class Span;
class SpeakerInfo;
class Timex;
class Token;

enum Language {
  Unknown = 0,
  Any = 1,
  Arabic = 2,
  Chinese = 3,
  English = 4,
  German = 5,
  French = 6,
  Hebrew = 7,
  Spanish = 8,
  UniversalEnglish = 9
};
bool Language_IsValid(int value);
const Language Language_MIN = Unknown;
const Language Language_MAX = UniversalEnglish;
const int Language_ARRAYSIZE = Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_descriptor();
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_descriptor(), value);
}
inline bool Language_Parse(
    const ::std::string& name, Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum Sentiment {
  STRONG_NEGATIVE = 0,
  WEAK_NEGATIVE = 1,
  NEUTRAL = 2,
  WEAK_POSITIVE = 3,
  STRONG_POSITIVE = 4
};
bool Sentiment_IsValid(int value);
const Sentiment Sentiment_MIN = STRONG_NEGATIVE;
const Sentiment Sentiment_MAX = STRONG_POSITIVE;
const int Sentiment_ARRAYSIZE = Sentiment_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sentiment_descriptor();
inline const ::std::string& Sentiment_Name(Sentiment value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sentiment_descriptor(), value);
}
inline bool Sentiment_Parse(
    const ::std::string& name, Sentiment* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sentiment>(
    Sentiment_descriptor(), name, value);
}
enum NaturalLogicRelation {
  EQUIVALENCE = 0,
  FORWARD_ENTAILMENT = 1,
  REVERSE_ENTAILMENT = 2,
  NEGATION = 3,
  ALTERNATION = 4,
  COVER = 5,
  INDEPENDENCE = 6
};
bool NaturalLogicRelation_IsValid(int value);
const NaturalLogicRelation NaturalLogicRelation_MIN = EQUIVALENCE;
const NaturalLogicRelation NaturalLogicRelation_MAX = INDEPENDENCE;
const int NaturalLogicRelation_ARRAYSIZE = NaturalLogicRelation_MAX + 1;

const ::google::protobuf::EnumDescriptor* NaturalLogicRelation_descriptor();
inline const ::std::string& NaturalLogicRelation_Name(NaturalLogicRelation value) {
  return ::google::protobuf::internal::NameOfEnum(
    NaturalLogicRelation_descriptor(), value);
}
inline bool NaturalLogicRelation_Parse(
    const ::std::string& name, NaturalLogicRelation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NaturalLogicRelation>(
    NaturalLogicRelation_descriptor(), name, value);
}
// ===================================================================

class Document : public ::google::protobuf::Message {
 public:
  Document();
  virtual ~Document();

  Document(const Document& from);

  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();

  void Swap(Document* other);

  // implements Message ----------------------------------------------

  inline Document* New() const { return New(NULL); }

  Document* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Document* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
  int sentence_size() const;
  void clear_sentence();
  static const int kSentenceFieldNumber = 2;
  const ::edu::stanford::nlp::pipeline::Sentence& sentence(int index) const;
  ::edu::stanford::nlp::pipeline::Sentence* mutable_sentence(int index);
  ::edu::stanford::nlp::pipeline::Sentence* add_sentence();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence >*
      mutable_sentence();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence >&
      sentence() const;

  // repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
  int corefchain_size() const;
  void clear_corefchain();
  static const int kCorefChainFieldNumber = 3;
  const ::edu::stanford::nlp::pipeline::CorefChain& corefchain(int index) const;
  ::edu::stanford::nlp::pipeline::CorefChain* mutable_corefchain(int index);
  ::edu::stanford::nlp::pipeline::CorefChain* add_corefchain();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain >*
      mutable_corefchain();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain >&
      corefchain() const;

  // optional string docID = 4;
  bool has_docid() const;
  void clear_docid();
  static const int kDocIDFieldNumber = 4;
  const ::std::string& docid() const;
  void set_docid(const ::std::string& value);
  void set_docid(const char* value);
  void set_docid(const char* value, size_t size);
  ::std::string* mutable_docid();
  ::std::string* release_docid();
  void set_allocated_docid(::std::string* docid);

  // repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
  int sentencelesstoken_size() const;
  void clear_sentencelesstoken();
  static const int kSentencelessTokenFieldNumber = 5;
  const ::edu::stanford::nlp::pipeline::Token& sentencelesstoken(int index) const;
  ::edu::stanford::nlp::pipeline::Token* mutable_sentencelesstoken(int index);
  ::edu::stanford::nlp::pipeline::Token* add_sentencelesstoken();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >*
      mutable_sentencelesstoken();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >&
      sentencelesstoken() const;

  // repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
  int quote_size() const;
  void clear_quote();
  static const int kQuoteFieldNumber = 6;
  const ::edu::stanford::nlp::pipeline::Quote& quote(int index) const;
  ::edu::stanford::nlp::pipeline::Quote* mutable_quote(int index);
  ::edu::stanford::nlp::pipeline::Quote* add_quote();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote >*
      mutable_quote();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote >&
      quote() const;

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Document)
  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Document)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_docid();
  inline void clear_has_docid();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence > sentence_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain > corefchain_;
  ::google::protobuf::internal::ArenaStringPtr docid_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token > sentencelesstoken_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote > quote_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Document* default_instance_;
};
// -------------------------------------------------------------------

class Sentence : public ::google::protobuf::Message {
 public:
  Sentence();
  virtual ~Sentence();

  Sentence(const Sentence& from);

  inline Sentence& operator=(const Sentence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sentence& default_instance();

  void Swap(Sentence* other);

  // implements Message ----------------------------------------------

  inline Sentence* New() const { return New(NULL); }

  Sentence* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sentence& from);
  void MergeFrom(const Sentence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sentence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.stanford.nlp.pipeline.Token token = 1;
  int token_size() const;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::edu::stanford::nlp::pipeline::Token& token(int index) const;
  ::edu::stanford::nlp::pipeline::Token* mutable_token(int index);
  ::edu::stanford::nlp::pipeline::Token* add_token();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >*
      mutable_token();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >&
      token() const;

  // required uint32 tokenOffsetBegin = 2;
  bool has_tokenoffsetbegin() const;
  void clear_tokenoffsetbegin();
  static const int kTokenOffsetBeginFieldNumber = 2;
  ::google::protobuf::uint32 tokenoffsetbegin() const;
  void set_tokenoffsetbegin(::google::protobuf::uint32 value);

  // required uint32 tokenOffsetEnd = 3;
  bool has_tokenoffsetend() const;
  void clear_tokenoffsetend();
  static const int kTokenOffsetEndFieldNumber = 3;
  ::google::protobuf::uint32 tokenoffsetend() const;
  void set_tokenoffsetend(::google::protobuf::uint32 value);

  // optional uint32 sentenceIndex = 4;
  bool has_sentenceindex() const;
  void clear_sentenceindex();
  static const int kSentenceIndexFieldNumber = 4;
  ::google::protobuf::uint32 sentenceindex() const;
  void set_sentenceindex(::google::protobuf::uint32 value);

  // optional uint32 characterOffsetBegin = 5;
  bool has_characteroffsetbegin() const;
  void clear_characteroffsetbegin();
  static const int kCharacterOffsetBeginFieldNumber = 5;
  ::google::protobuf::uint32 characteroffsetbegin() const;
  void set_characteroffsetbegin(::google::protobuf::uint32 value);

  // optional uint32 characterOffsetEnd = 6;
  bool has_characteroffsetend() const;
  void clear_characteroffsetend();
  static const int kCharacterOffsetEndFieldNumber = 6;
  ::google::protobuf::uint32 characteroffsetend() const;
  void set_characteroffsetend(::google::protobuf::uint32 value);

  // optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
  bool has_parsetree() const;
  void clear_parsetree();
  static const int kParseTreeFieldNumber = 7;
  const ::edu::stanford::nlp::pipeline::ParseTree& parsetree() const;
  ::edu::stanford::nlp::pipeline::ParseTree* mutable_parsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* release_parsetree();
  void set_allocated_parsetree(::edu::stanford::nlp::pipeline::ParseTree* parsetree);

  // optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
  bool has_binarizedparsetree() const;
  void clear_binarizedparsetree();
  static const int kBinarizedParseTreeFieldNumber = 31;
  const ::edu::stanford::nlp::pipeline::ParseTree& binarizedparsetree() const;
  ::edu::stanford::nlp::pipeline::ParseTree* mutable_binarizedparsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* release_binarizedparsetree();
  void set_allocated_binarizedparsetree(::edu::stanford::nlp::pipeline::ParseTree* binarizedparsetree);

  // optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
  bool has_annotatedparsetree() const;
  void clear_annotatedparsetree();
  static const int kAnnotatedParseTreeFieldNumber = 32;
  const ::edu::stanford::nlp::pipeline::ParseTree& annotatedparsetree() const;
  ::edu::stanford::nlp::pipeline::ParseTree* mutable_annotatedparsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* release_annotatedparsetree();
  void set_allocated_annotatedparsetree(::edu::stanford::nlp::pipeline::ParseTree* annotatedparsetree);

  // optional string sentiment = 33;
  bool has_sentiment() const;
  void clear_sentiment();
  static const int kSentimentFieldNumber = 33;
  const ::std::string& sentiment() const;
  void set_sentiment(const ::std::string& value);
  void set_sentiment(const char* value);
  void set_sentiment(const char* value, size_t size);
  ::std::string* mutable_sentiment();
  ::std::string* release_sentiment();
  void set_allocated_sentiment(::std::string* sentiment);

  // repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
  int kbestparsetrees_size() const;
  void clear_kbestparsetrees();
  static const int kKBestParseTreesFieldNumber = 34;
  const ::edu::stanford::nlp::pipeline::ParseTree& kbestparsetrees(int index) const;
  ::edu::stanford::nlp::pipeline::ParseTree* mutable_kbestparsetrees(int index);
  ::edu::stanford::nlp::pipeline::ParseTree* add_kbestparsetrees();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >*
      mutable_kbestparsetrees();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >&
      kbestparsetrees() const;

  // optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
  bool has_basicdependencies() const;
  void clear_basicdependencies();
  static const int kBasicDependenciesFieldNumber = 8;
  const ::edu::stanford::nlp::pipeline::DependencyGraph& basicdependencies() const;
  ::edu::stanford::nlp::pipeline::DependencyGraph* mutable_basicdependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* release_basicdependencies();
  void set_allocated_basicdependencies(::edu::stanford::nlp::pipeline::DependencyGraph* basicdependencies);

  // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
  bool has_collapseddependencies() const;
  void clear_collapseddependencies();
  static const int kCollapsedDependenciesFieldNumber = 9;
  const ::edu::stanford::nlp::pipeline::DependencyGraph& collapseddependencies() const;
  ::edu::stanford::nlp::pipeline::DependencyGraph* mutable_collapseddependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* release_collapseddependencies();
  void set_allocated_collapseddependencies(::edu::stanford::nlp::pipeline::DependencyGraph* collapseddependencies);

  // optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
  bool has_collapsedccprocesseddependencies() const;
  void clear_collapsedccprocesseddependencies();
  static const int kCollapsedCCProcessedDependenciesFieldNumber = 10;
  const ::edu::stanford::nlp::pipeline::DependencyGraph& collapsedccprocesseddependencies() const;
  ::edu::stanford::nlp::pipeline::DependencyGraph* mutable_collapsedccprocesseddependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* release_collapsedccprocesseddependencies();
  void set_allocated_collapsedccprocesseddependencies(::edu::stanford::nlp::pipeline::DependencyGraph* collapsedccprocesseddependencies);

  // optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
  bool has_alternativedependencies() const;
  void clear_alternativedependencies();
  static const int kAlternativeDependenciesFieldNumber = 13;
  const ::edu::stanford::nlp::pipeline::DependencyGraph& alternativedependencies() const;
  ::edu::stanford::nlp::pipeline::DependencyGraph* mutable_alternativedependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* release_alternativedependencies();
  void set_allocated_alternativedependencies(::edu::stanford::nlp::pipeline::DependencyGraph* alternativedependencies);

  // repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
  int openietriple_size() const;
  void clear_openietriple();
  static const int kOpenieTripleFieldNumber = 14;
  const ::edu::stanford::nlp::pipeline::RelationTriple& openietriple(int index) const;
  ::edu::stanford::nlp::pipeline::RelationTriple* mutable_openietriple(int index);
  ::edu::stanford::nlp::pipeline::RelationTriple* add_openietriple();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >*
      mutable_openietriple();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >&
      openietriple() const;

  // repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
  int kbptriple_size() const;
  void clear_kbptriple();
  static const int kKbpTripleFieldNumber = 16;
  const ::edu::stanford::nlp::pipeline::RelationTriple& kbptriple(int index) const;
  ::edu::stanford::nlp::pipeline::RelationTriple* mutable_kbptriple(int index);
  ::edu::stanford::nlp::pipeline::RelationTriple* add_kbptriple();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >*
      mutable_kbptriple();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >&
      kbptriple() const;

  // repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
  int entailedsentence_size() const;
  void clear_entailedsentence();
  static const int kEntailedSentenceFieldNumber = 15;
  const ::edu::stanford::nlp::pipeline::SentenceFragment& entailedsentence(int index) const;
  ::edu::stanford::nlp::pipeline::SentenceFragment* mutable_entailedsentence(int index);
  ::edu::stanford::nlp::pipeline::SentenceFragment* add_entailedsentence();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment >*
      mutable_entailedsentence();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment >&
      entailedsentence() const;

  // optional uint32 paragraph = 11;
  bool has_paragraph() const;
  void clear_paragraph();
  static const int kParagraphFieldNumber = 11;
  ::google::protobuf::uint32 paragraph() const;
  void set_paragraph(::google::protobuf::uint32 value);

  // optional string text = 12;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 12;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional bool hasRelationAnnotations = 51;
  bool has_hasrelationannotations() const;
  void clear_hasrelationannotations();
  static const int kHasRelationAnnotationsFieldNumber = 51;
  bool hasrelationannotations() const;
  void set_hasrelationannotations(bool value);

  // repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
  int entity_size() const;
  void clear_entity();
  static const int kEntityFieldNumber = 52;
  const ::edu::stanford::nlp::pipeline::Entity& entity(int index) const;
  ::edu::stanford::nlp::pipeline::Entity* mutable_entity(int index);
  ::edu::stanford::nlp::pipeline::Entity* add_entity();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >*
      mutable_entity();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >&
      entity() const;

  // repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
  int relation_size() const;
  void clear_relation();
  static const int kRelationFieldNumber = 53;
  const ::edu::stanford::nlp::pipeline::Relation& relation(int index) const;
  ::edu::stanford::nlp::pipeline::Relation* mutable_relation(int index);
  ::edu::stanford::nlp::pipeline::Relation* add_relation();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation >*
      mutable_relation();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation >&
      relation() const;

  // optional bool hasNumerizedTokensAnnotation = 54;
  bool has_hasnumerizedtokensannotation() const;
  void clear_hasnumerizedtokensannotation();
  static const int kHasNumerizedTokensAnnotationFieldNumber = 54;
  bool hasnumerizedtokensannotation() const;
  void set_hasnumerizedtokensannotation(bool value);

  // repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
  int mentions_size() const;
  void clear_mentions();
  static const int kMentionsFieldNumber = 55;
  const ::edu::stanford::nlp::pipeline::NERMention& mentions(int index) const;
  ::edu::stanford::nlp::pipeline::NERMention* mutable_mentions(int index);
  ::edu::stanford::nlp::pipeline::NERMention* add_mentions();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention >*
      mutable_mentions();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention >&
      mentions() const;

  // repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
  int mentionsforcoref_size() const;
  void clear_mentionsforcoref();
  static const int kMentionsForCorefFieldNumber = 56;
  const ::edu::stanford::nlp::pipeline::Mention& mentionsforcoref(int index) const;
  ::edu::stanford::nlp::pipeline::Mention* mutable_mentionsforcoref(int index);
  ::edu::stanford::nlp::pipeline::Mention* add_mentionsforcoref();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention >*
      mutable_mentionsforcoref();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention >&
      mentionsforcoref() const;

  // optional bool hasCorefMentionsAnnotation = 57;
  bool has_hascorefmentionsannotation() const;
  void clear_hascorefmentionsannotation();
  static const int kHasCorefMentionsAnnotationFieldNumber = 57;
  bool hascorefmentionsannotation() const;
  void set_hascorefmentionsannotation(bool value);

  // optional string sentenceID = 58;
  bool has_sentenceid() const;
  void clear_sentenceid();
  static const int kSentenceIDFieldNumber = 58;
  const ::std::string& sentenceid() const;
  void set_sentenceid(const ::std::string& value);
  void set_sentenceid(const char* value);
  void set_sentenceid(const char* value, size_t size);
  ::std::string* mutable_sentenceid();
  ::std::string* release_sentenceid();
  void set_allocated_sentenceid(::std::string* sentenceid);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Sentence)
  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Sentence)
 private:
  inline void set_has_tokenoffsetbegin();
  inline void clear_has_tokenoffsetbegin();
  inline void set_has_tokenoffsetend();
  inline void clear_has_tokenoffsetend();
  inline void set_has_sentenceindex();
  inline void clear_has_sentenceindex();
  inline void set_has_characteroffsetbegin();
  inline void clear_has_characteroffsetbegin();
  inline void set_has_characteroffsetend();
  inline void clear_has_characteroffsetend();
  inline void set_has_parsetree();
  inline void clear_has_parsetree();
  inline void set_has_binarizedparsetree();
  inline void clear_has_binarizedparsetree();
  inline void set_has_annotatedparsetree();
  inline void clear_has_annotatedparsetree();
  inline void set_has_sentiment();
  inline void clear_has_sentiment();
  inline void set_has_basicdependencies();
  inline void clear_has_basicdependencies();
  inline void set_has_collapseddependencies();
  inline void clear_has_collapseddependencies();
  inline void set_has_collapsedccprocesseddependencies();
  inline void clear_has_collapsedccprocesseddependencies();
  inline void set_has_alternativedependencies();
  inline void clear_has_alternativedependencies();
  inline void set_has_paragraph();
  inline void clear_has_paragraph();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_hasrelationannotations();
  inline void clear_has_hasrelationannotations();
  inline void set_has_hasnumerizedtokensannotation();
  inline void clear_has_hasnumerizedtokensannotation();
  inline void set_has_hascorefmentionsannotation();
  inline void clear_has_hascorefmentionsannotation();
  inline void set_has_sentenceid();
  inline void clear_has_sentenceid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token > token_;
  ::google::protobuf::uint32 tokenoffsetbegin_;
  ::google::protobuf::uint32 tokenoffsetend_;
  ::google::protobuf::uint32 sentenceindex_;
  ::google::protobuf::uint32 characteroffsetbegin_;
  ::edu::stanford::nlp::pipeline::ParseTree* parsetree_;
  ::edu::stanford::nlp::pipeline::ParseTree* binarizedparsetree_;
  ::edu::stanford::nlp::pipeline::ParseTree* annotatedparsetree_;
  ::google::protobuf::internal::ArenaStringPtr sentiment_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree > kbestparsetrees_;
  ::edu::stanford::nlp::pipeline::DependencyGraph* basicdependencies_;
  ::google::protobuf::uint32 characteroffsetend_;
  ::google::protobuf::uint32 paragraph_;
  ::edu::stanford::nlp::pipeline::DependencyGraph* collapseddependencies_;
  ::edu::stanford::nlp::pipeline::DependencyGraph* collapsedccprocesseddependencies_;
  ::edu::stanford::nlp::pipeline::DependencyGraph* alternativedependencies_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple > openietriple_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple > kbptriple_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment > entailedsentence_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity > entity_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation > relation_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention > mentions_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention > mentionsforcoref_;
  ::google::protobuf::internal::ArenaStringPtr sentenceid_;
  bool hasrelationannotations_;
  bool hasnumerizedtokensannotation_;
  bool hascorefmentionsannotation_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Sentence* default_instance_;
};
// -------------------------------------------------------------------

class Token : public ::google::protobuf::Message {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();

  void Swap(Token* other);

  // implements Message ----------------------------------------------

  inline Token* New() const { return New(NULL); }

  Token* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Token* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string word = 1;
  bool has_word() const;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const ::std::string& word() const;
  void set_word(const ::std::string& value);
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  ::std::string* mutable_word();
  ::std::string* release_word();
  void set_allocated_word(::std::string* word);

  // optional string pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::std::string& pos() const;
  void set_pos(const ::std::string& value);
  void set_pos(const char* value);
  void set_pos(const char* value, size_t size);
  ::std::string* mutable_pos();
  ::std::string* release_pos();
  void set_allocated_pos(::std::string* pos);

  // optional string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional string category = 4;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 4;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // optional string before = 5;
  bool has_before() const;
  void clear_before();
  static const int kBeforeFieldNumber = 5;
  const ::std::string& before() const;
  void set_before(const ::std::string& value);
  void set_before(const char* value);
  void set_before(const char* value, size_t size);
  ::std::string* mutable_before();
  ::std::string* release_before();
  void set_allocated_before(::std::string* before);

  // optional string after = 6;
  bool has_after() const;
  void clear_after();
  static const int kAfterFieldNumber = 6;
  const ::std::string& after() const;
  void set_after(const ::std::string& value);
  void set_after(const char* value);
  void set_after(const char* value, size_t size);
  ::std::string* mutable_after();
  ::std::string* release_after();
  void set_allocated_after(::std::string* after);

  // optional string originalText = 7;
  bool has_originaltext() const;
  void clear_originaltext();
  static const int kOriginalTextFieldNumber = 7;
  const ::std::string& originaltext() const;
  void set_originaltext(const ::std::string& value);
  void set_originaltext(const char* value);
  void set_originaltext(const char* value, size_t size);
  ::std::string* mutable_originaltext();
  ::std::string* release_originaltext();
  void set_allocated_originaltext(::std::string* originaltext);

  // optional string ner = 8;
  bool has_ner() const;
  void clear_ner();
  static const int kNerFieldNumber = 8;
  const ::std::string& ner() const;
  void set_ner(const ::std::string& value);
  void set_ner(const char* value);
  void set_ner(const char* value, size_t size);
  ::std::string* mutable_ner();
  ::std::string* release_ner();
  void set_allocated_ner(::std::string* ner);

  // optional string normalizedNER = 9;
  bool has_normalizedner() const;
  void clear_normalizedner();
  static const int kNormalizedNERFieldNumber = 9;
  const ::std::string& normalizedner() const;
  void set_normalizedner(const ::std::string& value);
  void set_normalizedner(const char* value);
  void set_normalizedner(const char* value, size_t size);
  ::std::string* mutable_normalizedner();
  ::std::string* release_normalizedner();
  void set_allocated_normalizedner(::std::string* normalizedner);

  // optional string lemma = 10;
  bool has_lemma() const;
  void clear_lemma();
  static const int kLemmaFieldNumber = 10;
  const ::std::string& lemma() const;
  void set_lemma(const ::std::string& value);
  void set_lemma(const char* value);
  void set_lemma(const char* value, size_t size);
  ::std::string* mutable_lemma();
  ::std::string* release_lemma();
  void set_allocated_lemma(::std::string* lemma);

  // optional uint32 beginChar = 11;
  bool has_beginchar() const;
  void clear_beginchar();
  static const int kBeginCharFieldNumber = 11;
  ::google::protobuf::uint32 beginchar() const;
  void set_beginchar(::google::protobuf::uint32 value);

  // optional uint32 endChar = 12;
  bool has_endchar() const;
  void clear_endchar();
  static const int kEndCharFieldNumber = 12;
  ::google::protobuf::uint32 endchar() const;
  void set_endchar(::google::protobuf::uint32 value);

  // optional uint32 utterance = 13;
  bool has_utterance() const;
  void clear_utterance();
  static const int kUtteranceFieldNumber = 13;
  ::google::protobuf::uint32 utterance() const;
  void set_utterance(::google::protobuf::uint32 value);

  // optional string speaker = 14;
  bool has_speaker() const;
  void clear_speaker();
  static const int kSpeakerFieldNumber = 14;
  const ::std::string& speaker() const;
  void set_speaker(const ::std::string& value);
  void set_speaker(const char* value);
  void set_speaker(const char* value, size_t size);
  ::std::string* mutable_speaker();
  ::std::string* release_speaker();
  void set_allocated_speaker(::std::string* speaker);

  // optional uint32 beginIndex = 15;
  bool has_beginindex() const;
  void clear_beginindex();
  static const int kBeginIndexFieldNumber = 15;
  ::google::protobuf::uint32 beginindex() const;
  void set_beginindex(::google::protobuf::uint32 value);

  // optional uint32 endIndex = 16;
  bool has_endindex() const;
  void clear_endindex();
  static const int kEndIndexFieldNumber = 16;
  ::google::protobuf::uint32 endindex() const;
  void set_endindex(::google::protobuf::uint32 value);

  // optional uint32 tokenBeginIndex = 17;
  bool has_tokenbeginindex() const;
  void clear_tokenbeginindex();
  static const int kTokenBeginIndexFieldNumber = 17;
  ::google::protobuf::uint32 tokenbeginindex() const;
  void set_tokenbeginindex(::google::protobuf::uint32 value);

  // optional uint32 tokenEndIndex = 18;
  bool has_tokenendindex() const;
  void clear_tokenendindex();
  static const int kTokenEndIndexFieldNumber = 18;
  ::google::protobuf::uint32 tokenendindex() const;
  void set_tokenendindex(::google::protobuf::uint32 value);

  // optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
  bool has_timexvalue() const;
  void clear_timexvalue();
  static const int kTimexValueFieldNumber = 19;
  const ::edu::stanford::nlp::pipeline::Timex& timexvalue() const;
  ::edu::stanford::nlp::pipeline::Timex* mutable_timexvalue();
  ::edu::stanford::nlp::pipeline::Timex* release_timexvalue();
  void set_allocated_timexvalue(::edu::stanford::nlp::pipeline::Timex* timexvalue);

  // optional bool hasXmlContext = 21;
  bool has_hasxmlcontext() const;
  void clear_hasxmlcontext();
  static const int kHasXmlContextFieldNumber = 21;
  bool hasxmlcontext() const;
  void set_hasxmlcontext(bool value);

  // repeated string xmlContext = 22;
  int xmlcontext_size() const;
  void clear_xmlcontext();
  static const int kXmlContextFieldNumber = 22;
  const ::std::string& xmlcontext(int index) const;
  ::std::string* mutable_xmlcontext(int index);
  void set_xmlcontext(int index, const ::std::string& value);
  void set_xmlcontext(int index, const char* value);
  void set_xmlcontext(int index, const char* value, size_t size);
  ::std::string* add_xmlcontext();
  void add_xmlcontext(const ::std::string& value);
  void add_xmlcontext(const char* value);
  void add_xmlcontext(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& xmlcontext() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xmlcontext();

  // optional uint32 corefClusterID = 23;
  bool has_corefclusterid() const;
  void clear_corefclusterid();
  static const int kCorefClusterIDFieldNumber = 23;
  ::google::protobuf::uint32 corefclusterid() const;
  void set_corefclusterid(::google::protobuf::uint32 value);

  // optional string answer = 24;
  bool has_answer() const;
  void clear_answer();
  static const int kAnswerFieldNumber = 24;
  const ::std::string& answer() const;
  void set_answer(const ::std::string& value);
  void set_answer(const char* value);
  void set_answer(const char* value, size_t size);
  ::std::string* mutable_answer();
  ::std::string* release_answer();
  void set_allocated_answer(::std::string* answer);

  // optional uint32 headWordIndex = 26;
  bool has_headwordindex() const;
  void clear_headwordindex();
  static const int kHeadWordIndexFieldNumber = 26;
  ::google::protobuf::uint32 headwordindex() const;
  void set_headwordindex(::google::protobuf::uint32 value);

  // optional .edu.stanford.nlp.pipeline.Operator operator = 27;
  bool has_operator_() const;
  void clear_operator_();
  static const int kOperatorFieldNumber = 27;
  const ::edu::stanford::nlp::pipeline::Operator& operator_() const;
  ::edu::stanford::nlp::pipeline::Operator* mutable_operator_();
  ::edu::stanford::nlp::pipeline::Operator* release_operator_();
  void set_allocated_operator_(::edu::stanford::nlp::pipeline::Operator* operator_);

  // optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
  bool has_polarity() const;
  void clear_polarity();
  static const int kPolarityFieldNumber = 28;
  const ::edu::stanford::nlp::pipeline::Polarity& polarity() const;
  ::edu::stanford::nlp::pipeline::Polarity* mutable_polarity();
  ::edu::stanford::nlp::pipeline::Polarity* release_polarity();
  void set_allocated_polarity(::edu::stanford::nlp::pipeline::Polarity* polarity);

  // optional .edu.stanford.nlp.pipeline.Span span = 29;
  bool has_span() const;
  void clear_span();
  static const int kSpanFieldNumber = 29;
  const ::edu::stanford::nlp::pipeline::Span& span() const;
  ::edu::stanford::nlp::pipeline::Span* mutable_span();
  ::edu::stanford::nlp::pipeline::Span* release_span();
  void set_allocated_span(::edu::stanford::nlp::pipeline::Span* span);

  // optional string sentiment = 30;
  bool has_sentiment() const;
  void clear_sentiment();
  static const int kSentimentFieldNumber = 30;
  const ::std::string& sentiment() const;
  void set_sentiment(const ::std::string& value);
  void set_sentiment(const char* value);
  void set_sentiment(const char* value, size_t size);
  ::std::string* mutable_sentiment();
  ::std::string* release_sentiment();
  void set_allocated_sentiment(::std::string* sentiment);

  // optional int32 quotationIndex = 31;
  bool has_quotationindex() const;
  void clear_quotationindex();
  static const int kQuotationIndexFieldNumber = 31;
  ::google::protobuf::int32 quotationindex() const;
  void set_quotationindex(::google::protobuf::int32 value);

  // optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
  bool has_conllufeatures() const;
  void clear_conllufeatures();
  static const int kConllUFeaturesFieldNumber = 32;
  const ::edu::stanford::nlp::pipeline::MapStringString& conllufeatures() const;
  ::edu::stanford::nlp::pipeline::MapStringString* mutable_conllufeatures();
  ::edu::stanford::nlp::pipeline::MapStringString* release_conllufeatures();
  void set_allocated_conllufeatures(::edu::stanford::nlp::pipeline::MapStringString* conllufeatures);

  // optional string coarseTag = 33;
  bool has_coarsetag() const;
  void clear_coarsetag();
  static const int kCoarseTagFieldNumber = 33;
  const ::std::string& coarsetag() const;
  void set_coarsetag(const ::std::string& value);
  void set_coarsetag(const char* value);
  void set_coarsetag(const char* value, size_t size);
  ::std::string* mutable_coarsetag();
  ::std::string* release_coarsetag();
  void set_allocated_coarsetag(::std::string* coarsetag);

  // optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
  bool has_conllutokenspan() const;
  void clear_conllutokenspan();
  static const int kConllUTokenSpanFieldNumber = 34;
  const ::edu::stanford::nlp::pipeline::Span& conllutokenspan() const;
  ::edu::stanford::nlp::pipeline::Span* mutable_conllutokenspan();
  ::edu::stanford::nlp::pipeline::Span* release_conllutokenspan();
  void set_allocated_conllutokenspan(::edu::stanford::nlp::pipeline::Span* conllutokenspan);

  // optional string conllUMisc = 35;
  bool has_conllumisc() const;
  void clear_conllumisc();
  static const int kConllUMiscFieldNumber = 35;
  const ::std::string& conllumisc() const;
  void set_conllumisc(const ::std::string& value);
  void set_conllumisc(const char* value);
  void set_conllumisc(const char* value, size_t size);
  ::std::string* mutable_conllumisc();
  ::std::string* release_conllumisc();
  void set_allocated_conllumisc(::std::string* conllumisc);

  // optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
  bool has_conllusecondarydeps() const;
  void clear_conllusecondarydeps();
  static const int kConllUSecondaryDepsFieldNumber = 36;
  const ::edu::stanford::nlp::pipeline::MapIntString& conllusecondarydeps() const;
  ::edu::stanford::nlp::pipeline::MapIntString* mutable_conllusecondarydeps();
  ::edu::stanford::nlp::pipeline::MapIntString* release_conllusecondarydeps();
  void set_allocated_conllusecondarydeps(::edu::stanford::nlp::pipeline::MapIntString* conllusecondarydeps);

  // optional string wikipediaEntity = 37;
  bool has_wikipediaentity() const;
  void clear_wikipediaentity();
  static const int kWikipediaEntityFieldNumber = 37;
  const ::std::string& wikipediaentity() const;
  void set_wikipediaentity(const ::std::string& value);
  void set_wikipediaentity(const char* value);
  void set_wikipediaentity(const char* value, size_t size);
  ::std::string* mutable_wikipediaentity();
  ::std::string* release_wikipediaentity();
  void set_allocated_wikipediaentity(::std::string* wikipediaentity);

  // optional string gender = 51;
  bool has_gender() const;
  void clear_gender();
  static const int kGenderFieldNumber = 51;
  const ::std::string& gender() const;
  void set_gender(const ::std::string& value);
  void set_gender(const char* value);
  void set_gender(const char* value, size_t size);
  ::std::string* mutable_gender();
  ::std::string* release_gender();
  void set_allocated_gender(::std::string* gender);

  // optional string trueCase = 52;
  bool has_truecase() const;
  void clear_truecase();
  static const int kTrueCaseFieldNumber = 52;
  const ::std::string& truecase() const;
  void set_truecase(const ::std::string& value);
  void set_truecase(const char* value);
  void set_truecase(const char* value, size_t size);
  ::std::string* mutable_truecase();
  ::std::string* release_truecase();
  void set_allocated_truecase(::std::string* truecase);

  // optional string trueCaseText = 53;
  bool has_truecasetext() const;
  void clear_truecasetext();
  static const int kTrueCaseTextFieldNumber = 53;
  const ::std::string& truecasetext() const;
  void set_truecasetext(const ::std::string& value);
  void set_truecasetext(const char* value);
  void set_truecasetext(const char* value, size_t size);
  ::std::string* mutable_truecasetext();
  ::std::string* release_truecasetext();
  void set_allocated_truecasetext(::std::string* truecasetext);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Token)
  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Token)
 private:
  inline void set_has_word();
  inline void clear_has_word();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_before();
  inline void clear_has_before();
  inline void set_has_after();
  inline void clear_has_after();
  inline void set_has_originaltext();
  inline void clear_has_originaltext();
  inline void set_has_ner();
  inline void clear_has_ner();
  inline void set_has_normalizedner();
  inline void clear_has_normalizedner();
  inline void set_has_lemma();
  inline void clear_has_lemma();
  inline void set_has_beginchar();
  inline void clear_has_beginchar();
  inline void set_has_endchar();
  inline void clear_has_endchar();
  inline void set_has_utterance();
  inline void clear_has_utterance();
  inline void set_has_speaker();
  inline void clear_has_speaker();
  inline void set_has_beginindex();
  inline void clear_has_beginindex();
  inline void set_has_endindex();
  inline void clear_has_endindex();
  inline void set_has_tokenbeginindex();
  inline void clear_has_tokenbeginindex();
  inline void set_has_tokenendindex();
  inline void clear_has_tokenendindex();
  inline void set_has_timexvalue();
  inline void clear_has_timexvalue();
  inline void set_has_hasxmlcontext();
  inline void clear_has_hasxmlcontext();
  inline void set_has_corefclusterid();
  inline void clear_has_corefclusterid();
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_headwordindex();
  inline void clear_has_headwordindex();
  inline void set_has_operator_();
  inline void clear_has_operator_();
  inline void set_has_polarity();
  inline void clear_has_polarity();
  inline void set_has_span();
  inline void clear_has_span();
  inline void set_has_sentiment();
  inline void clear_has_sentiment();
  inline void set_has_quotationindex();
  inline void clear_has_quotationindex();
  inline void set_has_conllufeatures();
  inline void clear_has_conllufeatures();
  inline void set_has_coarsetag();
  inline void clear_has_coarsetag();
  inline void set_has_conllutokenspan();
  inline void clear_has_conllutokenspan();
  inline void set_has_conllumisc();
  inline void clear_has_conllumisc();
  inline void set_has_conllusecondarydeps();
  inline void clear_has_conllusecondarydeps();
  inline void set_has_wikipediaentity();
  inline void clear_has_wikipediaentity();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_truecase();
  inline void clear_has_truecase();
  inline void set_has_truecasetext();
  inline void clear_has_truecasetext();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[2];
  ::google::protobuf::internal::ArenaStringPtr word_;
  ::google::protobuf::internal::ArenaStringPtr pos_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::internal::ArenaStringPtr before_;
  ::google::protobuf::internal::ArenaStringPtr after_;
  ::google::protobuf::internal::ArenaStringPtr originaltext_;
  ::google::protobuf::internal::ArenaStringPtr ner_;
  ::google::protobuf::internal::ArenaStringPtr normalizedner_;
  ::google::protobuf::internal::ArenaStringPtr lemma_;
  ::google::protobuf::uint32 beginchar_;
  ::google::protobuf::uint32 endchar_;
  ::google::protobuf::internal::ArenaStringPtr speaker_;
  ::google::protobuf::uint32 utterance_;
  ::google::protobuf::uint32 beginindex_;
  ::google::protobuf::uint32 endindex_;
  ::google::protobuf::uint32 tokenbeginindex_;
  ::edu::stanford::nlp::pipeline::Timex* timexvalue_;
  ::google::protobuf::uint32 tokenendindex_;
  bool hasxmlcontext_;
  ::google::protobuf::RepeatedPtrField< ::std::string> xmlcontext_;
  ::google::protobuf::internal::ArenaStringPtr answer_;
  ::google::protobuf::uint32 corefclusterid_;
  ::google::protobuf::uint32 headwordindex_;
  ::edu::stanford::nlp::pipeline::Operator* operator__;
  ::edu::stanford::nlp::pipeline::Polarity* polarity_;
  ::edu::stanford::nlp::pipeline::Span* span_;
  ::google::protobuf::internal::ArenaStringPtr sentiment_;
  ::edu::stanford::nlp::pipeline::MapStringString* conllufeatures_;
  ::google::protobuf::internal::ArenaStringPtr coarsetag_;
  ::edu::stanford::nlp::pipeline::Span* conllutokenspan_;
  ::google::protobuf::internal::ArenaStringPtr conllumisc_;
  ::edu::stanford::nlp::pipeline::MapIntString* conllusecondarydeps_;
  ::google::protobuf::internal::ArenaStringPtr wikipediaentity_;
  ::google::protobuf::internal::ArenaStringPtr gender_;
  ::google::protobuf::internal::ArenaStringPtr truecase_;
  ::google::protobuf::internal::ArenaStringPtr truecasetext_;
  ::google::protobuf::int32 quotationindex_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Token* default_instance_;
};
// -------------------------------------------------------------------

class Quote : public ::google::protobuf::Message {
 public:
  Quote();
  virtual ~Quote();

  Quote(const Quote& from);

  inline Quote& operator=(const Quote& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quote& default_instance();

  void Swap(Quote* other);

  // implements Message ----------------------------------------------

  inline Quote* New() const { return New(NULL); }

  Quote* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quote& from);
  void MergeFrom(const Quote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Quote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 begin = 2;
  bool has_begin() const;
  void clear_begin();
  static const int kBeginFieldNumber = 2;
  ::google::protobuf::uint32 begin() const;
  void set_begin(::google::protobuf::uint32 value);

  // optional uint32 end = 3;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 3;
  ::google::protobuf::uint32 end() const;
  void set_end(::google::protobuf::uint32 value);

  // optional uint32 sentenceBegin = 5;
  bool has_sentencebegin() const;
  void clear_sentencebegin();
  static const int kSentenceBeginFieldNumber = 5;
  ::google::protobuf::uint32 sentencebegin() const;
  void set_sentencebegin(::google::protobuf::uint32 value);

  // optional uint32 sentenceEnd = 6;
  bool has_sentenceend() const;
  void clear_sentenceend();
  static const int kSentenceEndFieldNumber = 6;
  ::google::protobuf::uint32 sentenceend() const;
  void set_sentenceend(::google::protobuf::uint32 value);

  // optional uint32 tokenBegin = 7;
  bool has_tokenbegin() const;
  void clear_tokenbegin();
  static const int kTokenBeginFieldNumber = 7;
  ::google::protobuf::uint32 tokenbegin() const;
  void set_tokenbegin(::google::protobuf::uint32 value);

  // optional uint32 tokenEnd = 8;
  bool has_tokenend() const;
  void clear_tokenend();
  static const int kTokenEndFieldNumber = 8;
  ::google::protobuf::uint32 tokenend() const;
  void set_tokenend(::google::protobuf::uint32 value);

  // optional string docid = 9;
  bool has_docid() const;
  void clear_docid();
  static const int kDocidFieldNumber = 9;
  const ::std::string& docid() const;
  void set_docid(const ::std::string& value);
  void set_docid(const char* value);
  void set_docid(const char* value, size_t size);
  ::std::string* mutable_docid();
  ::std::string* release_docid();
  void set_allocated_docid(::std::string* docid);

  // optional uint32 index = 10;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 10;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Quote)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_sentencebegin();
  inline void clear_has_sentencebegin();
  inline void set_has_sentenceend();
  inline void clear_has_sentenceend();
  inline void set_has_tokenbegin();
  inline void clear_has_tokenbegin();
  inline void set_has_tokenend();
  inline void clear_has_tokenend();
  inline void set_has_docid();
  inline void clear_has_docid();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 begin_;
  ::google::protobuf::uint32 end_;
  ::google::protobuf::uint32 sentencebegin_;
  ::google::protobuf::uint32 sentenceend_;
  ::google::protobuf::uint32 tokenbegin_;
  ::google::protobuf::uint32 tokenend_;
  ::google::protobuf::internal::ArenaStringPtr docid_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Quote* default_instance_;
};
// -------------------------------------------------------------------

class ParseTree : public ::google::protobuf::Message {
 public:
  ParseTree();
  virtual ~ParseTree();

  ParseTree(const ParseTree& from);

  inline ParseTree& operator=(const ParseTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParseTree& default_instance();

  void Swap(ParseTree* other);

  // implements Message ----------------------------------------------

  inline ParseTree* New() const { return New(NULL); }

  ParseTree* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParseTree& from);
  void MergeFrom(const ParseTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ParseTree* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 1;
  const ::edu::stanford::nlp::pipeline::ParseTree& child(int index) const;
  ::edu::stanford::nlp::pipeline::ParseTree* mutable_child(int index);
  ::edu::stanford::nlp::pipeline::ParseTree* add_child();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >&
      child() const;

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional uint32 yieldBeginIndex = 3;
  bool has_yieldbeginindex() const;
  void clear_yieldbeginindex();
  static const int kYieldBeginIndexFieldNumber = 3;
  ::google::protobuf::uint32 yieldbeginindex() const;
  void set_yieldbeginindex(::google::protobuf::uint32 value);

  // optional uint32 yieldEndIndex = 4;
  bool has_yieldendindex() const;
  void clear_yieldendindex();
  static const int kYieldEndIndexFieldNumber = 4;
  ::google::protobuf::uint32 yieldendindex() const;
  void set_yieldendindex(::google::protobuf::uint32 value);

  // optional double score = 5;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 5;
  double score() const;
  void set_score(double value);

  // optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
  bool has_sentiment() const;
  void clear_sentiment();
  static const int kSentimentFieldNumber = 6;
  ::edu::stanford::nlp::pipeline::Sentiment sentiment() const;
  void set_sentiment(::edu::stanford::nlp::pipeline::Sentiment value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.ParseTree)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_yieldbeginindex();
  inline void clear_has_yieldbeginindex();
  inline void set_has_yieldendindex();
  inline void clear_has_yieldendindex();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_sentiment();
  inline void clear_has_sentiment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree > child_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint32 yieldbeginindex_;
  ::google::protobuf::uint32 yieldendindex_;
  double score_;
  int sentiment_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static ParseTree* default_instance_;
};
// -------------------------------------------------------------------

class DependencyGraph_Node : public ::google::protobuf::Message {
 public:
  DependencyGraph_Node();
  virtual ~DependencyGraph_Node();

  DependencyGraph_Node(const DependencyGraph_Node& from);

  inline DependencyGraph_Node& operator=(const DependencyGraph_Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DependencyGraph_Node& default_instance();

  void Swap(DependencyGraph_Node* other);

  // implements Message ----------------------------------------------

  inline DependencyGraph_Node* New() const { return New(NULL); }

  DependencyGraph_Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DependencyGraph_Node& from);
  void MergeFrom(const DependencyGraph_Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DependencyGraph_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sentenceIndex = 1;
  bool has_sentenceindex() const;
  void clear_sentenceindex();
  static const int kSentenceIndexFieldNumber = 1;
  ::google::protobuf::uint32 sentenceindex() const;
  void set_sentenceindex(::google::protobuf::uint32 value);

  // required uint32 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional uint32 copyAnnotation = 3;
  bool has_copyannotation() const;
  void clear_copyannotation();
  static const int kCopyAnnotationFieldNumber = 3;
  ::google::protobuf::uint32 copyannotation() const;
  void set_copyannotation(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.DependencyGraph.Node)
 private:
  inline void set_has_sentenceindex();
  inline void clear_has_sentenceindex();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_copyannotation();
  inline void clear_has_copyannotation();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sentenceindex_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 copyannotation_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static DependencyGraph_Node* default_instance_;
};
// -------------------------------------------------------------------

class DependencyGraph_Edge : public ::google::protobuf::Message {
 public:
  DependencyGraph_Edge();
  virtual ~DependencyGraph_Edge();

  DependencyGraph_Edge(const DependencyGraph_Edge& from);

  inline DependencyGraph_Edge& operator=(const DependencyGraph_Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DependencyGraph_Edge& default_instance();

  void Swap(DependencyGraph_Edge* other);

  // implements Message ----------------------------------------------

  inline DependencyGraph_Edge* New() const { return New(NULL); }

  DependencyGraph_Edge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DependencyGraph_Edge& from);
  void MergeFrom(const DependencyGraph_Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DependencyGraph_Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::google::protobuf::uint32 source() const;
  void set_source(::google::protobuf::uint32 value);

  // required uint32 target = 2;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  ::google::protobuf::uint32 target() const;
  void set_target(::google::protobuf::uint32 value);

  // optional string dep = 3;
  bool has_dep() const;
  void clear_dep();
  static const int kDepFieldNumber = 3;
  const ::std::string& dep() const;
  void set_dep(const ::std::string& value);
  void set_dep(const char* value);
  void set_dep(const char* value, size_t size);
  ::std::string* mutable_dep();
  ::std::string* release_dep();
  void set_allocated_dep(::std::string* dep);

  // optional bool isExtra = 4;
  bool has_isextra() const;
  void clear_isextra();
  static const int kIsExtraFieldNumber = 4;
  bool isextra() const;
  void set_isextra(bool value);

  // optional uint32 sourceCopy = 5;
  bool has_sourcecopy() const;
  void clear_sourcecopy();
  static const int kSourceCopyFieldNumber = 5;
  ::google::protobuf::uint32 sourcecopy() const;
  void set_sourcecopy(::google::protobuf::uint32 value);

  // optional uint32 targetCopy = 6;
  bool has_targetcopy() const;
  void clear_targetcopy();
  static const int kTargetCopyFieldNumber = 6;
  ::google::protobuf::uint32 targetcopy() const;
  void set_targetcopy(::google::protobuf::uint32 value);

  // optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 7;
  ::edu::stanford::nlp::pipeline::Language language() const;
  void set_language(::edu::stanford::nlp::pipeline::Language value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.DependencyGraph.Edge)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_dep();
  inline void clear_has_dep();
  inline void set_has_isextra();
  inline void clear_has_isextra();
  inline void set_has_sourcecopy();
  inline void clear_has_sourcecopy();
  inline void set_has_targetcopy();
  inline void clear_has_targetcopy();
  inline void set_has_language();
  inline void clear_has_language();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 source_;
  ::google::protobuf::uint32 target_;
  ::google::protobuf::internal::ArenaStringPtr dep_;
  bool isextra_;
  ::google::protobuf::uint32 sourcecopy_;
  ::google::protobuf::uint32 targetcopy_;
  int language_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static DependencyGraph_Edge* default_instance_;
};
// -------------------------------------------------------------------

class DependencyGraph : public ::google::protobuf::Message {
 public:
  DependencyGraph();
  virtual ~DependencyGraph();

  DependencyGraph(const DependencyGraph& from);

  inline DependencyGraph& operator=(const DependencyGraph& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DependencyGraph& default_instance();

  void Swap(DependencyGraph* other);

  // implements Message ----------------------------------------------

  inline DependencyGraph* New() const { return New(NULL); }

  DependencyGraph* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DependencyGraph& from);
  void MergeFrom(const DependencyGraph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DependencyGraph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DependencyGraph_Node Node;
  typedef DependencyGraph_Edge Edge;

  // accessors -------------------------------------------------------

  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::edu::stanford::nlp::pipeline::DependencyGraph_Node& node(int index) const;
  ::edu::stanford::nlp::pipeline::DependencyGraph_Node* mutable_node(int index);
  ::edu::stanford::nlp::pipeline::DependencyGraph_Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node >&
      node() const;

  // repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
  int edge_size() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  const ::edu::stanford::nlp::pipeline::DependencyGraph_Edge& edge(int index) const;
  ::edu::stanford::nlp::pipeline::DependencyGraph_Edge* mutable_edge(int index);
  ::edu::stanford::nlp::pipeline::DependencyGraph_Edge* add_edge();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge >*
      mutable_edge();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge >&
      edge() const;

  // repeated uint32 root = 3 [packed = true];
  int root_size() const;
  void clear_root();
  static const int kRootFieldNumber = 3;
  ::google::protobuf::uint32 root(int index) const;
  void set_root(int index, ::google::protobuf::uint32 value);
  void add_root(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      root() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_root();

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.DependencyGraph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node > node_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge > edge_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > root_;
  mutable int _root_cached_byte_size_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static DependencyGraph* default_instance_;
};
// -------------------------------------------------------------------

class CorefChain_CorefMention : public ::google::protobuf::Message {
 public:
  CorefChain_CorefMention();
  virtual ~CorefChain_CorefMention();

  CorefChain_CorefMention(const CorefChain_CorefMention& from);

  inline CorefChain_CorefMention& operator=(const CorefChain_CorefMention& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CorefChain_CorefMention& default_instance();

  void Swap(CorefChain_CorefMention* other);

  // implements Message ----------------------------------------------

  inline CorefChain_CorefMention* New() const { return New(NULL); }

  CorefChain_CorefMention* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CorefChain_CorefMention& from);
  void MergeFrom(const CorefChain_CorefMention& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CorefChain_CorefMention* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 mentionID = 1;
  bool has_mentionid() const;
  void clear_mentionid();
  static const int kMentionIDFieldNumber = 1;
  ::google::protobuf::int32 mentionid() const;
  void set_mentionid(::google::protobuf::int32 value);

  // optional string mentionType = 2;
  bool has_mentiontype() const;
  void clear_mentiontype();
  static const int kMentionTypeFieldNumber = 2;
  const ::std::string& mentiontype() const;
  void set_mentiontype(const ::std::string& value);
  void set_mentiontype(const char* value);
  void set_mentiontype(const char* value, size_t size);
  ::std::string* mutable_mentiontype();
  ::std::string* release_mentiontype();
  void set_allocated_mentiontype(::std::string* mentiontype);

  // optional string number = 3;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 3;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // optional string gender = 4;
  bool has_gender() const;
  void clear_gender();
  static const int kGenderFieldNumber = 4;
  const ::std::string& gender() const;
  void set_gender(const ::std::string& value);
  void set_gender(const char* value);
  void set_gender(const char* value, size_t size);
  ::std::string* mutable_gender();
  ::std::string* release_gender();
  void set_allocated_gender(::std::string* gender);

  // optional string animacy = 5;
  bool has_animacy() const;
  void clear_animacy();
  static const int kAnimacyFieldNumber = 5;
  const ::std::string& animacy() const;
  void set_animacy(const ::std::string& value);
  void set_animacy(const char* value);
  void set_animacy(const char* value, size_t size);
  ::std::string* mutable_animacy();
  ::std::string* release_animacy();
  void set_allocated_animacy(::std::string* animacy);

  // optional uint32 beginIndex = 6;
  bool has_beginindex() const;
  void clear_beginindex();
  static const int kBeginIndexFieldNumber = 6;
  ::google::protobuf::uint32 beginindex() const;
  void set_beginindex(::google::protobuf::uint32 value);

  // optional uint32 endIndex = 7;
  bool has_endindex() const;
  void clear_endindex();
  static const int kEndIndexFieldNumber = 7;
  ::google::protobuf::uint32 endindex() const;
  void set_endindex(::google::protobuf::uint32 value);

  // optional uint32 headIndex = 9;
  bool has_headindex() const;
  void clear_headindex();
  static const int kHeadIndexFieldNumber = 9;
  ::google::protobuf::uint32 headindex() const;
  void set_headindex(::google::protobuf::uint32 value);

  // optional uint32 sentenceIndex = 10;
  bool has_sentenceindex() const;
  void clear_sentenceindex();
  static const int kSentenceIndexFieldNumber = 10;
  ::google::protobuf::uint32 sentenceindex() const;
  void set_sentenceindex(::google::protobuf::uint32 value);

  // optional uint32 position = 11;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 11;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.CorefChain.CorefMention)
 private:
  inline void set_has_mentionid();
  inline void clear_has_mentionid();
  inline void set_has_mentiontype();
  inline void clear_has_mentiontype();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_animacy();
  inline void clear_has_animacy();
  inline void set_has_beginindex();
  inline void clear_has_beginindex();
  inline void set_has_endindex();
  inline void clear_has_endindex();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_sentenceindex();
  inline void clear_has_sentenceindex();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mentiontype_;
  ::google::protobuf::internal::ArenaStringPtr number_;
  ::google::protobuf::int32 mentionid_;
  ::google::protobuf::uint32 beginindex_;
  ::google::protobuf::internal::ArenaStringPtr gender_;
  ::google::protobuf::internal::ArenaStringPtr animacy_;
  ::google::protobuf::uint32 endindex_;
  ::google::protobuf::uint32 headindex_;
  ::google::protobuf::uint32 sentenceindex_;
  ::google::protobuf::uint32 position_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static CorefChain_CorefMention* default_instance_;
};
// -------------------------------------------------------------------

class CorefChain : public ::google::protobuf::Message {
 public:
  CorefChain();
  virtual ~CorefChain();

  CorefChain(const CorefChain& from);

  inline CorefChain& operator=(const CorefChain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CorefChain& default_instance();

  void Swap(CorefChain* other);

  // implements Message ----------------------------------------------

  inline CorefChain* New() const { return New(NULL); }

  CorefChain* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CorefChain& from);
  void MergeFrom(const CorefChain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CorefChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CorefChain_CorefMention CorefMention;

  // accessors -------------------------------------------------------

  // required int32 chainID = 1;
  bool has_chainid() const;
  void clear_chainid();
  static const int kChainIDFieldNumber = 1;
  ::google::protobuf::int32 chainid() const;
  void set_chainid(::google::protobuf::int32 value);

  // repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
  int mention_size() const;
  void clear_mention();
  static const int kMentionFieldNumber = 2;
  const ::edu::stanford::nlp::pipeline::CorefChain_CorefMention& mention(int index) const;
  ::edu::stanford::nlp::pipeline::CorefChain_CorefMention* mutable_mention(int index);
  ::edu::stanford::nlp::pipeline::CorefChain_CorefMention* add_mention();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention >*
      mutable_mention();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention >&
      mention() const;

  // required uint32 representative = 3;
  bool has_representative() const;
  void clear_representative();
  static const int kRepresentativeFieldNumber = 3;
  ::google::protobuf::uint32 representative() const;
  void set_representative(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.CorefChain)
 private:
  inline void set_has_chainid();
  inline void clear_has_chainid();
  inline void set_has_representative();
  inline void clear_has_representative();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention > mention_;
  ::google::protobuf::int32 chainid_;
  ::google::protobuf::uint32 representative_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static CorefChain* default_instance_;
};
// -------------------------------------------------------------------

class Mention : public ::google::protobuf::Message {
 public:
  Mention();
  virtual ~Mention();

  Mention(const Mention& from);

  inline Mention& operator=(const Mention& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mention& default_instance();

  void Swap(Mention* other);

  // implements Message ----------------------------------------------

  inline Mention* New() const { return New(NULL); }

  Mention* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mention& from);
  void MergeFrom(const Mention& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mention* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 mentionID = 1;
  bool has_mentionid() const;
  void clear_mentionid();
  static const int kMentionIDFieldNumber = 1;
  ::google::protobuf::int32 mentionid() const;
  void set_mentionid(::google::protobuf::int32 value);

  // optional string mentionType = 2;
  bool has_mentiontype() const;
  void clear_mentiontype();
  static const int kMentionTypeFieldNumber = 2;
  const ::std::string& mentiontype() const;
  void set_mentiontype(const ::std::string& value);
  void set_mentiontype(const char* value);
  void set_mentiontype(const char* value, size_t size);
  ::std::string* mutable_mentiontype();
  ::std::string* release_mentiontype();
  void set_allocated_mentiontype(::std::string* mentiontype);

  // optional string number = 3;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 3;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // optional string gender = 4;
  bool has_gender() const;
  void clear_gender();
  static const int kGenderFieldNumber = 4;
  const ::std::string& gender() const;
  void set_gender(const ::std::string& value);
  void set_gender(const char* value);
  void set_gender(const char* value, size_t size);
  ::std::string* mutable_gender();
  ::std::string* release_gender();
  void set_allocated_gender(::std::string* gender);

  // optional string animacy = 5;
  bool has_animacy() const;
  void clear_animacy();
  static const int kAnimacyFieldNumber = 5;
  const ::std::string& animacy() const;
  void set_animacy(const ::std::string& value);
  void set_animacy(const char* value);
  void set_animacy(const char* value, size_t size);
  ::std::string* mutable_animacy();
  ::std::string* release_animacy();
  void set_allocated_animacy(::std::string* animacy);

  // optional string person = 6;
  bool has_person() const;
  void clear_person();
  static const int kPersonFieldNumber = 6;
  const ::std::string& person() const;
  void set_person(const ::std::string& value);
  void set_person(const char* value);
  void set_person(const char* value, size_t size);
  ::std::string* mutable_person();
  ::std::string* release_person();
  void set_allocated_person(::std::string* person);

  // optional uint32 startIndex = 7;
  bool has_startindex() const;
  void clear_startindex();
  static const int kStartIndexFieldNumber = 7;
  ::google::protobuf::uint32 startindex() const;
  void set_startindex(::google::protobuf::uint32 value);

  // optional uint32 endIndex = 9;
  bool has_endindex() const;
  void clear_endindex();
  static const int kEndIndexFieldNumber = 9;
  ::google::protobuf::uint32 endindex() const;
  void set_endindex(::google::protobuf::uint32 value);

  // optional uint32 headIndex = 10;
  bool has_headindex() const;
  void clear_headindex();
  static const int kHeadIndexFieldNumber = 10;
  ::google::protobuf::uint32 headindex() const;
  void set_headindex(::google::protobuf::uint32 value);

  // optional string headString = 11;
  bool has_headstring() const;
  void clear_headstring();
  static const int kHeadStringFieldNumber = 11;
  const ::std::string& headstring() const;
  void set_headstring(const ::std::string& value);
  void set_headstring(const char* value);
  void set_headstring(const char* value, size_t size);
  ::std::string* mutable_headstring();
  ::std::string* release_headstring();
  void set_allocated_headstring(::std::string* headstring);

  // optional string nerString = 12;
  bool has_nerstring() const;
  void clear_nerstring();
  static const int kNerStringFieldNumber = 12;
  const ::std::string& nerstring() const;
  void set_nerstring(const ::std::string& value);
  void set_nerstring(const char* value);
  void set_nerstring(const char* value, size_t size);
  ::std::string* mutable_nerstring();
  ::std::string* release_nerstring();
  void set_allocated_nerstring(::std::string* nerstring);

  // optional uint32 originalRef = 13;
  bool has_originalref() const;
  void clear_originalref();
  static const int kOriginalRefFieldNumber = 13;
  ::google::protobuf::uint32 originalref() const;
  void set_originalref(::google::protobuf::uint32 value);

  // optional int32 goldCorefClusterID = 14;
  bool has_goldcorefclusterid() const;
  void clear_goldcorefclusterid();
  static const int kGoldCorefClusterIDFieldNumber = 14;
  ::google::protobuf::int32 goldcorefclusterid() const;
  void set_goldcorefclusterid(::google::protobuf::int32 value);

  // optional int32 corefClusterID = 15;
  bool has_corefclusterid() const;
  void clear_corefclusterid();
  static const int kCorefClusterIDFieldNumber = 15;
  ::google::protobuf::int32 corefclusterid() const;
  void set_corefclusterid(::google::protobuf::int32 value);

  // optional uint32 mentionNum = 16;
  bool has_mentionnum() const;
  void clear_mentionnum();
  static const int kMentionNumFieldNumber = 16;
  ::google::protobuf::uint32 mentionnum() const;
  void set_mentionnum(::google::protobuf::uint32 value);

  // optional uint32 sentNum = 17;
  bool has_sentnum() const;
  void clear_sentnum();
  static const int kSentNumFieldNumber = 17;
  ::google::protobuf::uint32 sentnum() const;
  void set_sentnum(::google::protobuf::uint32 value);

  // optional uint32 utter = 18;
  bool has_utter() const;
  void clear_utter();
  static const int kUtterFieldNumber = 18;
  ::google::protobuf::uint32 utter() const;
  void set_utter(::google::protobuf::uint32 value);

  // optional uint32 paragraph = 19;
  bool has_paragraph() const;
  void clear_paragraph();
  static const int kParagraphFieldNumber = 19;
  ::google::protobuf::uint32 paragraph() const;
  void set_paragraph(::google::protobuf::uint32 value);

  // optional bool isSubject = 20;
  bool has_issubject() const;
  void clear_issubject();
  static const int kIsSubjectFieldNumber = 20;
  bool issubject() const;
  void set_issubject(bool value);

  // optional bool isDirectObject = 21;
  bool has_isdirectobject() const;
  void clear_isdirectobject();
  static const int kIsDirectObjectFieldNumber = 21;
  bool isdirectobject() const;
  void set_isdirectobject(bool value);

  // optional bool isIndirectObject = 22;
  bool has_isindirectobject() const;
  void clear_isindirectobject();
  static const int kIsIndirectObjectFieldNumber = 22;
  bool isindirectobject() const;
  void set_isindirectobject(bool value);

  // optional bool isPrepositionObject = 23;
  bool has_isprepositionobject() const;
  void clear_isprepositionobject();
  static const int kIsPrepositionObjectFieldNumber = 23;
  bool isprepositionobject() const;
  void set_isprepositionobject(bool value);

  // optional bool hasTwin = 24;
  bool has_hastwin() const;
  void clear_hastwin();
  static const int kHasTwinFieldNumber = 24;
  bool hastwin() const;
  void set_hastwin(bool value);

  // optional bool generic = 25;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 25;
  bool generic() const;
  void set_generic(bool value);

  // optional bool isSingleton = 26;
  bool has_issingleton() const;
  void clear_issingleton();
  static const int kIsSingletonFieldNumber = 26;
  bool issingleton() const;
  void set_issingleton(bool value);

  // optional bool hasBasicDependency = 27;
  bool has_hasbasicdependency() const;
  void clear_hasbasicdependency();
  static const int kHasBasicDependencyFieldNumber = 27;
  bool hasbasicdependency() const;
  void set_hasbasicdependency(bool value);

  // optional bool hasCollapsedDependency = 28;
  bool has_hascollapseddependency() const;
  void clear_hascollapseddependency();
  static const int kHasCollapsedDependencyFieldNumber = 28;
  bool hascollapseddependency() const;
  void set_hascollapseddependency(bool value);

  // optional bool hasContextParseTree = 29;
  bool has_hascontextparsetree() const;
  void clear_hascontextparsetree();
  static const int kHasContextParseTreeFieldNumber = 29;
  bool hascontextparsetree() const;
  void set_hascontextparsetree(bool value);

  // optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
  bool has_headindexedword() const;
  void clear_headindexedword();
  static const int kHeadIndexedWordFieldNumber = 30;
  const ::edu::stanford::nlp::pipeline::IndexedWord& headindexedword() const;
  ::edu::stanford::nlp::pipeline::IndexedWord* mutable_headindexedword();
  ::edu::stanford::nlp::pipeline::IndexedWord* release_headindexedword();
  void set_allocated_headindexedword(::edu::stanford::nlp::pipeline::IndexedWord* headindexedword);

  // optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
  bool has_dependingverb() const;
  void clear_dependingverb();
  static const int kDependingVerbFieldNumber = 31;
  const ::edu::stanford::nlp::pipeline::IndexedWord& dependingverb() const;
  ::edu::stanford::nlp::pipeline::IndexedWord* mutable_dependingverb();
  ::edu::stanford::nlp::pipeline::IndexedWord* release_dependingverb();
  void set_allocated_dependingverb(::edu::stanford::nlp::pipeline::IndexedWord* dependingverb);

  // optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
  bool has_headword() const;
  void clear_headword();
  static const int kHeadWordFieldNumber = 32;
  const ::edu::stanford::nlp::pipeline::IndexedWord& headword() const;
  ::edu::stanford::nlp::pipeline::IndexedWord* mutable_headword();
  ::edu::stanford::nlp::pipeline::IndexedWord* release_headword();
  void set_allocated_headword(::edu::stanford::nlp::pipeline::IndexedWord* headword);

  // optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
  bool has_speakerinfo() const;
  void clear_speakerinfo();
  static const int kSpeakerInfoFieldNumber = 33;
  const ::edu::stanford::nlp::pipeline::SpeakerInfo& speakerinfo() const;
  ::edu::stanford::nlp::pipeline::SpeakerInfo* mutable_speakerinfo();
  ::edu::stanford::nlp::pipeline::SpeakerInfo* release_speakerinfo();
  void set_allocated_speakerinfo(::edu::stanford::nlp::pipeline::SpeakerInfo* speakerinfo);

  // repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
  int sentencewords_size() const;
  void clear_sentencewords();
  static const int kSentenceWordsFieldNumber = 50;
  const ::edu::stanford::nlp::pipeline::IndexedWord& sentencewords(int index) const;
  ::edu::stanford::nlp::pipeline::IndexedWord* mutable_sentencewords(int index);
  ::edu::stanford::nlp::pipeline::IndexedWord* add_sentencewords();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >*
      mutable_sentencewords();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >&
      sentencewords() const;

  // repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
  int originalspan_size() const;
  void clear_originalspan();
  static const int kOriginalSpanFieldNumber = 51;
  const ::edu::stanford::nlp::pipeline::IndexedWord& originalspan(int index) const;
  ::edu::stanford::nlp::pipeline::IndexedWord* mutable_originalspan(int index);
  ::edu::stanford::nlp::pipeline::IndexedWord* add_originalspan();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >*
      mutable_originalspan();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >&
      originalspan() const;

  // repeated string dependents = 52;
  int dependents_size() const;
  void clear_dependents();
  static const int kDependentsFieldNumber = 52;
  const ::std::string& dependents(int index) const;
  ::std::string* mutable_dependents(int index);
  void set_dependents(int index, const ::std::string& value);
  void set_dependents(int index, const char* value);
  void set_dependents(int index, const char* value, size_t size);
  ::std::string* add_dependents();
  void add_dependents(const ::std::string& value);
  void add_dependents(const char* value);
  void add_dependents(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dependents() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dependents();

  // repeated string preprocessedTerms = 53;
  int preprocessedterms_size() const;
  void clear_preprocessedterms();
  static const int kPreprocessedTermsFieldNumber = 53;
  const ::std::string& preprocessedterms(int index) const;
  ::std::string* mutable_preprocessedterms(int index);
  void set_preprocessedterms(int index, const ::std::string& value);
  void set_preprocessedterms(int index, const char* value);
  void set_preprocessedterms(int index, const char* value, size_t size);
  ::std::string* add_preprocessedterms();
  void add_preprocessedterms(const ::std::string& value);
  void add_preprocessedterms(const char* value);
  void add_preprocessedterms(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& preprocessedterms() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_preprocessedterms();

  // repeated int32 appositions = 54;
  int appositions_size() const;
  void clear_appositions();
  static const int kAppositionsFieldNumber = 54;
  ::google::protobuf::int32 appositions(int index) const;
  void set_appositions(int index, ::google::protobuf::int32 value);
  void add_appositions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      appositions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_appositions();

  // repeated int32 predicateNominatives = 55;
  int predicatenominatives_size() const;
  void clear_predicatenominatives();
  static const int kPredicateNominativesFieldNumber = 55;
  ::google::protobuf::int32 predicatenominatives(int index) const;
  void set_predicatenominatives(int index, ::google::protobuf::int32 value);
  void add_predicatenominatives(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      predicatenominatives() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_predicatenominatives();

  // repeated int32 relativePronouns = 56;
  int relativepronouns_size() const;
  void clear_relativepronouns();
  static const int kRelativePronounsFieldNumber = 56;
  ::google::protobuf::int32 relativepronouns(int index) const;
  void set_relativepronouns(int index, ::google::protobuf::int32 value);
  void add_relativepronouns(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      relativepronouns() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_relativepronouns();

  // repeated int32 listMembers = 57;
  int listmembers_size() const;
  void clear_listmembers();
  static const int kListMembersFieldNumber = 57;
  ::google::protobuf::int32 listmembers(int index) const;
  void set_listmembers(int index, ::google::protobuf::int32 value);
  void add_listmembers(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      listmembers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_listmembers();

  // repeated int32 belongToLists = 58;
  int belongtolists_size() const;
  void clear_belongtolists();
  static const int kBelongToListsFieldNumber = 58;
  ::google::protobuf::int32 belongtolists(int index) const;
  void set_belongtolists(int index, ::google::protobuf::int32 value);
  void add_belongtolists(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      belongtolists() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_belongtolists();

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Mention)
 private:
  inline void set_has_mentionid();
  inline void clear_has_mentionid();
  inline void set_has_mentiontype();
  inline void clear_has_mentiontype();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_animacy();
  inline void clear_has_animacy();
  inline void set_has_person();
  inline void clear_has_person();
  inline void set_has_startindex();
  inline void clear_has_startindex();
  inline void set_has_endindex();
  inline void clear_has_endindex();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headstring();
  inline void clear_has_headstring();
  inline void set_has_nerstring();
  inline void clear_has_nerstring();
  inline void set_has_originalref();
  inline void clear_has_originalref();
  inline void set_has_goldcorefclusterid();
  inline void clear_has_goldcorefclusterid();
  inline void set_has_corefclusterid();
  inline void clear_has_corefclusterid();
  inline void set_has_mentionnum();
  inline void clear_has_mentionnum();
  inline void set_has_sentnum();
  inline void clear_has_sentnum();
  inline void set_has_utter();
  inline void clear_has_utter();
  inline void set_has_paragraph();
  inline void clear_has_paragraph();
  inline void set_has_issubject();
  inline void clear_has_issubject();
  inline void set_has_isdirectobject();
  inline void clear_has_isdirectobject();
  inline void set_has_isindirectobject();
  inline void clear_has_isindirectobject();
  inline void set_has_isprepositionobject();
  inline void clear_has_isprepositionobject();
  inline void set_has_hastwin();
  inline void clear_has_hastwin();
  inline void set_has_generic();
  inline void clear_has_generic();
  inline void set_has_issingleton();
  inline void clear_has_issingleton();
  inline void set_has_hasbasicdependency();
  inline void clear_has_hasbasicdependency();
  inline void set_has_hascollapseddependency();
  inline void clear_has_hascollapseddependency();
  inline void set_has_hascontextparsetree();
  inline void clear_has_hascontextparsetree();
  inline void set_has_headindexedword();
  inline void clear_has_headindexedword();
  inline void set_has_dependingverb();
  inline void clear_has_dependingverb();
  inline void set_has_headword();
  inline void clear_has_headword();
  inline void set_has_speakerinfo();
  inline void clear_has_speakerinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[2];
  ::google::protobuf::internal::ArenaStringPtr mentiontype_;
  ::google::protobuf::internal::ArenaStringPtr number_;
  ::google::protobuf::internal::ArenaStringPtr gender_;
  ::google::protobuf::int32 mentionid_;
  ::google::protobuf::uint32 startindex_;
  ::google::protobuf::internal::ArenaStringPtr animacy_;
  ::google::protobuf::internal::ArenaStringPtr person_;
  ::google::protobuf::uint32 endindex_;
  ::google::protobuf::uint32 headindex_;
  ::google::protobuf::internal::ArenaStringPtr headstring_;
  ::google::protobuf::internal::ArenaStringPtr nerstring_;
  ::google::protobuf::uint32 originalref_;
  ::google::protobuf::int32 goldcorefclusterid_;
  ::google::protobuf::int32 corefclusterid_;
  ::google::protobuf::uint32 mentionnum_;
  ::google::protobuf::uint32 sentnum_;
  ::google::protobuf::uint32 utter_;
  ::google::protobuf::uint32 paragraph_;
  bool issubject_;
  bool isdirectobject_;
  bool isindirectobject_;
  bool isprepositionobject_;
  bool hastwin_;
  bool generic_;
  bool issingleton_;
  bool hasbasicdependency_;
  bool hascollapseddependency_;
  bool hascontextparsetree_;
  ::edu::stanford::nlp::pipeline::IndexedWord* headindexedword_;
  ::edu::stanford::nlp::pipeline::IndexedWord* dependingverb_;
  ::edu::stanford::nlp::pipeline::IndexedWord* headword_;
  ::edu::stanford::nlp::pipeline::SpeakerInfo* speakerinfo_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord > sentencewords_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord > originalspan_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dependents_;
  ::google::protobuf::RepeatedPtrField< ::std::string> preprocessedterms_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > appositions_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > predicatenominatives_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > relativepronouns_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > listmembers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > belongtolists_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Mention* default_instance_;
};
// -------------------------------------------------------------------

class IndexedWord : public ::google::protobuf::Message {
 public:
  IndexedWord();
  virtual ~IndexedWord();

  IndexedWord(const IndexedWord& from);

  inline IndexedWord& operator=(const IndexedWord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexedWord& default_instance();

  void Swap(IndexedWord* other);

  // implements Message ----------------------------------------------

  inline IndexedWord* New() const { return New(NULL); }

  IndexedWord* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexedWord& from);
  void MergeFrom(const IndexedWord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IndexedWord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sentenceNum = 1;
  bool has_sentencenum() const;
  void clear_sentencenum();
  static const int kSentenceNumFieldNumber = 1;
  ::google::protobuf::uint32 sentencenum() const;
  void set_sentencenum(::google::protobuf::uint32 value);

  // optional uint32 tokenIndex = 2;
  bool has_tokenindex() const;
  void clear_tokenindex();
  static const int kTokenIndexFieldNumber = 2;
  ::google::protobuf::uint32 tokenindex() const;
  void set_tokenindex(::google::protobuf::uint32 value);

  // optional uint32 docID = 3;
  bool has_docid() const;
  void clear_docid();
  static const int kDocIDFieldNumber = 3;
  ::google::protobuf::uint32 docid() const;
  void set_docid(::google::protobuf::uint32 value);

  // optional uint32 copyCount = 4;
  bool has_copycount() const;
  void clear_copycount();
  static const int kCopyCountFieldNumber = 4;
  ::google::protobuf::uint32 copycount() const;
  void set_copycount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.IndexedWord)
 private:
  inline void set_has_sentencenum();
  inline void clear_has_sentencenum();
  inline void set_has_tokenindex();
  inline void clear_has_tokenindex();
  inline void set_has_docid();
  inline void clear_has_docid();
  inline void set_has_copycount();
  inline void clear_has_copycount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sentencenum_;
  ::google::protobuf::uint32 tokenindex_;
  ::google::protobuf::uint32 docid_;
  ::google::protobuf::uint32 copycount_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static IndexedWord* default_instance_;
};
// -------------------------------------------------------------------

class SpeakerInfo : public ::google::protobuf::Message {
 public:
  SpeakerInfo();
  virtual ~SpeakerInfo();

  SpeakerInfo(const SpeakerInfo& from);

  inline SpeakerInfo& operator=(const SpeakerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeakerInfo& default_instance();

  void Swap(SpeakerInfo* other);

  // implements Message ----------------------------------------------

  inline SpeakerInfo* New() const { return New(NULL); }

  SpeakerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeakerInfo& from);
  void MergeFrom(const SpeakerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SpeakerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string speakerName = 1;
  bool has_speakername() const;
  void clear_speakername();
  static const int kSpeakerNameFieldNumber = 1;
  const ::std::string& speakername() const;
  void set_speakername(const ::std::string& value);
  void set_speakername(const char* value);
  void set_speakername(const char* value, size_t size);
  ::std::string* mutable_speakername();
  ::std::string* release_speakername();
  void set_allocated_speakername(::std::string* speakername);

  // repeated int32 mentions = 2;
  int mentions_size() const;
  void clear_mentions();
  static const int kMentionsFieldNumber = 2;
  ::google::protobuf::int32 mentions(int index) const;
  void set_mentions(int index, ::google::protobuf::int32 value);
  void add_mentions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      mentions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_mentions();

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.SpeakerInfo)
 private:
  inline void set_has_speakername();
  inline void clear_has_speakername();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr speakername_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > mentions_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static SpeakerInfo* default_instance_;
};
// -------------------------------------------------------------------

class Span : public ::google::protobuf::Message {
 public:
  Span();
  virtual ~Span();

  Span(const Span& from);

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Span& default_instance();

  void Swap(Span* other);

  // implements Message ----------------------------------------------

  inline Span* New() const { return New(NULL); }

  Span* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Span& from);
  void MergeFrom(const Span& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 begin = 1;
  bool has_begin() const;
  void clear_begin();
  static const int kBeginFieldNumber = 1;
  ::google::protobuf::uint32 begin() const;
  void set_begin(::google::protobuf::uint32 value);

  // required uint32 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::uint32 end() const;
  void set_end(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Span)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 begin_;
  ::google::protobuf::uint32 end_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Span* default_instance_;
};
// -------------------------------------------------------------------

class Timex : public ::google::protobuf::Message {
 public:
  Timex();
  virtual ~Timex();

  Timex(const Timex& from);

  inline Timex& operator=(const Timex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Timex& default_instance();

  void Swap(Timex* other);

  // implements Message ----------------------------------------------

  inline Timex* New() const { return New(NULL); }

  Timex* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timex& from);
  void MergeFrom(const Timex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Timex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional string altValue = 2;
  bool has_altvalue() const;
  void clear_altvalue();
  static const int kAltValueFieldNumber = 2;
  const ::std::string& altvalue() const;
  void set_altvalue(const ::std::string& value);
  void set_altvalue(const char* value);
  void set_altvalue(const char* value, size_t size);
  ::std::string* mutable_altvalue();
  ::std::string* release_altvalue();
  void set_allocated_altvalue(::std::string* altvalue);

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string tid = 5;
  bool has_tid() const;
  void clear_tid();
  static const int kTidFieldNumber = 5;
  const ::std::string& tid() const;
  void set_tid(const ::std::string& value);
  void set_tid(const char* value);
  void set_tid(const char* value, size_t size);
  ::std::string* mutable_tid();
  ::std::string* release_tid();
  void set_allocated_tid(::std::string* tid);

  // optional uint32 beginPoint = 6;
  bool has_beginpoint() const;
  void clear_beginpoint();
  static const int kBeginPointFieldNumber = 6;
  ::google::protobuf::uint32 beginpoint() const;
  void set_beginpoint(::google::protobuf::uint32 value);

  // optional uint32 endPoint = 7;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndPointFieldNumber = 7;
  ::google::protobuf::uint32 endpoint() const;
  void set_endpoint(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Timex)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_altvalue();
  inline void clear_has_altvalue();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_beginpoint();
  inline void clear_has_beginpoint();
  inline void set_has_endpoint();
  inline void clear_has_endpoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr altvalue_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr tid_;
  ::google::protobuf::uint32 beginpoint_;
  ::google::protobuf::uint32 endpoint_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Timex* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  inline Entity* New() const { return New(NULL); }

  Entity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 headStart = 6;
  bool has_headstart() const;
  void clear_headstart();
  static const int kHeadStartFieldNumber = 6;
  ::google::protobuf::uint32 headstart() const;
  void set_headstart(::google::protobuf::uint32 value);

  // optional uint32 headEnd = 7;
  bool has_headend() const;
  void clear_headend();
  static const int kHeadEndFieldNumber = 7;
  ::google::protobuf::uint32 headend() const;
  void set_headend(::google::protobuf::uint32 value);

  // optional string mentionType = 8;
  bool has_mentiontype() const;
  void clear_mentiontype();
  static const int kMentionTypeFieldNumber = 8;
  const ::std::string& mentiontype() const;
  void set_mentiontype(const ::std::string& value);
  void set_mentiontype(const char* value);
  void set_mentiontype(const char* value, size_t size);
  ::std::string* mutable_mentiontype();
  ::std::string* release_mentiontype();
  void set_allocated_mentiontype(::std::string* mentiontype);

  // optional string normalizedName = 9;
  bool has_normalizedname() const;
  void clear_normalizedname();
  static const int kNormalizedNameFieldNumber = 9;
  const ::std::string& normalizedname() const;
  void set_normalizedname(const ::std::string& value);
  void set_normalizedname(const char* value);
  void set_normalizedname(const char* value, size_t size);
  ::std::string* mutable_normalizedname();
  ::std::string* release_normalizedname();
  void set_allocated_normalizedname(::std::string* normalizedname);

  // optional uint32 headTokenIndex = 10;
  bool has_headtokenindex() const;
  void clear_headtokenindex();
  static const int kHeadTokenIndexFieldNumber = 10;
  ::google::protobuf::uint32 headtokenindex() const;
  void set_headtokenindex(::google::protobuf::uint32 value);

  // optional string corefID = 11;
  bool has_corefid() const;
  void clear_corefid();
  static const int kCorefIDFieldNumber = 11;
  const ::std::string& corefid() const;
  void set_corefid(const ::std::string& value);
  void set_corefid(const char* value);
  void set_corefid(const char* value, size_t size);
  ::std::string* mutable_corefid();
  ::std::string* release_corefid();
  void set_allocated_corefid(::std::string* corefid);

  // optional string objectID = 1;
  bool has_objectid() const;
  void clear_objectid();
  static const int kObjectIDFieldNumber = 1;
  const ::std::string& objectid() const;
  void set_objectid(const ::std::string& value);
  void set_objectid(const char* value);
  void set_objectid(const char* value, size_t size);
  ::std::string* mutable_objectid();
  ::std::string* release_objectid();
  void set_allocated_objectid(::std::string* objectid);

  // optional uint32 extentStart = 2;
  bool has_extentstart() const;
  void clear_extentstart();
  static const int kExtentStartFieldNumber = 2;
  ::google::protobuf::uint32 extentstart() const;
  void set_extentstart(::google::protobuf::uint32 value);

  // optional uint32 extentEnd = 3;
  bool has_extentend() const;
  void clear_extentend();
  static const int kExtentEndFieldNumber = 3;
  ::google::protobuf::uint32 extentend() const;
  void set_extentend(::google::protobuf::uint32 value);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string subtype = 5;
  bool has_subtype() const;
  void clear_subtype();
  static const int kSubtypeFieldNumber = 5;
  const ::std::string& subtype() const;
  void set_subtype(const ::std::string& value);
  void set_subtype(const char* value);
  void set_subtype(const char* value, size_t size);
  ::std::string* mutable_subtype();
  ::std::string* release_subtype();
  void set_allocated_subtype(::std::string* subtype);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Entity)
 private:
  inline void set_has_headstart();
  inline void clear_has_headstart();
  inline void set_has_headend();
  inline void clear_has_headend();
  inline void set_has_mentiontype();
  inline void clear_has_mentiontype();
  inline void set_has_normalizedname();
  inline void clear_has_normalizedname();
  inline void set_has_headtokenindex();
  inline void clear_has_headtokenindex();
  inline void set_has_corefid();
  inline void clear_has_corefid();
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_extentstart();
  inline void clear_has_extentstart();
  inline void set_has_extentend();
  inline void clear_has_extentend();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 headstart_;
  ::google::protobuf::uint32 headend_;
  ::google::protobuf::internal::ArenaStringPtr mentiontype_;
  ::google::protobuf::internal::ArenaStringPtr normalizedname_;
  ::google::protobuf::internal::ArenaStringPtr corefid_;
  ::google::protobuf::uint32 headtokenindex_;
  ::google::protobuf::uint32 extentstart_;
  ::google::protobuf::internal::ArenaStringPtr objectid_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr subtype_;
  ::google::protobuf::uint32 extentend_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class Relation : public ::google::protobuf::Message {
 public:
  Relation();
  virtual ~Relation();

  Relation(const Relation& from);

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Relation& default_instance();

  void Swap(Relation* other);

  // implements Message ----------------------------------------------

  inline Relation* New() const { return New(NULL); }

  Relation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Relation& from);
  void MergeFrom(const Relation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Relation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string argName = 6;
  int argname_size() const;
  void clear_argname();
  static const int kArgNameFieldNumber = 6;
  const ::std::string& argname(int index) const;
  ::std::string* mutable_argname(int index);
  void set_argname(int index, const ::std::string& value);
  void set_argname(int index, const char* value);
  void set_argname(int index, const char* value, size_t size);
  ::std::string* add_argname();
  void add_argname(const ::std::string& value);
  void add_argname(const char* value);
  void add_argname(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& argname() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_argname();

  // repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 7;
  const ::edu::stanford::nlp::pipeline::Entity& arg(int index) const;
  ::edu::stanford::nlp::pipeline::Entity* mutable_arg(int index);
  ::edu::stanford::nlp::pipeline::Entity* add_arg();
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >&
      arg() const;

  // optional string signature = 8;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 8;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional string objectID = 1;
  bool has_objectid() const;
  void clear_objectid();
  static const int kObjectIDFieldNumber = 1;
  const ::std::string& objectid() const;
  void set_objectid(const ::std::string& value);
  void set_objectid(const char* value);
  void set_objectid(const char* value, size_t size);
  ::std::string* mutable_objectid();
  ::std::string* release_objectid();
  void set_allocated_objectid(::std::string* objectid);

  // optional uint32 extentStart = 2;
  bool has_extentstart() const;
  void clear_extentstart();
  static const int kExtentStartFieldNumber = 2;
  ::google::protobuf::uint32 extentstart() const;
  void set_extentstart(::google::protobuf::uint32 value);

  // optional uint32 extentEnd = 3;
  bool has_extentend() const;
  void clear_extentend();
  static const int kExtentEndFieldNumber = 3;
  ::google::protobuf::uint32 extentend() const;
  void set_extentend(::google::protobuf::uint32 value);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string subtype = 5;
  bool has_subtype() const;
  void clear_subtype();
  static const int kSubtypeFieldNumber = 5;
  const ::std::string& subtype() const;
  void set_subtype(const ::std::string& value);
  void set_subtype(const char* value);
  void set_subtype(const char* value, size_t size);
  ::std::string* mutable_subtype();
  ::std::string* release_subtype();
  void set_allocated_subtype(::std::string* subtype);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Relation)
 private:
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_extentstart();
  inline void clear_has_extentstart();
  inline void set_has_extentend();
  inline void clear_has_extentend();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> argname_;
  ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity > arg_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr objectid_;
  ::google::protobuf::uint32 extentstart_;
  ::google::protobuf::uint32 extentend_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr subtype_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Relation* default_instance_;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::Message {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operator& default_instance();

  void Swap(Operator* other);

  // implements Message ----------------------------------------------

  inline Operator* New() const { return New(NULL); }

  Operator* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 quantifierSpanBegin = 2;
  bool has_quantifierspanbegin() const;
  void clear_quantifierspanbegin();
  static const int kQuantifierSpanBeginFieldNumber = 2;
  ::google::protobuf::int32 quantifierspanbegin() const;
  void set_quantifierspanbegin(::google::protobuf::int32 value);

  // required int32 quantifierSpanEnd = 3;
  bool has_quantifierspanend() const;
  void clear_quantifierspanend();
  static const int kQuantifierSpanEndFieldNumber = 3;
  ::google::protobuf::int32 quantifierspanend() const;
  void set_quantifierspanend(::google::protobuf::int32 value);

  // required int32 subjectSpanBegin = 4;
  bool has_subjectspanbegin() const;
  void clear_subjectspanbegin();
  static const int kSubjectSpanBeginFieldNumber = 4;
  ::google::protobuf::int32 subjectspanbegin() const;
  void set_subjectspanbegin(::google::protobuf::int32 value);

  // required int32 subjectSpanEnd = 5;
  bool has_subjectspanend() const;
  void clear_subjectspanend();
  static const int kSubjectSpanEndFieldNumber = 5;
  ::google::protobuf::int32 subjectspanend() const;
  void set_subjectspanend(::google::protobuf::int32 value);

  // required int32 objectSpanBegin = 6;
  bool has_objectspanbegin() const;
  void clear_objectspanbegin();
  static const int kObjectSpanBeginFieldNumber = 6;
  ::google::protobuf::int32 objectspanbegin() const;
  void set_objectspanbegin(::google::protobuf::int32 value);

  // required int32 objectSpanEnd = 7;
  bool has_objectspanend() const;
  void clear_objectspanend();
  static const int kObjectSpanEndFieldNumber = 7;
  ::google::protobuf::int32 objectspanend() const;
  void set_objectspanend(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Operator)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_quantifierspanbegin();
  inline void clear_has_quantifierspanbegin();
  inline void set_has_quantifierspanend();
  inline void clear_has_quantifierspanend();
  inline void set_has_subjectspanbegin();
  inline void clear_has_subjectspanbegin();
  inline void set_has_subjectspanend();
  inline void clear_has_subjectspanend();
  inline void set_has_objectspanbegin();
  inline void clear_has_objectspanbegin();
  inline void set_has_objectspanend();
  inline void clear_has_objectspanend();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 quantifierspanbegin_;
  ::google::protobuf::int32 quantifierspanend_;
  ::google::protobuf::int32 subjectspanbegin_;
  ::google::protobuf::int32 subjectspanend_;
  ::google::protobuf::int32 objectspanbegin_;
  ::google::protobuf::int32 objectspanend_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Operator* default_instance_;
};
// -------------------------------------------------------------------

class Polarity : public ::google::protobuf::Message {
 public:
  Polarity();
  virtual ~Polarity();

  Polarity(const Polarity& from);

  inline Polarity& operator=(const Polarity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polarity& default_instance();

  void Swap(Polarity* other);

  // implements Message ----------------------------------------------

  inline Polarity* New() const { return New(NULL); }

  Polarity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polarity& from);
  void MergeFrom(const Polarity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Polarity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
  bool has_projectequivalence() const;
  void clear_projectequivalence();
  static const int kProjectEquivalenceFieldNumber = 1;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectequivalence() const;
  void set_projectequivalence(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
  bool has_projectforwardentailment() const;
  void clear_projectforwardentailment();
  static const int kProjectForwardEntailmentFieldNumber = 2;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectforwardentailment() const;
  void set_projectforwardentailment(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
  bool has_projectreverseentailment() const;
  void clear_projectreverseentailment();
  static const int kProjectReverseEntailmentFieldNumber = 3;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectreverseentailment() const;
  void set_projectreverseentailment(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
  bool has_projectnegation() const;
  void clear_projectnegation();
  static const int kProjectNegationFieldNumber = 4;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectnegation() const;
  void set_projectnegation(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
  bool has_projectalternation() const;
  void clear_projectalternation();
  static const int kProjectAlternationFieldNumber = 5;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectalternation() const;
  void set_projectalternation(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
  bool has_projectcover() const;
  void clear_projectcover();
  static const int kProjectCoverFieldNumber = 6;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectcover() const;
  void set_projectcover(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
  bool has_projectindependence() const;
  void clear_projectindependence();
  static const int kProjectIndependenceFieldNumber = 7;
  ::edu::stanford::nlp::pipeline::NaturalLogicRelation projectindependence() const;
  void set_projectindependence(::edu::stanford::nlp::pipeline::NaturalLogicRelation value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.Polarity)
 private:
  inline void set_has_projectequivalence();
  inline void clear_has_projectequivalence();
  inline void set_has_projectforwardentailment();
  inline void clear_has_projectforwardentailment();
  inline void set_has_projectreverseentailment();
  inline void clear_has_projectreverseentailment();
  inline void set_has_projectnegation();
  inline void clear_has_projectnegation();
  inline void set_has_projectalternation();
  inline void clear_has_projectalternation();
  inline void set_has_projectcover();
  inline void clear_has_projectcover();
  inline void set_has_projectindependence();
  inline void clear_has_projectindependence();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int projectequivalence_;
  int projectforwardentailment_;
  int projectreverseentailment_;
  int projectnegation_;
  int projectalternation_;
  int projectcover_;
  int projectindependence_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static Polarity* default_instance_;
};
// -------------------------------------------------------------------

class NERMention : public ::google::protobuf::Message {
 public:
  NERMention();
  virtual ~NERMention();

  NERMention(const NERMention& from);

  inline NERMention& operator=(const NERMention& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NERMention& default_instance();

  void Swap(NERMention* other);

  // implements Message ----------------------------------------------

  inline NERMention* New() const { return New(NULL); }

  NERMention* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NERMention& from);
  void MergeFrom(const NERMention& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NERMention* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sentenceIndex = 1;
  bool has_sentenceindex() const;
  void clear_sentenceindex();
  static const int kSentenceIndexFieldNumber = 1;
  ::google::protobuf::uint32 sentenceindex() const;
  void set_sentenceindex(::google::protobuf::uint32 value);

  // required uint32 tokenStartInSentenceInclusive = 2;
  bool has_tokenstartinsentenceinclusive() const;
  void clear_tokenstartinsentenceinclusive();
  static const int kTokenStartInSentenceInclusiveFieldNumber = 2;
  ::google::protobuf::uint32 tokenstartinsentenceinclusive() const;
  void set_tokenstartinsentenceinclusive(::google::protobuf::uint32 value);

  // required uint32 tokenEndInSentenceExclusive = 3;
  bool has_tokenendinsentenceexclusive() const;
  void clear_tokenendinsentenceexclusive();
  static const int kTokenEndInSentenceExclusiveFieldNumber = 3;
  ::google::protobuf::uint32 tokenendinsentenceexclusive() const;
  void set_tokenendinsentenceexclusive(::google::protobuf::uint32 value);

  // required string ner = 4;
  bool has_ner() const;
  void clear_ner();
  static const int kNerFieldNumber = 4;
  const ::std::string& ner() const;
  void set_ner(const ::std::string& value);
  void set_ner(const char* value);
  void set_ner(const char* value, size_t size);
  ::std::string* mutable_ner();
  ::std::string* release_ner();
  void set_allocated_ner(::std::string* ner);

  // optional string normalizedNER = 5;
  bool has_normalizedner() const;
  void clear_normalizedner();
  static const int kNormalizedNERFieldNumber = 5;
  const ::std::string& normalizedner() const;
  void set_normalizedner(const ::std::string& value);
  void set_normalizedner(const char* value);
  void set_normalizedner(const char* value, size_t size);
  ::std::string* mutable_normalizedner();
  ::std::string* release_normalizedner();
  void set_allocated_normalizedner(::std::string* normalizedner);

  // optional string entityType = 6;
  bool has_entitytype() const;
  void clear_entitytype();
  static const int kEntityTypeFieldNumber = 6;
  const ::std::string& entitytype() const;
  void set_entitytype(const ::std::string& value);
  void set_entitytype(const char* value);
  void set_entitytype(const char* value, size_t size);
  ::std::string* mutable_entitytype();
  ::std::string* release_entitytype();
  void set_allocated_entitytype(::std::string* entitytype);

  // optional .edu.stanford.nlp.pipeline.Timex timex = 7;
  bool has_timex() const;
  void clear_timex();
  static const int kTimexFieldNumber = 7;
  const ::edu::stanford::nlp::pipeline::Timex& timex() const;
  ::edu::stanford::nlp::pipeline::Timex* mutable_timex();
  ::edu::stanford::nlp::pipeline::Timex* release_timex();
  void set_allocated_timex(::edu::stanford::nlp::pipeline::Timex* timex);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.NERMention)
 private:
  inline void set_has_sentenceindex();
  inline void clear_has_sentenceindex();
  inline void set_has_tokenstartinsentenceinclusive();
  inline void clear_has_tokenstartinsentenceinclusive();
  inline void set_has_tokenendinsentenceexclusive();
  inline void clear_has_tokenendinsentenceexclusive();
  inline void set_has_ner();
  inline void clear_has_ner();
  inline void set_has_normalizedner();
  inline void clear_has_normalizedner();
  inline void set_has_entitytype();
  inline void clear_has_entitytype();
  inline void set_has_timex();
  inline void clear_has_timex();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sentenceindex_;
  ::google::protobuf::uint32 tokenstartinsentenceinclusive_;
  ::google::protobuf::internal::ArenaStringPtr ner_;
  ::google::protobuf::internal::ArenaStringPtr normalizedner_;
  ::google::protobuf::internal::ArenaStringPtr entitytype_;
  ::edu::stanford::nlp::pipeline::Timex* timex_;
  ::google::protobuf::uint32 tokenendinsentenceexclusive_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static NERMention* default_instance_;
};
// -------------------------------------------------------------------

class SentenceFragment : public ::google::protobuf::Message {
 public:
  SentenceFragment();
  virtual ~SentenceFragment();

  SentenceFragment(const SentenceFragment& from);

  inline SentenceFragment& operator=(const SentenceFragment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SentenceFragment& default_instance();

  void Swap(SentenceFragment* other);

  // implements Message ----------------------------------------------

  inline SentenceFragment* New() const { return New(NULL); }

  SentenceFragment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SentenceFragment& from);
  void MergeFrom(const SentenceFragment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SentenceFragment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 tokenIndex = 1;
  int tokenindex_size() const;
  void clear_tokenindex();
  static const int kTokenIndexFieldNumber = 1;
  ::google::protobuf::uint32 tokenindex(int index) const;
  void set_tokenindex(int index, ::google::protobuf::uint32 value);
  void add_tokenindex(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tokenindex() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tokenindex();

  // optional uint32 root = 2;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 2;
  ::google::protobuf::uint32 root() const;
  void set_root(::google::protobuf::uint32 value);

  // optional bool assumedTruth = 3;
  bool has_assumedtruth() const;
  void clear_assumedtruth();
  static const int kAssumedTruthFieldNumber = 3;
  bool assumedtruth() const;
  void set_assumedtruth(bool value);

  // optional double score = 4;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  double score() const;
  void set_score(double value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.SentenceFragment)
 private:
  inline void set_has_root();
  inline void clear_has_root();
  inline void set_has_assumedtruth();
  inline void clear_has_assumedtruth();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tokenindex_;
  ::google::protobuf::uint32 root_;
  bool assumedtruth_;
  double score_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static SentenceFragment* default_instance_;
};
// -------------------------------------------------------------------

class RelationTriple : public ::google::protobuf::Message {
 public:
  RelationTriple();
  virtual ~RelationTriple();

  RelationTriple(const RelationTriple& from);

  inline RelationTriple& operator=(const RelationTriple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelationTriple& default_instance();

  void Swap(RelationTriple* other);

  // implements Message ----------------------------------------------

  inline RelationTriple* New() const { return New(NULL); }

  RelationTriple* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RelationTriple& from);
  void MergeFrom(const RelationTriple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelationTriple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string subject = 1;
  bool has_subject() const;
  void clear_subject();
  static const int kSubjectFieldNumber = 1;
  const ::std::string& subject() const;
  void set_subject(const ::std::string& value);
  void set_subject(const char* value);
  void set_subject(const char* value, size_t size);
  ::std::string* mutable_subject();
  ::std::string* release_subject();
  void set_allocated_subject(::std::string* subject);

  // optional string relation = 2;
  bool has_relation() const;
  void clear_relation();
  static const int kRelationFieldNumber = 2;
  const ::std::string& relation() const;
  void set_relation(const ::std::string& value);
  void set_relation(const char* value);
  void set_relation(const char* value, size_t size);
  ::std::string* mutable_relation();
  ::std::string* release_relation();
  void set_allocated_relation(::std::string* relation);

  // optional string object = 3;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 3;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // optional double confidence = 4;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  double confidence() const;
  void set_confidence(double value);

  // repeated uint32 subjectTokens = 5;
  int subjecttokens_size() const;
  void clear_subjecttokens();
  static const int kSubjectTokensFieldNumber = 5;
  ::google::protobuf::uint32 subjecttokens(int index) const;
  void set_subjecttokens(int index, ::google::protobuf::uint32 value);
  void add_subjecttokens(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      subjecttokens() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_subjecttokens();

  // repeated uint32 relationTokens = 6;
  int relationtokens_size() const;
  void clear_relationtokens();
  static const int kRelationTokensFieldNumber = 6;
  ::google::protobuf::uint32 relationtokens(int index) const;
  void set_relationtokens(int index, ::google::protobuf::uint32 value);
  void add_relationtokens(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      relationtokens() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_relationtokens();

  // repeated uint32 objectTokens = 7;
  int objecttokens_size() const;
  void clear_objecttokens();
  static const int kObjectTokensFieldNumber = 7;
  ::google::protobuf::uint32 objecttokens(int index) const;
  void set_objecttokens(int index, ::google::protobuf::uint32 value);
  void add_objecttokens(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      objecttokens() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_objecttokens();

  // optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
  bool has_tree() const;
  void clear_tree();
  static const int kTreeFieldNumber = 8;
  const ::edu::stanford::nlp::pipeline::DependencyGraph& tree() const;
  ::edu::stanford::nlp::pipeline::DependencyGraph* mutable_tree();
  ::edu::stanford::nlp::pipeline::DependencyGraph* release_tree();
  void set_allocated_tree(::edu::stanford::nlp::pipeline::DependencyGraph* tree);

  // optional bool istmod = 9;
  bool has_istmod() const;
  void clear_istmod();
  static const int kIstmodFieldNumber = 9;
  bool istmod() const;
  void set_istmod(bool value);

  // optional bool prefixBe = 10;
  bool has_prefixbe() const;
  void clear_prefixbe();
  static const int kPrefixBeFieldNumber = 10;
  bool prefixbe() const;
  void set_prefixbe(bool value);

  // optional bool suffixBe = 11;
  bool has_suffixbe() const;
  void clear_suffixbe();
  static const int kSuffixBeFieldNumber = 11;
  bool suffixbe() const;
  void set_suffixbe(bool value);

  // optional bool suffixOf = 12;
  bool has_suffixof() const;
  void clear_suffixof();
  static const int kSuffixOfFieldNumber = 12;
  bool suffixof() const;
  void set_suffixof(bool value);

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.RelationTriple)
 private:
  inline void set_has_subject();
  inline void clear_has_subject();
  inline void set_has_relation();
  inline void clear_has_relation();
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_tree();
  inline void clear_has_tree();
  inline void set_has_istmod();
  inline void clear_has_istmod();
  inline void set_has_prefixbe();
  inline void clear_has_prefixbe();
  inline void set_has_suffixbe();
  inline void clear_has_suffixbe();
  inline void set_has_suffixof();
  inline void clear_has_suffixof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr subject_;
  ::google::protobuf::internal::ArenaStringPtr relation_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  double confidence_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > subjecttokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > relationtokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > objecttokens_;
  ::edu::stanford::nlp::pipeline::DependencyGraph* tree_;
  bool istmod_;
  bool prefixbe_;
  bool suffixbe_;
  bool suffixof_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static RelationTriple* default_instance_;
};
// -------------------------------------------------------------------

class MapStringString : public ::google::protobuf::Message {
 public:
  MapStringString();
  virtual ~MapStringString();

  MapStringString(const MapStringString& from);

  inline MapStringString& operator=(const MapStringString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapStringString& default_instance();

  void Swap(MapStringString* other);

  // implements Message ----------------------------------------------

  inline MapStringString* New() const { return New(NULL); }

  MapStringString* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapStringString& from);
  void MergeFrom(const MapStringString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapStringString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string key = 1;
  int key_size() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key(int index) const;
  ::std::string* mutable_key(int index);
  void set_key(int index, const ::std::string& value);
  void set_key(int index, const char* value);
  void set_key(int index, const char* value, size_t size);
  ::std::string* add_key();
  void add_key(const ::std::string& value);
  void add_key(const char* value);
  void add_key(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();

  // repeated string value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.MapStringString)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static MapStringString* default_instance_;
};
// -------------------------------------------------------------------

class MapIntString : public ::google::protobuf::Message {
 public:
  MapIntString();
  virtual ~MapIntString();

  MapIntString(const MapIntString& from);

  inline MapIntString& operator=(const MapIntString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapIntString& default_instance();

  void Swap(MapIntString* other);

  // implements Message ----------------------------------------------

  inline MapIntString* New() const { return New(NULL); }

  MapIntString* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapIntString& from);
  void MergeFrom(const MapIntString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapIntString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 key = 1;
  int key_size() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint32 key(int index) const;
  void set_key(int index, ::google::protobuf::uint32 value);
  void add_key(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      key() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_key();

  // repeated string value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:edu.stanford.nlp.pipeline.MapIntString)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  friend void  protobuf_AddDesc_CoreNLP_2eproto();
  friend void protobuf_AssignDesc_CoreNLP_2eproto();
  friend void protobuf_ShutdownFile_CoreNLP_2eproto();

  void InitAsDefaultInstance();
  static MapIntString* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Document

// required string text = 1;
inline bool Document::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Document::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Document::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Document::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Document::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Document::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Document.text)
}
inline void Document::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Document.text)
}
inline void Document::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Document.text)
}
inline ::std::string* Document::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Document::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Document::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Document.text)
}

// repeated .edu.stanford.nlp.pipeline.Sentence sentence = 2;
inline int Document::sentence_size() const {
  return sentence_.size();
}
inline void Document::clear_sentence() {
  sentence_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Sentence& Document::sentence(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Sentence* Document::mutable_sentence(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Sentence* Document::add_sentence() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence >*
Document::mutable_sentence() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.sentence)
  return &sentence_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Sentence >&
Document::sentence() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.sentence)
  return sentence_;
}

// repeated .edu.stanford.nlp.pipeline.CorefChain corefChain = 3;
inline int Document::corefchain_size() const {
  return corefchain_.size();
}
inline void Document::clear_corefchain() {
  corefchain_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::CorefChain& Document::corefchain(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::CorefChain* Document::mutable_corefchain(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::CorefChain* Document::add_corefchain() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain >*
Document::mutable_corefchain() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.corefChain)
  return &corefchain_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain >&
Document::corefchain() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.corefChain)
  return corefchain_;
}

// optional string docID = 4;
inline bool Document::has_docid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Document::set_has_docid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Document::clear_has_docid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Document::clear_docid() {
  docid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docid();
}
inline const ::std::string& Document::docid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.docID)
  return docid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Document::set_docid(const ::std::string& value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Document.docID)
}
inline void Document::set_docid(const char* value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Document.docID)
}
inline void Document::set_docid(const char* value, size_t size) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Document.docID)
}
inline ::std::string* Document::mutable_docid() {
  set_has_docid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.docID)
  return docid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Document::release_docid() {
  clear_has_docid();
  return docid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Document::set_allocated_docid(::std::string* docid) {
  if (docid != NULL) {
    set_has_docid();
  } else {
    clear_has_docid();
  }
  docid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Document.docID)
}

// repeated .edu.stanford.nlp.pipeline.Token sentencelessToken = 5;
inline int Document::sentencelesstoken_size() const {
  return sentencelesstoken_.size();
}
inline void Document::clear_sentencelesstoken() {
  sentencelesstoken_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Token& Document::sentencelesstoken(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Token* Document::mutable_sentencelesstoken(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Token* Document::add_sentencelesstoken() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >*
Document::mutable_sentencelesstoken() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return &sentencelesstoken_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >&
Document::sentencelesstoken() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.sentencelessToken)
  return sentencelesstoken_;
}

// repeated .edu.stanford.nlp.pipeline.Quote quote = 6;
inline int Document::quote_size() const {
  return quote_.size();
}
inline void Document::clear_quote() {
  quote_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Quote& Document::quote(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Document.quote)
  return quote_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Quote* Document::mutable_quote(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Document.quote)
  return quote_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Quote* Document::add_quote() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Document.quote)
  return quote_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote >*
Document::mutable_quote() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Document.quote)
  return &quote_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Quote >&
Document::quote() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Document.quote)
  return quote_;
}

// -------------------------------------------------------------------

// Sentence

// repeated .edu.stanford.nlp.pipeline.Token token = 1;
inline int Sentence::token_size() const {
  return token_.size();
}
inline void Sentence::clear_token() {
  token_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Token& Sentence::token(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.token)
  return token_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Token* Sentence::mutable_token(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.token)
  return token_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Token* Sentence::add_token() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.token)
  return token_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >*
Sentence::mutable_token() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.token)
  return &token_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Token >&
Sentence::token() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.token)
  return token_;
}

// required uint32 tokenOffsetBegin = 2;
inline bool Sentence::has_tokenoffsetbegin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sentence::set_has_tokenoffsetbegin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sentence::clear_has_tokenoffsetbegin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sentence::clear_tokenoffsetbegin() {
  tokenoffsetbegin_ = 0u;
  clear_has_tokenoffsetbegin();
}
inline ::google::protobuf::uint32 Sentence::tokenoffsetbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.tokenOffsetBegin)
  return tokenoffsetbegin_;
}
inline void Sentence::set_tokenoffsetbegin(::google::protobuf::uint32 value) {
  set_has_tokenoffsetbegin();
  tokenoffsetbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.tokenOffsetBegin)
}

// required uint32 tokenOffsetEnd = 3;
inline bool Sentence::has_tokenoffsetend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sentence::set_has_tokenoffsetend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sentence::clear_has_tokenoffsetend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sentence::clear_tokenoffsetend() {
  tokenoffsetend_ = 0u;
  clear_has_tokenoffsetend();
}
inline ::google::protobuf::uint32 Sentence::tokenoffsetend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.tokenOffsetEnd)
  return tokenoffsetend_;
}
inline void Sentence::set_tokenoffsetend(::google::protobuf::uint32 value) {
  set_has_tokenoffsetend();
  tokenoffsetend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.tokenOffsetEnd)
}

// optional uint32 sentenceIndex = 4;
inline bool Sentence::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sentence::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sentence::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sentence::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
inline ::google::protobuf::uint32 Sentence::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.sentenceIndex)
  return sentenceindex_;
}
inline void Sentence::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.sentenceIndex)
}

// optional uint32 characterOffsetBegin = 5;
inline bool Sentence::has_characteroffsetbegin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sentence::set_has_characteroffsetbegin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sentence::clear_has_characteroffsetbegin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sentence::clear_characteroffsetbegin() {
  characteroffsetbegin_ = 0u;
  clear_has_characteroffsetbegin();
}
inline ::google::protobuf::uint32 Sentence::characteroffsetbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.characterOffsetBegin)
  return characteroffsetbegin_;
}
inline void Sentence::set_characteroffsetbegin(::google::protobuf::uint32 value) {
  set_has_characteroffsetbegin();
  characteroffsetbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.characterOffsetBegin)
}

// optional uint32 characterOffsetEnd = 6;
inline bool Sentence::has_characteroffsetend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sentence::set_has_characteroffsetend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sentence::clear_has_characteroffsetend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sentence::clear_characteroffsetend() {
  characteroffsetend_ = 0u;
  clear_has_characteroffsetend();
}
inline ::google::protobuf::uint32 Sentence::characteroffsetend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.characterOffsetEnd)
  return characteroffsetend_;
}
inline void Sentence::set_characteroffsetend(::google::protobuf::uint32 value) {
  set_has_characteroffsetend();
  characteroffsetend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.characterOffsetEnd)
}

// optional .edu.stanford.nlp.pipeline.ParseTree parseTree = 7;
inline bool Sentence::has_parsetree() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sentence::set_has_parsetree() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sentence::clear_has_parsetree() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sentence::clear_parsetree() {
  if (parsetree_ != NULL) parsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
  clear_has_parsetree();
}
inline const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::parsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.parseTree)
  return parsetree_ != NULL ? *parsetree_ : *default_instance_->parsetree_;
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_parsetree() {
  set_has_parsetree();
  if (parsetree_ == NULL) {
    parsetree_ = new ::edu::stanford::nlp::pipeline::ParseTree;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.parseTree)
  return parsetree_;
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::release_parsetree() {
  clear_has_parsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* temp = parsetree_;
  parsetree_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_parsetree(::edu::stanford::nlp::pipeline::ParseTree* parsetree) {
  delete parsetree_;
  parsetree_ = parsetree;
  if (parsetree) {
    set_has_parsetree();
  } else {
    clear_has_parsetree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.parseTree)
}

// optional .edu.stanford.nlp.pipeline.ParseTree binarizedParseTree = 31;
inline bool Sentence::has_binarizedparsetree() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Sentence::set_has_binarizedparsetree() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Sentence::clear_has_binarizedparsetree() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Sentence::clear_binarizedparsetree() {
  if (binarizedparsetree_ != NULL) binarizedparsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
  clear_has_binarizedparsetree();
}
inline const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::binarizedparsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.binarizedParseTree)
  return binarizedparsetree_ != NULL ? *binarizedparsetree_ : *default_instance_->binarizedparsetree_;
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_binarizedparsetree() {
  set_has_binarizedparsetree();
  if (binarizedparsetree_ == NULL) {
    binarizedparsetree_ = new ::edu::stanford::nlp::pipeline::ParseTree;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.binarizedParseTree)
  return binarizedparsetree_;
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::release_binarizedparsetree() {
  clear_has_binarizedparsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* temp = binarizedparsetree_;
  binarizedparsetree_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_binarizedparsetree(::edu::stanford::nlp::pipeline::ParseTree* binarizedparsetree) {
  delete binarizedparsetree_;
  binarizedparsetree_ = binarizedparsetree;
  if (binarizedparsetree) {
    set_has_binarizedparsetree();
  } else {
    clear_has_binarizedparsetree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.binarizedParseTree)
}

// optional .edu.stanford.nlp.pipeline.ParseTree annotatedParseTree = 32;
inline bool Sentence::has_annotatedparsetree() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Sentence::set_has_annotatedparsetree() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Sentence::clear_has_annotatedparsetree() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Sentence::clear_annotatedparsetree() {
  if (annotatedparsetree_ != NULL) annotatedparsetree_->::edu::stanford::nlp::pipeline::ParseTree::Clear();
  clear_has_annotatedparsetree();
}
inline const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::annotatedparsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.annotatedParseTree)
  return annotatedparsetree_ != NULL ? *annotatedparsetree_ : *default_instance_->annotatedparsetree_;
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_annotatedparsetree() {
  set_has_annotatedparsetree();
  if (annotatedparsetree_ == NULL) {
    annotatedparsetree_ = new ::edu::stanford::nlp::pipeline::ParseTree;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.annotatedParseTree)
  return annotatedparsetree_;
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::release_annotatedparsetree() {
  clear_has_annotatedparsetree();
  ::edu::stanford::nlp::pipeline::ParseTree* temp = annotatedparsetree_;
  annotatedparsetree_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_annotatedparsetree(::edu::stanford::nlp::pipeline::ParseTree* annotatedparsetree) {
  delete annotatedparsetree_;
  annotatedparsetree_ = annotatedparsetree;
  if (annotatedparsetree) {
    set_has_annotatedparsetree();
  } else {
    clear_has_annotatedparsetree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.annotatedParseTree)
}

// optional string sentiment = 33;
inline bool Sentence::has_sentiment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Sentence::set_has_sentiment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Sentence::clear_has_sentiment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Sentence::clear_sentiment() {
  sentiment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentiment();
}
inline const ::std::string& Sentence::sentiment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.sentiment)
  return sentiment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sentence::set_sentiment(const ::std::string& value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.sentiment)
}
inline void Sentence::set_sentiment(const char* value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Sentence.sentiment)
}
inline void Sentence::set_sentiment(const char* value, size_t size) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Sentence.sentiment)
}
inline ::std::string* Sentence::mutable_sentiment() {
  set_has_sentiment();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.sentiment)
  return sentiment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sentence::release_sentiment() {
  clear_has_sentiment();
  return sentiment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sentence::set_allocated_sentiment(::std::string* sentiment) {
  if (sentiment != NULL) {
    set_has_sentiment();
  } else {
    clear_has_sentiment();
  }
  sentiment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentiment);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.sentiment)
}

// repeated .edu.stanford.nlp.pipeline.ParseTree kBestParseTrees = 34;
inline int Sentence::kbestparsetrees_size() const {
  return kbestparsetrees_.size();
}
inline void Sentence::clear_kbestparsetrees() {
  kbestparsetrees_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::ParseTree& Sentence::kbestparsetrees(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::mutable_kbestparsetrees(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::ParseTree* Sentence::add_kbestparsetrees() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >*
Sentence::mutable_kbestparsetrees() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return &kbestparsetrees_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >&
Sentence::kbestparsetrees() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.kBestParseTrees)
  return kbestparsetrees_;
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph basicDependencies = 8;
inline bool Sentence::has_basicdependencies() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Sentence::set_has_basicdependencies() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Sentence::clear_has_basicdependencies() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Sentence::clear_basicdependencies() {
  if (basicdependencies_ != NULL) basicdependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_basicdependencies();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::basicdependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.basicDependencies)
  return basicdependencies_ != NULL ? *basicdependencies_ : *default_instance_->basicdependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_basicdependencies() {
  set_has_basicdependencies();
  if (basicdependencies_ == NULL) {
    basicdependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.basicDependencies)
  return basicdependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_basicdependencies() {
  clear_has_basicdependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = basicdependencies_;
  basicdependencies_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_basicdependencies(::edu::stanford::nlp::pipeline::DependencyGraph* basicdependencies) {
  delete basicdependencies_;
  basicdependencies_ = basicdependencies;
  if (basicdependencies) {
    set_has_basicdependencies();
  } else {
    clear_has_basicdependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.basicDependencies)
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedDependencies = 9;
inline bool Sentence::has_collapseddependencies() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Sentence::set_has_collapseddependencies() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Sentence::clear_has_collapseddependencies() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Sentence::clear_collapseddependencies() {
  if (collapseddependencies_ != NULL) collapseddependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_collapseddependencies();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::collapseddependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.collapsedDependencies)
  return collapseddependencies_ != NULL ? *collapseddependencies_ : *default_instance_->collapseddependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_collapseddependencies() {
  set_has_collapseddependencies();
  if (collapseddependencies_ == NULL) {
    collapseddependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.collapsedDependencies)
  return collapseddependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_collapseddependencies() {
  clear_has_collapseddependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = collapseddependencies_;
  collapseddependencies_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_collapseddependencies(::edu::stanford::nlp::pipeline::DependencyGraph* collapseddependencies) {
  delete collapseddependencies_;
  collapseddependencies_ = collapseddependencies;
  if (collapseddependencies) {
    set_has_collapseddependencies();
  } else {
    clear_has_collapseddependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.collapsedDependencies)
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph collapsedCCProcessedDependencies = 10;
inline bool Sentence::has_collapsedccprocesseddependencies() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Sentence::set_has_collapsedccprocesseddependencies() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Sentence::clear_has_collapsedccprocesseddependencies() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Sentence::clear_collapsedccprocesseddependencies() {
  if (collapsedccprocesseddependencies_ != NULL) collapsedccprocesseddependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_collapsedccprocesseddependencies();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::collapsedccprocesseddependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.collapsedCCProcessedDependencies)
  return collapsedccprocesseddependencies_ != NULL ? *collapsedccprocesseddependencies_ : *default_instance_->collapsedccprocesseddependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_collapsedccprocesseddependencies() {
  set_has_collapsedccprocesseddependencies();
  if (collapsedccprocesseddependencies_ == NULL) {
    collapsedccprocesseddependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.collapsedCCProcessedDependencies)
  return collapsedccprocesseddependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_collapsedccprocesseddependencies() {
  clear_has_collapsedccprocesseddependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = collapsedccprocesseddependencies_;
  collapsedccprocesseddependencies_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_collapsedccprocesseddependencies(::edu::stanford::nlp::pipeline::DependencyGraph* collapsedccprocesseddependencies) {
  delete collapsedccprocesseddependencies_;
  collapsedccprocesseddependencies_ = collapsedccprocesseddependencies;
  if (collapsedccprocesseddependencies) {
    set_has_collapsedccprocesseddependencies();
  } else {
    clear_has_collapsedccprocesseddependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.collapsedCCProcessedDependencies)
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph alternativeDependencies = 13;
inline bool Sentence::has_alternativedependencies() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Sentence::set_has_alternativedependencies() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Sentence::clear_has_alternativedependencies() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Sentence::clear_alternativedependencies() {
  if (alternativedependencies_ != NULL) alternativedependencies_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_alternativedependencies();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph& Sentence::alternativedependencies() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.alternativeDependencies)
  return alternativedependencies_ != NULL ? *alternativedependencies_ : *default_instance_->alternativedependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::mutable_alternativedependencies() {
  set_has_alternativedependencies();
  if (alternativedependencies_ == NULL) {
    alternativedependencies_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.alternativeDependencies)
  return alternativedependencies_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* Sentence::release_alternativedependencies() {
  clear_has_alternativedependencies();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = alternativedependencies_;
  alternativedependencies_ = NULL;
  return temp;
}
inline void Sentence::set_allocated_alternativedependencies(::edu::stanford::nlp::pipeline::DependencyGraph* alternativedependencies) {
  delete alternativedependencies_;
  alternativedependencies_ = alternativedependencies;
  if (alternativedependencies) {
    set_has_alternativedependencies();
  } else {
    clear_has_alternativedependencies();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.alternativeDependencies)
}

// repeated .edu.stanford.nlp.pipeline.RelationTriple openieTriple = 14;
inline int Sentence::openietriple_size() const {
  return openietriple_.size();
}
inline void Sentence::clear_openietriple() {
  openietriple_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::RelationTriple& Sentence::openietriple(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::RelationTriple* Sentence::mutable_openietriple(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::RelationTriple* Sentence::add_openietriple() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >*
Sentence::mutable_openietriple() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return &openietriple_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >&
Sentence::openietriple() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.openieTriple)
  return openietriple_;
}

// repeated .edu.stanford.nlp.pipeline.RelationTriple kbpTriple = 16;
inline int Sentence::kbptriple_size() const {
  return kbptriple_.size();
}
inline void Sentence::clear_kbptriple() {
  kbptriple_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::RelationTriple& Sentence::kbptriple(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::RelationTriple* Sentence::mutable_kbptriple(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::RelationTriple* Sentence::add_kbptriple() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >*
Sentence::mutable_kbptriple() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return &kbptriple_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::RelationTriple >&
Sentence::kbptriple() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.kbpTriple)
  return kbptriple_;
}

// repeated .edu.stanford.nlp.pipeline.SentenceFragment entailedSentence = 15;
inline int Sentence::entailedsentence_size() const {
  return entailedsentence_.size();
}
inline void Sentence::clear_entailedsentence() {
  entailedsentence_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::SentenceFragment& Sentence::entailedsentence(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::SentenceFragment* Sentence::mutable_entailedsentence(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::SentenceFragment* Sentence::add_entailedsentence() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment >*
Sentence::mutable_entailedsentence() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return &entailedsentence_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::SentenceFragment >&
Sentence::entailedsentence() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.entailedSentence)
  return entailedsentence_;
}

// optional uint32 paragraph = 11;
inline bool Sentence::has_paragraph() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Sentence::set_has_paragraph() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Sentence::clear_has_paragraph() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Sentence::clear_paragraph() {
  paragraph_ = 0u;
  clear_has_paragraph();
}
inline ::google::protobuf::uint32 Sentence::paragraph() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.paragraph)
  return paragraph_;
}
inline void Sentence::set_paragraph(::google::protobuf::uint32 value) {
  set_has_paragraph();
  paragraph_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.paragraph)
}

// optional string text = 12;
inline bool Sentence::has_text() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Sentence::set_has_text() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Sentence::clear_has_text() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Sentence::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Sentence::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sentence::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.text)
}
inline void Sentence::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Sentence.text)
}
inline void Sentence::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Sentence.text)
}
inline ::std::string* Sentence::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sentence::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sentence::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.text)
}

// optional bool hasRelationAnnotations = 51;
inline bool Sentence::has_hasrelationannotations() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Sentence::set_has_hasrelationannotations() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Sentence::clear_has_hasrelationannotations() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Sentence::clear_hasrelationannotations() {
  hasrelationannotations_ = false;
  clear_has_hasrelationannotations();
}
inline bool Sentence::hasrelationannotations() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.hasRelationAnnotations)
  return hasrelationannotations_;
}
inline void Sentence::set_hasrelationannotations(bool value) {
  set_has_hasrelationannotations();
  hasrelationannotations_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.hasRelationAnnotations)
}

// repeated .edu.stanford.nlp.pipeline.Entity entity = 52;
inline int Sentence::entity_size() const {
  return entity_.size();
}
inline void Sentence::clear_entity() {
  entity_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Entity& Sentence::entity(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Entity* Sentence::mutable_entity(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Entity* Sentence::add_entity() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >*
Sentence::mutable_entity() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.entity)
  return &entity_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >&
Sentence::entity() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.entity)
  return entity_;
}

// repeated .edu.stanford.nlp.pipeline.Relation relation = 53;
inline int Sentence::relation_size() const {
  return relation_.size();
}
inline void Sentence::clear_relation() {
  relation_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Relation& Sentence::relation(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Relation* Sentence::mutable_relation(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Relation* Sentence::add_relation() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation >*
Sentence::mutable_relation() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.relation)
  return &relation_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Relation >&
Sentence::relation() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.relation)
  return relation_;
}

// optional bool hasNumerizedTokensAnnotation = 54;
inline bool Sentence::has_hasnumerizedtokensannotation() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Sentence::set_has_hasnumerizedtokensannotation() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Sentence::clear_has_hasnumerizedtokensannotation() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Sentence::clear_hasnumerizedtokensannotation() {
  hasnumerizedtokensannotation_ = false;
  clear_has_hasnumerizedtokensannotation();
}
inline bool Sentence::hasnumerizedtokensannotation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.hasNumerizedTokensAnnotation)
  return hasnumerizedtokensannotation_;
}
inline void Sentence::set_hasnumerizedtokensannotation(bool value) {
  set_has_hasnumerizedtokensannotation();
  hasnumerizedtokensannotation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.hasNumerizedTokensAnnotation)
}

// repeated .edu.stanford.nlp.pipeline.NERMention mentions = 55;
inline int Sentence::mentions_size() const {
  return mentions_.size();
}
inline void Sentence::clear_mentions() {
  mentions_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::NERMention& Sentence::mentions(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::NERMention* Sentence::mutable_mentions(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::NERMention* Sentence::add_mentions() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention >*
Sentence::mutable_mentions() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.mentions)
  return &mentions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::NERMention >&
Sentence::mentions() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.mentions)
  return mentions_;
}

// repeated .edu.stanford.nlp.pipeline.Mention mentionsForCoref = 56;
inline int Sentence::mentionsforcoref_size() const {
  return mentionsforcoref_.size();
}
inline void Sentence::clear_mentionsforcoref() {
  mentionsforcoref_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Mention& Sentence::mentionsforcoref(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Mention* Sentence::mutable_mentionsforcoref(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Mention* Sentence::add_mentionsforcoref() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention >*
Sentence::mutable_mentionsforcoref() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return &mentionsforcoref_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Mention >&
Sentence::mentionsforcoref() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Sentence.mentionsForCoref)
  return mentionsforcoref_;
}

// optional bool hasCorefMentionsAnnotation = 57;
inline bool Sentence::has_hascorefmentionsannotation() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Sentence::set_has_hascorefmentionsannotation() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Sentence::clear_has_hascorefmentionsannotation() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Sentence::clear_hascorefmentionsannotation() {
  hascorefmentionsannotation_ = false;
  clear_has_hascorefmentionsannotation();
}
inline bool Sentence::hascorefmentionsannotation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.hasCorefMentionsAnnotation)
  return hascorefmentionsannotation_;
}
inline void Sentence::set_hascorefmentionsannotation(bool value) {
  set_has_hascorefmentionsannotation();
  hascorefmentionsannotation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.hasCorefMentionsAnnotation)
}

// optional string sentenceID = 58;
inline bool Sentence::has_sentenceid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Sentence::set_has_sentenceid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Sentence::clear_has_sentenceid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Sentence::clear_sentenceid() {
  sentenceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentenceid();
}
inline const ::std::string& Sentence::sentenceid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Sentence.sentenceID)
  return sentenceid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sentence::set_sentenceid(const ::std::string& value) {
  set_has_sentenceid();
  sentenceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}
inline void Sentence::set_sentenceid(const char* value) {
  set_has_sentenceid();
  sentenceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}
inline void Sentence::set_sentenceid(const char* value, size_t size) {
  set_has_sentenceid();
  sentenceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}
inline ::std::string* Sentence::mutable_sentenceid() {
  set_has_sentenceid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Sentence.sentenceID)
  return sentenceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sentence::release_sentenceid() {
  clear_has_sentenceid();
  return sentenceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sentence::set_allocated_sentenceid(::std::string* sentenceid) {
  if (sentenceid != NULL) {
    set_has_sentenceid();
  } else {
    clear_has_sentenceid();
  }
  sentenceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentenceid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Sentence.sentenceID)
}

// -------------------------------------------------------------------

// Token

// required string word = 1;
inline bool Token::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Token::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Token::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Token::clear_word() {
  word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_word();
}
inline const ::std::string& Token::word() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.word)
  return word_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_word(const ::std::string& value) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.word)
}
inline void Token::set_word(const char* value) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.word)
}
inline void Token::set_word(const char* value, size_t size) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.word)
}
inline ::std::string* Token::mutable_word() {
  set_has_word();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.word)
  return word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_word() {
  clear_has_word();
  return word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_word(::std::string* word) {
  if (word != NULL) {
    set_has_word();
  } else {
    clear_has_word();
  }
  word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.word)
}

// optional string pos = 2;
inline bool Token::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Token::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Token::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Token::clear_pos() {
  pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pos();
}
inline const ::std::string& Token::pos() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.pos)
  return pos_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_pos(const ::std::string& value) {
  set_has_pos();
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.pos)
}
inline void Token::set_pos(const char* value) {
  set_has_pos();
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.pos)
}
inline void Token::set_pos(const char* value, size_t size) {
  set_has_pos();
  pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.pos)
}
inline ::std::string* Token::mutable_pos() {
  set_has_pos();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.pos)
  return pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_pos() {
  clear_has_pos();
  return pos_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_pos(::std::string* pos) {
  if (pos != NULL) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pos);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.pos)
}

// optional string value = 3;
inline bool Token::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Token::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Token::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Token::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Token::value() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.value)
}
inline void Token::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.value)
}
inline void Token::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.value)
}
inline ::std::string* Token::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.value)
}

// optional string category = 4;
inline bool Token::has_category() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Token::set_has_category() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Token::clear_has_category() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Token::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
inline const ::std::string& Token::category() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.category)
  return category_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.category)
}
inline void Token::set_category(const char* value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.category)
}
inline void Token::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.category)
}
inline ::std::string* Token::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_category() {
  clear_has_category();
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.category)
}

// optional string before = 5;
inline bool Token::has_before() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Token::set_has_before() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Token::clear_has_before() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Token::clear_before() {
  before_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_before();
}
inline const ::std::string& Token::before() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.before)
  return before_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_before(const ::std::string& value) {
  set_has_before();
  before_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.before)
}
inline void Token::set_before(const char* value) {
  set_has_before();
  before_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.before)
}
inline void Token::set_before(const char* value, size_t size) {
  set_has_before();
  before_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.before)
}
inline ::std::string* Token::mutable_before() {
  set_has_before();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.before)
  return before_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_before() {
  clear_has_before();
  return before_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_before(::std::string* before) {
  if (before != NULL) {
    set_has_before();
  } else {
    clear_has_before();
  }
  before_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), before);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.before)
}

// optional string after = 6;
inline bool Token::has_after() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Token::set_has_after() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Token::clear_has_after() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Token::clear_after() {
  after_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_after();
}
inline const ::std::string& Token::after() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.after)
  return after_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_after(const ::std::string& value) {
  set_has_after();
  after_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.after)
}
inline void Token::set_after(const char* value) {
  set_has_after();
  after_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.after)
}
inline void Token::set_after(const char* value, size_t size) {
  set_has_after();
  after_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.after)
}
inline ::std::string* Token::mutable_after() {
  set_has_after();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.after)
  return after_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_after() {
  clear_has_after();
  return after_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_after(::std::string* after) {
  if (after != NULL) {
    set_has_after();
  } else {
    clear_has_after();
  }
  after_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), after);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.after)
}

// optional string originalText = 7;
inline bool Token::has_originaltext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Token::set_has_originaltext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Token::clear_has_originaltext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Token::clear_originaltext() {
  originaltext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_originaltext();
}
inline const ::std::string& Token::originaltext() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.originalText)
  return originaltext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_originaltext(const ::std::string& value) {
  set_has_originaltext();
  originaltext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.originalText)
}
inline void Token::set_originaltext(const char* value) {
  set_has_originaltext();
  originaltext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.originalText)
}
inline void Token::set_originaltext(const char* value, size_t size) {
  set_has_originaltext();
  originaltext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.originalText)
}
inline ::std::string* Token::mutable_originaltext() {
  set_has_originaltext();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.originalText)
  return originaltext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_originaltext() {
  clear_has_originaltext();
  return originaltext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_originaltext(::std::string* originaltext) {
  if (originaltext != NULL) {
    set_has_originaltext();
  } else {
    clear_has_originaltext();
  }
  originaltext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), originaltext);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.originalText)
}

// optional string ner = 8;
inline bool Token::has_ner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Token::set_has_ner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Token::clear_has_ner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Token::clear_ner() {
  ner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ner();
}
inline const ::std::string& Token::ner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.ner)
  return ner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_ner(const ::std::string& value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.ner)
}
inline void Token::set_ner(const char* value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.ner)
}
inline void Token::set_ner(const char* value, size_t size) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.ner)
}
inline ::std::string* Token::mutable_ner() {
  set_has_ner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.ner)
  return ner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_ner() {
  clear_has_ner();
  return ner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_ner(::std::string* ner) {
  if (ner != NULL) {
    set_has_ner();
  } else {
    clear_has_ner();
  }
  ner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.ner)
}

// optional string normalizedNER = 9;
inline bool Token::has_normalizedner() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Token::set_has_normalizedner() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Token::clear_has_normalizedner() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Token::clear_normalizedner() {
  normalizedner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_normalizedner();
}
inline const ::std::string& Token::normalizedner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.normalizedNER)
  return normalizedner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_normalizedner(const ::std::string& value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.normalizedNER)
}
inline void Token::set_normalizedner(const char* value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.normalizedNER)
}
inline void Token::set_normalizedner(const char* value, size_t size) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.normalizedNER)
}
inline ::std::string* Token::mutable_normalizedner() {
  set_has_normalizedner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.normalizedNER)
  return normalizedner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_normalizedner() {
  clear_has_normalizedner();
  return normalizedner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_normalizedner(::std::string* normalizedner) {
  if (normalizedner != NULL) {
    set_has_normalizedner();
  } else {
    clear_has_normalizedner();
  }
  normalizedner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normalizedner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.normalizedNER)
}

// optional string lemma = 10;
inline bool Token::has_lemma() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Token::set_has_lemma() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Token::clear_has_lemma() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Token::clear_lemma() {
  lemma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lemma();
}
inline const ::std::string& Token::lemma() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.lemma)
  return lemma_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_lemma(const ::std::string& value) {
  set_has_lemma();
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.lemma)
}
inline void Token::set_lemma(const char* value) {
  set_has_lemma();
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.lemma)
}
inline void Token::set_lemma(const char* value, size_t size) {
  set_has_lemma();
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.lemma)
}
inline ::std::string* Token::mutable_lemma() {
  set_has_lemma();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.lemma)
  return lemma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_lemma() {
  clear_has_lemma();
  return lemma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_lemma(::std::string* lemma) {
  if (lemma != NULL) {
    set_has_lemma();
  } else {
    clear_has_lemma();
  }
  lemma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lemma);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.lemma)
}

// optional uint32 beginChar = 11;
inline bool Token::has_beginchar() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Token::set_has_beginchar() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Token::clear_has_beginchar() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Token::clear_beginchar() {
  beginchar_ = 0u;
  clear_has_beginchar();
}
inline ::google::protobuf::uint32 Token::beginchar() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.beginChar)
  return beginchar_;
}
inline void Token::set_beginchar(::google::protobuf::uint32 value) {
  set_has_beginchar();
  beginchar_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.beginChar)
}

// optional uint32 endChar = 12;
inline bool Token::has_endchar() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Token::set_has_endchar() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Token::clear_has_endchar() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Token::clear_endchar() {
  endchar_ = 0u;
  clear_has_endchar();
}
inline ::google::protobuf::uint32 Token::endchar() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.endChar)
  return endchar_;
}
inline void Token::set_endchar(::google::protobuf::uint32 value) {
  set_has_endchar();
  endchar_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.endChar)
}

// optional uint32 utterance = 13;
inline bool Token::has_utterance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Token::set_has_utterance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Token::clear_has_utterance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Token::clear_utterance() {
  utterance_ = 0u;
  clear_has_utterance();
}
inline ::google::protobuf::uint32 Token::utterance() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.utterance)
  return utterance_;
}
inline void Token::set_utterance(::google::protobuf::uint32 value) {
  set_has_utterance();
  utterance_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.utterance)
}

// optional string speaker = 14;
inline bool Token::has_speaker() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Token::set_has_speaker() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Token::clear_has_speaker() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Token::clear_speaker() {
  speaker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_speaker();
}
inline const ::std::string& Token::speaker() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.speaker)
  return speaker_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_speaker(const ::std::string& value) {
  set_has_speaker();
  speaker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.speaker)
}
inline void Token::set_speaker(const char* value) {
  set_has_speaker();
  speaker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.speaker)
}
inline void Token::set_speaker(const char* value, size_t size) {
  set_has_speaker();
  speaker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.speaker)
}
inline ::std::string* Token::mutable_speaker() {
  set_has_speaker();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.speaker)
  return speaker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_speaker() {
  clear_has_speaker();
  return speaker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_speaker(::std::string* speaker) {
  if (speaker != NULL) {
    set_has_speaker();
  } else {
    clear_has_speaker();
  }
  speaker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), speaker);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.speaker)
}

// optional uint32 beginIndex = 15;
inline bool Token::has_beginindex() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Token::set_has_beginindex() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Token::clear_has_beginindex() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Token::clear_beginindex() {
  beginindex_ = 0u;
  clear_has_beginindex();
}
inline ::google::protobuf::uint32 Token::beginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.beginIndex)
  return beginindex_;
}
inline void Token::set_beginindex(::google::protobuf::uint32 value) {
  set_has_beginindex();
  beginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.beginIndex)
}

// optional uint32 endIndex = 16;
inline bool Token::has_endindex() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Token::set_has_endindex() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Token::clear_has_endindex() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Token::clear_endindex() {
  endindex_ = 0u;
  clear_has_endindex();
}
inline ::google::protobuf::uint32 Token::endindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.endIndex)
  return endindex_;
}
inline void Token::set_endindex(::google::protobuf::uint32 value) {
  set_has_endindex();
  endindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.endIndex)
}

// optional uint32 tokenBeginIndex = 17;
inline bool Token::has_tokenbeginindex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Token::set_has_tokenbeginindex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Token::clear_has_tokenbeginindex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Token::clear_tokenbeginindex() {
  tokenbeginindex_ = 0u;
  clear_has_tokenbeginindex();
}
inline ::google::protobuf::uint32 Token::tokenbeginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.tokenBeginIndex)
  return tokenbeginindex_;
}
inline void Token::set_tokenbeginindex(::google::protobuf::uint32 value) {
  set_has_tokenbeginindex();
  tokenbeginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.tokenBeginIndex)
}

// optional uint32 tokenEndIndex = 18;
inline bool Token::has_tokenendindex() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Token::set_has_tokenendindex() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Token::clear_has_tokenendindex() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Token::clear_tokenendindex() {
  tokenendindex_ = 0u;
  clear_has_tokenendindex();
}
inline ::google::protobuf::uint32 Token::tokenendindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.tokenEndIndex)
  return tokenendindex_;
}
inline void Token::set_tokenendindex(::google::protobuf::uint32 value) {
  set_has_tokenendindex();
  tokenendindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.tokenEndIndex)
}

// optional .edu.stanford.nlp.pipeline.Timex timexValue = 19;
inline bool Token::has_timexvalue() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Token::set_has_timexvalue() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Token::clear_has_timexvalue() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Token::clear_timexvalue() {
  if (timexvalue_ != NULL) timexvalue_->::edu::stanford::nlp::pipeline::Timex::Clear();
  clear_has_timexvalue();
}
inline const ::edu::stanford::nlp::pipeline::Timex& Token::timexvalue() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.timexValue)
  return timexvalue_ != NULL ? *timexvalue_ : *default_instance_->timexvalue_;
}
inline ::edu::stanford::nlp::pipeline::Timex* Token::mutable_timexvalue() {
  set_has_timexvalue();
  if (timexvalue_ == NULL) {
    timexvalue_ = new ::edu::stanford::nlp::pipeline::Timex;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.timexValue)
  return timexvalue_;
}
inline ::edu::stanford::nlp::pipeline::Timex* Token::release_timexvalue() {
  clear_has_timexvalue();
  ::edu::stanford::nlp::pipeline::Timex* temp = timexvalue_;
  timexvalue_ = NULL;
  return temp;
}
inline void Token::set_allocated_timexvalue(::edu::stanford::nlp::pipeline::Timex* timexvalue) {
  delete timexvalue_;
  timexvalue_ = timexvalue;
  if (timexvalue) {
    set_has_timexvalue();
  } else {
    clear_has_timexvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.timexValue)
}

// optional bool hasXmlContext = 21;
inline bool Token::has_hasxmlcontext() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Token::set_has_hasxmlcontext() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Token::clear_has_hasxmlcontext() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Token::clear_hasxmlcontext() {
  hasxmlcontext_ = false;
  clear_has_hasxmlcontext();
}
inline bool Token::hasxmlcontext() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.hasXmlContext)
  return hasxmlcontext_;
}
inline void Token::set_hasxmlcontext(bool value) {
  set_has_hasxmlcontext();
  hasxmlcontext_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.hasXmlContext)
}

// repeated string xmlContext = 22;
inline int Token::xmlcontext_size() const {
  return xmlcontext_.size();
}
inline void Token::clear_xmlcontext() {
  xmlcontext_.Clear();
}
inline const ::std::string& Token::xmlcontext(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.xmlContext)
  return xmlcontext_.Get(index);
}
inline ::std::string* Token::mutable_xmlcontext(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.xmlContext)
  return xmlcontext_.Mutable(index);
}
inline void Token::set_xmlcontext(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.xmlContext)
  xmlcontext_.Mutable(index)->assign(value);
}
inline void Token::set_xmlcontext(int index, const char* value) {
  xmlcontext_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.xmlContext)
}
inline void Token::set_xmlcontext(int index, const char* value, size_t size) {
  xmlcontext_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.xmlContext)
}
inline ::std::string* Token::add_xmlcontext() {
  return xmlcontext_.Add();
}
inline void Token::add_xmlcontext(const ::std::string& value) {
  xmlcontext_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Token.xmlContext)
}
inline void Token::add_xmlcontext(const char* value) {
  xmlcontext_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Token.xmlContext)
}
inline void Token::add_xmlcontext(const char* value, size_t size) {
  xmlcontext_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Token.xmlContext)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Token::xmlcontext() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Token.xmlContext)
  return xmlcontext_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Token::mutable_xmlcontext() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Token.xmlContext)
  return &xmlcontext_;
}

// optional uint32 corefClusterID = 23;
inline bool Token::has_corefclusterid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Token::set_has_corefclusterid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Token::clear_has_corefclusterid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Token::clear_corefclusterid() {
  corefclusterid_ = 0u;
  clear_has_corefclusterid();
}
inline ::google::protobuf::uint32 Token::corefclusterid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.corefClusterID)
  return corefclusterid_;
}
inline void Token::set_corefclusterid(::google::protobuf::uint32 value) {
  set_has_corefclusterid();
  corefclusterid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.corefClusterID)
}

// optional string answer = 24;
inline bool Token::has_answer() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Token::set_has_answer() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Token::clear_has_answer() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Token::clear_answer() {
  answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_answer();
}
inline const ::std::string& Token::answer() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.answer)
  return answer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_answer(const ::std::string& value) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.answer)
}
inline void Token::set_answer(const char* value) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.answer)
}
inline void Token::set_answer(const char* value, size_t size) {
  set_has_answer();
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.answer)
}
inline ::std::string* Token::mutable_answer() {
  set_has_answer();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.answer)
  return answer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_answer() {
  clear_has_answer();
  return answer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_answer(::std::string* answer) {
  if (answer != NULL) {
    set_has_answer();
  } else {
    clear_has_answer();
  }
  answer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), answer);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.answer)
}

// optional uint32 headWordIndex = 26;
inline bool Token::has_headwordindex() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Token::set_has_headwordindex() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Token::clear_has_headwordindex() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Token::clear_headwordindex() {
  headwordindex_ = 0u;
  clear_has_headwordindex();
}
inline ::google::protobuf::uint32 Token::headwordindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.headWordIndex)
  return headwordindex_;
}
inline void Token::set_headwordindex(::google::protobuf::uint32 value) {
  set_has_headwordindex();
  headwordindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.headWordIndex)
}

// optional .edu.stanford.nlp.pipeline.Operator operator = 27;
inline bool Token::has_operator_() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Token::set_has_operator_() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Token::clear_has_operator_() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Token::clear_operator_() {
  if (operator__ != NULL) operator__->::edu::stanford::nlp::pipeline::Operator::Clear();
  clear_has_operator_();
}
inline const ::edu::stanford::nlp::pipeline::Operator& Token::operator_() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.operator)
  return operator__ != NULL ? *operator__ : *default_instance_->operator__;
}
inline ::edu::stanford::nlp::pipeline::Operator* Token::mutable_operator_() {
  set_has_operator_();
  if (operator__ == NULL) {
    operator__ = new ::edu::stanford::nlp::pipeline::Operator;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.operator)
  return operator__;
}
inline ::edu::stanford::nlp::pipeline::Operator* Token::release_operator_() {
  clear_has_operator_();
  ::edu::stanford::nlp::pipeline::Operator* temp = operator__;
  operator__ = NULL;
  return temp;
}
inline void Token::set_allocated_operator_(::edu::stanford::nlp::pipeline::Operator* operator_) {
  delete operator__;
  operator__ = operator_;
  if (operator_) {
    set_has_operator_();
  } else {
    clear_has_operator_();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.operator)
}

// optional .edu.stanford.nlp.pipeline.Polarity polarity = 28;
inline bool Token::has_polarity() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Token::set_has_polarity() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Token::clear_has_polarity() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Token::clear_polarity() {
  if (polarity_ != NULL) polarity_->::edu::stanford::nlp::pipeline::Polarity::Clear();
  clear_has_polarity();
}
inline const ::edu::stanford::nlp::pipeline::Polarity& Token::polarity() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.polarity)
  return polarity_ != NULL ? *polarity_ : *default_instance_->polarity_;
}
inline ::edu::stanford::nlp::pipeline::Polarity* Token::mutable_polarity() {
  set_has_polarity();
  if (polarity_ == NULL) {
    polarity_ = new ::edu::stanford::nlp::pipeline::Polarity;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.polarity)
  return polarity_;
}
inline ::edu::stanford::nlp::pipeline::Polarity* Token::release_polarity() {
  clear_has_polarity();
  ::edu::stanford::nlp::pipeline::Polarity* temp = polarity_;
  polarity_ = NULL;
  return temp;
}
inline void Token::set_allocated_polarity(::edu::stanford::nlp::pipeline::Polarity* polarity) {
  delete polarity_;
  polarity_ = polarity;
  if (polarity) {
    set_has_polarity();
  } else {
    clear_has_polarity();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.polarity)
}

// optional .edu.stanford.nlp.pipeline.Span span = 29;
inline bool Token::has_span() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Token::set_has_span() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Token::clear_has_span() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Token::clear_span() {
  if (span_ != NULL) span_->::edu::stanford::nlp::pipeline::Span::Clear();
  clear_has_span();
}
inline const ::edu::stanford::nlp::pipeline::Span& Token::span() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.span)
  return span_ != NULL ? *span_ : *default_instance_->span_;
}
inline ::edu::stanford::nlp::pipeline::Span* Token::mutable_span() {
  set_has_span();
  if (span_ == NULL) {
    span_ = new ::edu::stanford::nlp::pipeline::Span;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.span)
  return span_;
}
inline ::edu::stanford::nlp::pipeline::Span* Token::release_span() {
  clear_has_span();
  ::edu::stanford::nlp::pipeline::Span* temp = span_;
  span_ = NULL;
  return temp;
}
inline void Token::set_allocated_span(::edu::stanford::nlp::pipeline::Span* span) {
  delete span_;
  span_ = span;
  if (span) {
    set_has_span();
  } else {
    clear_has_span();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.span)
}

// optional string sentiment = 30;
inline bool Token::has_sentiment() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Token::set_has_sentiment() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Token::clear_has_sentiment() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Token::clear_sentiment() {
  sentiment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sentiment();
}
inline const ::std::string& Token::sentiment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.sentiment)
  return sentiment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_sentiment(const ::std::string& value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.sentiment)
}
inline void Token::set_sentiment(const char* value) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.sentiment)
}
inline void Token::set_sentiment(const char* value, size_t size) {
  set_has_sentiment();
  sentiment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.sentiment)
}
inline ::std::string* Token::mutable_sentiment() {
  set_has_sentiment();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.sentiment)
  return sentiment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_sentiment() {
  clear_has_sentiment();
  return sentiment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_sentiment(::std::string* sentiment) {
  if (sentiment != NULL) {
    set_has_sentiment();
  } else {
    clear_has_sentiment();
  }
  sentiment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentiment);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.sentiment)
}

// optional int32 quotationIndex = 31;
inline bool Token::has_quotationindex() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Token::set_has_quotationindex() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Token::clear_has_quotationindex() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Token::clear_quotationindex() {
  quotationindex_ = 0;
  clear_has_quotationindex();
}
inline ::google::protobuf::int32 Token::quotationindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.quotationIndex)
  return quotationindex_;
}
inline void Token::set_quotationindex(::google::protobuf::int32 value) {
  set_has_quotationindex();
  quotationindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.quotationIndex)
}

// optional .edu.stanford.nlp.pipeline.MapStringString conllUFeatures = 32;
inline bool Token::has_conllufeatures() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Token::set_has_conllufeatures() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Token::clear_has_conllufeatures() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Token::clear_conllufeatures() {
  if (conllufeatures_ != NULL) conllufeatures_->::edu::stanford::nlp::pipeline::MapStringString::Clear();
  clear_has_conllufeatures();
}
inline const ::edu::stanford::nlp::pipeline::MapStringString& Token::conllufeatures() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUFeatures)
  return conllufeatures_ != NULL ? *conllufeatures_ : *default_instance_->conllufeatures_;
}
inline ::edu::stanford::nlp::pipeline::MapStringString* Token::mutable_conllufeatures() {
  set_has_conllufeatures();
  if (conllufeatures_ == NULL) {
    conllufeatures_ = new ::edu::stanford::nlp::pipeline::MapStringString;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUFeatures)
  return conllufeatures_;
}
inline ::edu::stanford::nlp::pipeline::MapStringString* Token::release_conllufeatures() {
  clear_has_conllufeatures();
  ::edu::stanford::nlp::pipeline::MapStringString* temp = conllufeatures_;
  conllufeatures_ = NULL;
  return temp;
}
inline void Token::set_allocated_conllufeatures(::edu::stanford::nlp::pipeline::MapStringString* conllufeatures) {
  delete conllufeatures_;
  conllufeatures_ = conllufeatures;
  if (conllufeatures) {
    set_has_conllufeatures();
  } else {
    clear_has_conllufeatures();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUFeatures)
}

// optional string coarseTag = 33;
inline bool Token::has_coarsetag() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Token::set_has_coarsetag() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Token::clear_has_coarsetag() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Token::clear_coarsetag() {
  coarsetag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coarsetag();
}
inline const ::std::string& Token::coarsetag() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.coarseTag)
  return coarsetag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_coarsetag(const ::std::string& value) {
  set_has_coarsetag();
  coarsetag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.coarseTag)
}
inline void Token::set_coarsetag(const char* value) {
  set_has_coarsetag();
  coarsetag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.coarseTag)
}
inline void Token::set_coarsetag(const char* value, size_t size) {
  set_has_coarsetag();
  coarsetag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.coarseTag)
}
inline ::std::string* Token::mutable_coarsetag() {
  set_has_coarsetag();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.coarseTag)
  return coarsetag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_coarsetag() {
  clear_has_coarsetag();
  return coarsetag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_coarsetag(::std::string* coarsetag) {
  if (coarsetag != NULL) {
    set_has_coarsetag();
  } else {
    clear_has_coarsetag();
  }
  coarsetag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coarsetag);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.coarseTag)
}

// optional .edu.stanford.nlp.pipeline.Span conllUTokenSpan = 34;
inline bool Token::has_conllutokenspan() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Token::set_has_conllutokenspan() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Token::clear_has_conllutokenspan() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Token::clear_conllutokenspan() {
  if (conllutokenspan_ != NULL) conllutokenspan_->::edu::stanford::nlp::pipeline::Span::Clear();
  clear_has_conllutokenspan();
}
inline const ::edu::stanford::nlp::pipeline::Span& Token::conllutokenspan() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUTokenSpan)
  return conllutokenspan_ != NULL ? *conllutokenspan_ : *default_instance_->conllutokenspan_;
}
inline ::edu::stanford::nlp::pipeline::Span* Token::mutable_conllutokenspan() {
  set_has_conllutokenspan();
  if (conllutokenspan_ == NULL) {
    conllutokenspan_ = new ::edu::stanford::nlp::pipeline::Span;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUTokenSpan)
  return conllutokenspan_;
}
inline ::edu::stanford::nlp::pipeline::Span* Token::release_conllutokenspan() {
  clear_has_conllutokenspan();
  ::edu::stanford::nlp::pipeline::Span* temp = conllutokenspan_;
  conllutokenspan_ = NULL;
  return temp;
}
inline void Token::set_allocated_conllutokenspan(::edu::stanford::nlp::pipeline::Span* conllutokenspan) {
  delete conllutokenspan_;
  conllutokenspan_ = conllutokenspan;
  if (conllutokenspan) {
    set_has_conllutokenspan();
  } else {
    clear_has_conllutokenspan();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUTokenSpan)
}

// optional string conllUMisc = 35;
inline bool Token::has_conllumisc() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Token::set_has_conllumisc() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Token::clear_has_conllumisc() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Token::clear_conllumisc() {
  conllumisc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_conllumisc();
}
inline const ::std::string& Token::conllumisc() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUMisc)
  return conllumisc_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_conllumisc(const ::std::string& value) {
  set_has_conllumisc();
  conllumisc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.conllUMisc)
}
inline void Token::set_conllumisc(const char* value) {
  set_has_conllumisc();
  conllumisc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.conllUMisc)
}
inline void Token::set_conllumisc(const char* value, size_t size) {
  set_has_conllumisc();
  conllumisc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.conllUMisc)
}
inline ::std::string* Token::mutable_conllumisc() {
  set_has_conllumisc();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUMisc)
  return conllumisc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_conllumisc() {
  clear_has_conllumisc();
  return conllumisc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_conllumisc(::std::string* conllumisc) {
  if (conllumisc != NULL) {
    set_has_conllumisc();
  } else {
    clear_has_conllumisc();
  }
  conllumisc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conllumisc);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUMisc)
}

// optional .edu.stanford.nlp.pipeline.MapIntString conllUSecondaryDeps = 36;
inline bool Token::has_conllusecondarydeps() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Token::set_has_conllusecondarydeps() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Token::clear_has_conllusecondarydeps() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Token::clear_conllusecondarydeps() {
  if (conllusecondarydeps_ != NULL) conllusecondarydeps_->::edu::stanford::nlp::pipeline::MapIntString::Clear();
  clear_has_conllusecondarydeps();
}
inline const ::edu::stanford::nlp::pipeline::MapIntString& Token::conllusecondarydeps() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.conllUSecondaryDeps)
  return conllusecondarydeps_ != NULL ? *conllusecondarydeps_ : *default_instance_->conllusecondarydeps_;
}
inline ::edu::stanford::nlp::pipeline::MapIntString* Token::mutable_conllusecondarydeps() {
  set_has_conllusecondarydeps();
  if (conllusecondarydeps_ == NULL) {
    conllusecondarydeps_ = new ::edu::stanford::nlp::pipeline::MapIntString;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.conllUSecondaryDeps)
  return conllusecondarydeps_;
}
inline ::edu::stanford::nlp::pipeline::MapIntString* Token::release_conllusecondarydeps() {
  clear_has_conllusecondarydeps();
  ::edu::stanford::nlp::pipeline::MapIntString* temp = conllusecondarydeps_;
  conllusecondarydeps_ = NULL;
  return temp;
}
inline void Token::set_allocated_conllusecondarydeps(::edu::stanford::nlp::pipeline::MapIntString* conllusecondarydeps) {
  delete conllusecondarydeps_;
  conllusecondarydeps_ = conllusecondarydeps;
  if (conllusecondarydeps) {
    set_has_conllusecondarydeps();
  } else {
    clear_has_conllusecondarydeps();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.conllUSecondaryDeps)
}

// optional string wikipediaEntity = 37;
inline bool Token::has_wikipediaentity() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Token::set_has_wikipediaentity() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Token::clear_has_wikipediaentity() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Token::clear_wikipediaentity() {
  wikipediaentity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wikipediaentity();
}
inline const ::std::string& Token::wikipediaentity() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
  return wikipediaentity_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_wikipediaentity(const ::std::string& value) {
  set_has_wikipediaentity();
  wikipediaentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}
inline void Token::set_wikipediaentity(const char* value) {
  set_has_wikipediaentity();
  wikipediaentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}
inline void Token::set_wikipediaentity(const char* value, size_t size) {
  set_has_wikipediaentity();
  wikipediaentity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}
inline ::std::string* Token::mutable_wikipediaentity() {
  set_has_wikipediaentity();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
  return wikipediaentity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_wikipediaentity() {
  clear_has_wikipediaentity();
  return wikipediaentity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_wikipediaentity(::std::string* wikipediaentity) {
  if (wikipediaentity != NULL) {
    set_has_wikipediaentity();
  } else {
    clear_has_wikipediaentity();
  }
  wikipediaentity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wikipediaentity);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.wikipediaEntity)
}

// optional string gender = 51;
inline bool Token::has_gender() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Token::set_has_gender() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Token::clear_has_gender() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Token::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
inline const ::std::string& Token::gender() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.gender)
  return gender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.gender)
}
inline void Token::set_gender(const char* value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.gender)
}
inline void Token::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.gender)
}
inline ::std::string* Token::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_gender() {
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.gender)
}

// optional string trueCase = 52;
inline bool Token::has_truecase() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Token::set_has_truecase() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Token::clear_has_truecase() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Token::clear_truecase() {
  truecase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_truecase();
}
inline const ::std::string& Token::truecase() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.trueCase)
  return truecase_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_truecase(const ::std::string& value) {
  set_has_truecase();
  truecase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.trueCase)
}
inline void Token::set_truecase(const char* value) {
  set_has_truecase();
  truecase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.trueCase)
}
inline void Token::set_truecase(const char* value, size_t size) {
  set_has_truecase();
  truecase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.trueCase)
}
inline ::std::string* Token::mutable_truecase() {
  set_has_truecase();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.trueCase)
  return truecase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_truecase() {
  clear_has_truecase();
  return truecase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_truecase(::std::string* truecase) {
  if (truecase != NULL) {
    set_has_truecase();
  } else {
    clear_has_truecase();
  }
  truecase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), truecase);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.trueCase)
}

// optional string trueCaseText = 53;
inline bool Token::has_truecasetext() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Token::set_has_truecasetext() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Token::clear_has_truecasetext() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Token::clear_truecasetext() {
  truecasetext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_truecasetext();
}
inline const ::std::string& Token::truecasetext() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Token.trueCaseText)
  return truecasetext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_truecasetext(const ::std::string& value) {
  set_has_truecasetext();
  truecasetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Token.trueCaseText)
}
inline void Token::set_truecasetext(const char* value) {
  set_has_truecasetext();
  truecasetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Token.trueCaseText)
}
inline void Token::set_truecasetext(const char* value, size_t size) {
  set_has_truecasetext();
  truecasetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Token.trueCaseText)
}
inline ::std::string* Token::mutable_truecasetext() {
  set_has_truecasetext();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Token.trueCaseText)
  return truecasetext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_truecasetext() {
  clear_has_truecasetext();
  return truecasetext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_truecasetext(::std::string* truecasetext) {
  if (truecasetext != NULL) {
    set_has_truecasetext();
  } else {
    clear_has_truecasetext();
  }
  truecasetext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), truecasetext);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Token.trueCaseText)
}

// -------------------------------------------------------------------

// Quote

// optional string text = 1;
inline bool Quote::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quote::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quote::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quote::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Quote::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Quote::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.text)
}
inline void Quote::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Quote.text)
}
inline void Quote::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Quote.text)
}
inline ::std::string* Quote::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Quote.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Quote::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Quote::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Quote.text)
}

// optional uint32 begin = 2;
inline bool Quote::has_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quote::set_has_begin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quote::clear_has_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quote::clear_begin() {
  begin_ = 0u;
  clear_has_begin();
}
inline ::google::protobuf::uint32 Quote::begin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.begin)
  return begin_;
}
inline void Quote::set_begin(::google::protobuf::uint32 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.begin)
}

// optional uint32 end = 3;
inline bool Quote::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quote::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quote::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quote::clear_end() {
  end_ = 0u;
  clear_has_end();
}
inline ::google::protobuf::uint32 Quote::end() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.end)
  return end_;
}
inline void Quote::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.end)
}

// optional uint32 sentenceBegin = 5;
inline bool Quote::has_sentencebegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quote::set_has_sentencebegin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quote::clear_has_sentencebegin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quote::clear_sentencebegin() {
  sentencebegin_ = 0u;
  clear_has_sentencebegin();
}
inline ::google::protobuf::uint32 Quote::sentencebegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.sentenceBegin)
  return sentencebegin_;
}
inline void Quote::set_sentencebegin(::google::protobuf::uint32 value) {
  set_has_sentencebegin();
  sentencebegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.sentenceBegin)
}

// optional uint32 sentenceEnd = 6;
inline bool Quote::has_sentenceend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Quote::set_has_sentenceend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Quote::clear_has_sentenceend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Quote::clear_sentenceend() {
  sentenceend_ = 0u;
  clear_has_sentenceend();
}
inline ::google::protobuf::uint32 Quote::sentenceend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.sentenceEnd)
  return sentenceend_;
}
inline void Quote::set_sentenceend(::google::protobuf::uint32 value) {
  set_has_sentenceend();
  sentenceend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.sentenceEnd)
}

// optional uint32 tokenBegin = 7;
inline bool Quote::has_tokenbegin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Quote::set_has_tokenbegin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Quote::clear_has_tokenbegin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Quote::clear_tokenbegin() {
  tokenbegin_ = 0u;
  clear_has_tokenbegin();
}
inline ::google::protobuf::uint32 Quote::tokenbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.tokenBegin)
  return tokenbegin_;
}
inline void Quote::set_tokenbegin(::google::protobuf::uint32 value) {
  set_has_tokenbegin();
  tokenbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.tokenBegin)
}

// optional uint32 tokenEnd = 8;
inline bool Quote::has_tokenend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Quote::set_has_tokenend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Quote::clear_has_tokenend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Quote::clear_tokenend() {
  tokenend_ = 0u;
  clear_has_tokenend();
}
inline ::google::protobuf::uint32 Quote::tokenend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.tokenEnd)
  return tokenend_;
}
inline void Quote::set_tokenend(::google::protobuf::uint32 value) {
  set_has_tokenend();
  tokenend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.tokenEnd)
}

// optional string docid = 9;
inline bool Quote::has_docid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Quote::set_has_docid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Quote::clear_has_docid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Quote::clear_docid() {
  docid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_docid();
}
inline const ::std::string& Quote::docid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.docid)
  return docid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Quote::set_docid(const ::std::string& value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.docid)
}
inline void Quote::set_docid(const char* value) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Quote.docid)
}
inline void Quote::set_docid(const char* value, size_t size) {
  set_has_docid();
  docid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Quote.docid)
}
inline ::std::string* Quote::mutable_docid() {
  set_has_docid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Quote.docid)
  return docid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Quote::release_docid() {
  clear_has_docid();
  return docid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Quote::set_allocated_docid(::std::string* docid) {
  if (docid != NULL) {
    set_has_docid();
  } else {
    clear_has_docid();
  }
  docid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), docid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Quote.docid)
}

// optional uint32 index = 10;
inline bool Quote::has_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Quote::set_has_index() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Quote::clear_has_index() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Quote::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Quote::index() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Quote.index)
  return index_;
}
inline void Quote::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Quote.index)
}

// -------------------------------------------------------------------

// ParseTree

// repeated .edu.stanford.nlp.pipeline.ParseTree child = 1;
inline int ParseTree::child_size() const {
  return child_.size();
}
inline void ParseTree::clear_child() {
  child_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::ParseTree& ParseTree::child(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::ParseTree* ParseTree::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::ParseTree* ParseTree::add_child() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >*
ParseTree::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.ParseTree.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::ParseTree >&
ParseTree::child() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.ParseTree.child)
  return child_;
}

// optional string value = 2;
inline bool ParseTree::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParseTree::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParseTree::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParseTree::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ParseTree::value() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParseTree::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.value)
}
inline void ParseTree::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.ParseTree.value)
}
inline void ParseTree::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.ParseTree.value)
}
inline ::std::string* ParseTree::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.ParseTree.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParseTree::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParseTree::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.ParseTree.value)
}

// optional uint32 yieldBeginIndex = 3;
inline bool ParseTree::has_yieldbeginindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParseTree::set_has_yieldbeginindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParseTree::clear_has_yieldbeginindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParseTree::clear_yieldbeginindex() {
  yieldbeginindex_ = 0u;
  clear_has_yieldbeginindex();
}
inline ::google::protobuf::uint32 ParseTree::yieldbeginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.yieldBeginIndex)
  return yieldbeginindex_;
}
inline void ParseTree::set_yieldbeginindex(::google::protobuf::uint32 value) {
  set_has_yieldbeginindex();
  yieldbeginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.yieldBeginIndex)
}

// optional uint32 yieldEndIndex = 4;
inline bool ParseTree::has_yieldendindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParseTree::set_has_yieldendindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParseTree::clear_has_yieldendindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParseTree::clear_yieldendindex() {
  yieldendindex_ = 0u;
  clear_has_yieldendindex();
}
inline ::google::protobuf::uint32 ParseTree::yieldendindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.yieldEndIndex)
  return yieldendindex_;
}
inline void ParseTree::set_yieldendindex(::google::protobuf::uint32 value) {
  set_has_yieldendindex();
  yieldendindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.yieldEndIndex)
}

// optional double score = 5;
inline bool ParseTree::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParseTree::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParseTree::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParseTree::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double ParseTree::score() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.score)
  return score_;
}
inline void ParseTree::set_score(double value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.score)
}

// optional .edu.stanford.nlp.pipeline.Sentiment sentiment = 6;
inline bool ParseTree::has_sentiment() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParseTree::set_has_sentiment() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParseTree::clear_has_sentiment() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParseTree::clear_sentiment() {
  sentiment_ = 0;
  clear_has_sentiment();
}
inline ::edu::stanford::nlp::pipeline::Sentiment ParseTree::sentiment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.ParseTree.sentiment)
  return static_cast< ::edu::stanford::nlp::pipeline::Sentiment >(sentiment_);
}
inline void ParseTree::set_sentiment(::edu::stanford::nlp::pipeline::Sentiment value) {
  assert(::edu::stanford::nlp::pipeline::Sentiment_IsValid(value));
  set_has_sentiment();
  sentiment_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.ParseTree.sentiment)
}

// -------------------------------------------------------------------

// DependencyGraph_Node

// required uint32 sentenceIndex = 1;
inline bool DependencyGraph_Node::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DependencyGraph_Node::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DependencyGraph_Node::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DependencyGraph_Node::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
inline ::google::protobuf::uint32 DependencyGraph_Node::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Node.sentenceIndex)
  return sentenceindex_;
}
inline void DependencyGraph_Node::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Node.sentenceIndex)
}

// required uint32 index = 2;
inline bool DependencyGraph_Node::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DependencyGraph_Node::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DependencyGraph_Node::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DependencyGraph_Node::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 DependencyGraph_Node::index() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Node.index)
  return index_;
}
inline void DependencyGraph_Node::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Node.index)
}

// optional uint32 copyAnnotation = 3;
inline bool DependencyGraph_Node::has_copyannotation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DependencyGraph_Node::set_has_copyannotation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DependencyGraph_Node::clear_has_copyannotation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DependencyGraph_Node::clear_copyannotation() {
  copyannotation_ = 0u;
  clear_has_copyannotation();
}
inline ::google::protobuf::uint32 DependencyGraph_Node::copyannotation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Node.copyAnnotation)
  return copyannotation_;
}
inline void DependencyGraph_Node::set_copyannotation(::google::protobuf::uint32 value) {
  set_has_copyannotation();
  copyannotation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Node.copyAnnotation)
}

// -------------------------------------------------------------------

// DependencyGraph_Edge

// required uint32 source = 1;
inline bool DependencyGraph_Edge::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DependencyGraph_Edge::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DependencyGraph_Edge::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DependencyGraph_Edge::clear_source() {
  source_ = 0u;
  clear_has_source();
}
inline ::google::protobuf::uint32 DependencyGraph_Edge::source() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.source)
  return source_;
}
inline void DependencyGraph_Edge::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.source)
}

// required uint32 target = 2;
inline bool DependencyGraph_Edge::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DependencyGraph_Edge::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DependencyGraph_Edge::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DependencyGraph_Edge::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 DependencyGraph_Edge::target() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.target)
  return target_;
}
inline void DependencyGraph_Edge::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.target)
}

// optional string dep = 3;
inline bool DependencyGraph_Edge::has_dep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DependencyGraph_Edge::set_has_dep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DependencyGraph_Edge::clear_has_dep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DependencyGraph_Edge::clear_dep() {
  dep_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dep();
}
inline const ::std::string& DependencyGraph_Edge::dep() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
  return dep_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DependencyGraph_Edge::set_dep(const ::std::string& value) {
  set_has_dep();
  dep_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}
inline void DependencyGraph_Edge::set_dep(const char* value) {
  set_has_dep();
  dep_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}
inline void DependencyGraph_Edge::set_dep(const char* value, size_t size) {
  set_has_dep();
  dep_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}
inline ::std::string* DependencyGraph_Edge::mutable_dep() {
  set_has_dep();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
  return dep_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DependencyGraph_Edge::release_dep() {
  clear_has_dep();
  return dep_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DependencyGraph_Edge::set_allocated_dep(::std::string* dep) {
  if (dep != NULL) {
    set_has_dep();
  } else {
    clear_has_dep();
  }
  dep_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dep);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.DependencyGraph.Edge.dep)
}

// optional bool isExtra = 4;
inline bool DependencyGraph_Edge::has_isextra() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DependencyGraph_Edge::set_has_isextra() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DependencyGraph_Edge::clear_has_isextra() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DependencyGraph_Edge::clear_isextra() {
  isextra_ = false;
  clear_has_isextra();
}
inline bool DependencyGraph_Edge::isextra() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.isExtra)
  return isextra_;
}
inline void DependencyGraph_Edge::set_isextra(bool value) {
  set_has_isextra();
  isextra_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.isExtra)
}

// optional uint32 sourceCopy = 5;
inline bool DependencyGraph_Edge::has_sourcecopy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DependencyGraph_Edge::set_has_sourcecopy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DependencyGraph_Edge::clear_has_sourcecopy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DependencyGraph_Edge::clear_sourcecopy() {
  sourcecopy_ = 0u;
  clear_has_sourcecopy();
}
inline ::google::protobuf::uint32 DependencyGraph_Edge::sourcecopy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.sourceCopy)
  return sourcecopy_;
}
inline void DependencyGraph_Edge::set_sourcecopy(::google::protobuf::uint32 value) {
  set_has_sourcecopy();
  sourcecopy_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.sourceCopy)
}

// optional uint32 targetCopy = 6;
inline bool DependencyGraph_Edge::has_targetcopy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DependencyGraph_Edge::set_has_targetcopy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DependencyGraph_Edge::clear_has_targetcopy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DependencyGraph_Edge::clear_targetcopy() {
  targetcopy_ = 0u;
  clear_has_targetcopy();
}
inline ::google::protobuf::uint32 DependencyGraph_Edge::targetcopy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.targetCopy)
  return targetcopy_;
}
inline void DependencyGraph_Edge::set_targetcopy(::google::protobuf::uint32 value) {
  set_has_targetcopy();
  targetcopy_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.targetCopy)
}

// optional .edu.stanford.nlp.pipeline.Language language = 7 [default = Unknown];
inline bool DependencyGraph_Edge::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DependencyGraph_Edge::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DependencyGraph_Edge::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DependencyGraph_Edge::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline ::edu::stanford::nlp::pipeline::Language DependencyGraph_Edge::language() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.Edge.language)
  return static_cast< ::edu::stanford::nlp::pipeline::Language >(language_);
}
inline void DependencyGraph_Edge::set_language(::edu::stanford::nlp::pipeline::Language value) {
  assert(::edu::stanford::nlp::pipeline::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.Edge.language)
}

// -------------------------------------------------------------------

// DependencyGraph

// repeated .edu.stanford.nlp.pipeline.DependencyGraph.Node node = 1;
inline int DependencyGraph::node_size() const {
  return node_.size();
}
inline void DependencyGraph::clear_node() {
  node_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph_Node& DependencyGraph::node(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph_Node* DependencyGraph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph_Node* DependencyGraph::add_node() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node >*
DependencyGraph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Node >&
DependencyGraph::node() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.DependencyGraph.node)
  return node_;
}

// repeated .edu.stanford.nlp.pipeline.DependencyGraph.Edge edge = 2;
inline int DependencyGraph::edge_size() const {
  return edge_.size();
}
inline void DependencyGraph::clear_edge() {
  edge_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph_Edge& DependencyGraph::edge(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph_Edge* DependencyGraph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph_Edge* DependencyGraph::add_edge() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge >*
DependencyGraph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return &edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::DependencyGraph_Edge >&
DependencyGraph::edge() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.DependencyGraph.edge)
  return edge_;
}

// repeated uint32 root = 3 [packed = true];
inline int DependencyGraph::root_size() const {
  return root_.size();
}
inline void DependencyGraph::clear_root() {
  root_.Clear();
}
inline ::google::protobuf::uint32 DependencyGraph::root(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.DependencyGraph.root)
  return root_.Get(index);
}
inline void DependencyGraph::set_root(int index, ::google::protobuf::uint32 value) {
  root_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.DependencyGraph.root)
}
inline void DependencyGraph::add_root(::google::protobuf::uint32 value) {
  root_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.DependencyGraph.root)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DependencyGraph::root() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.DependencyGraph.root)
  return root_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DependencyGraph::mutable_root() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.DependencyGraph.root)
  return &root_;
}

// -------------------------------------------------------------------

// CorefChain_CorefMention

// optional int32 mentionID = 1;
inline bool CorefChain_CorefMention::has_mentionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CorefChain_CorefMention::set_has_mentionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CorefChain_CorefMention::clear_has_mentionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CorefChain_CorefMention::clear_mentionid() {
  mentionid_ = 0;
  clear_has_mentionid();
}
inline ::google::protobuf::int32 CorefChain_CorefMention::mentionid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionID)
  return mentionid_;
}
inline void CorefChain_CorefMention::set_mentionid(::google::protobuf::int32 value) {
  set_has_mentionid();
  mentionid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionID)
}

// optional string mentionType = 2;
inline bool CorefChain_CorefMention::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CorefChain_CorefMention::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CorefChain_CorefMention::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CorefChain_CorefMention::clear_mentiontype() {
  mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mentiontype();
}
inline const ::std::string& CorefChain_CorefMention::mentiontype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
  return mentiontype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}
inline void CorefChain_CorefMention::set_mentiontype(const char* value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}
inline void CorefChain_CorefMention::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}
inline ::std::string* CorefChain_CorefMention::mutable_mentiontype() {
  set_has_mentiontype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
  return mentiontype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorefChain_CorefMention::release_mentiontype() {
  clear_has_mentiontype();
  return mentiontype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype != NULL) {
    set_has_mentiontype();
  } else {
    clear_has_mentiontype();
  }
  mentiontype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mentiontype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.mentionType)
}

// optional string number = 3;
inline bool CorefChain_CorefMention::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CorefChain_CorefMention::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CorefChain_CorefMention::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CorefChain_CorefMention::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_number();
}
inline const ::std::string& CorefChain_CorefMention::number() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
  return number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_number(const ::std::string& value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}
inline void CorefChain_CorefMention::set_number(const char* value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}
inline void CorefChain_CorefMention::set_number(const char* value, size_t size) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}
inline ::std::string* CorefChain_CorefMention::mutable_number() {
  set_has_number();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorefChain_CorefMention::release_number() {
  clear_has_number();
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    set_has_number();
  } else {
    clear_has_number();
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.number)
}

// optional string gender = 4;
inline bool CorefChain_CorefMention::has_gender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CorefChain_CorefMention::set_has_gender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CorefChain_CorefMention::clear_has_gender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CorefChain_CorefMention::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
inline const ::std::string& CorefChain_CorefMention::gender() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
  return gender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}
inline void CorefChain_CorefMention::set_gender(const char* value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}
inline void CorefChain_CorefMention::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}
inline ::std::string* CorefChain_CorefMention::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorefChain_CorefMention::release_gender() {
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.gender)
}

// optional string animacy = 5;
inline bool CorefChain_CorefMention::has_animacy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CorefChain_CorefMention::set_has_animacy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CorefChain_CorefMention::clear_has_animacy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CorefChain_CorefMention::clear_animacy() {
  animacy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_animacy();
}
inline const ::std::string& CorefChain_CorefMention::animacy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
  return animacy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_animacy(const ::std::string& value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}
inline void CorefChain_CorefMention::set_animacy(const char* value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}
inline void CorefChain_CorefMention::set_animacy(const char* value, size_t size) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}
inline ::std::string* CorefChain_CorefMention::mutable_animacy() {
  set_has_animacy();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
  return animacy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorefChain_CorefMention::release_animacy() {
  clear_has_animacy();
  return animacy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorefChain_CorefMention::set_allocated_animacy(::std::string* animacy) {
  if (animacy != NULL) {
    set_has_animacy();
  } else {
    clear_has_animacy();
  }
  animacy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), animacy);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.CorefChain.CorefMention.animacy)
}

// optional uint32 beginIndex = 6;
inline bool CorefChain_CorefMention::has_beginindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CorefChain_CorefMention::set_has_beginindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CorefChain_CorefMention::clear_has_beginindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CorefChain_CorefMention::clear_beginindex() {
  beginindex_ = 0u;
  clear_has_beginindex();
}
inline ::google::protobuf::uint32 CorefChain_CorefMention::beginindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.beginIndex)
  return beginindex_;
}
inline void CorefChain_CorefMention::set_beginindex(::google::protobuf::uint32 value) {
  set_has_beginindex();
  beginindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.beginIndex)
}

// optional uint32 endIndex = 7;
inline bool CorefChain_CorefMention::has_endindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CorefChain_CorefMention::set_has_endindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CorefChain_CorefMention::clear_has_endindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CorefChain_CorefMention::clear_endindex() {
  endindex_ = 0u;
  clear_has_endindex();
}
inline ::google::protobuf::uint32 CorefChain_CorefMention::endindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.endIndex)
  return endindex_;
}
inline void CorefChain_CorefMention::set_endindex(::google::protobuf::uint32 value) {
  set_has_endindex();
  endindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.endIndex)
}

// optional uint32 headIndex = 9;
inline bool CorefChain_CorefMention::has_headindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CorefChain_CorefMention::set_has_headindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CorefChain_CorefMention::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CorefChain_CorefMention::clear_headindex() {
  headindex_ = 0u;
  clear_has_headindex();
}
inline ::google::protobuf::uint32 CorefChain_CorefMention::headindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.headIndex)
  return headindex_;
}
inline void CorefChain_CorefMention::set_headindex(::google::protobuf::uint32 value) {
  set_has_headindex();
  headindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.headIndex)
}

// optional uint32 sentenceIndex = 10;
inline bool CorefChain_CorefMention::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CorefChain_CorefMention::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CorefChain_CorefMention::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CorefChain_CorefMention::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
inline ::google::protobuf::uint32 CorefChain_CorefMention::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.sentenceIndex)
  return sentenceindex_;
}
inline void CorefChain_CorefMention::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.sentenceIndex)
}

// optional uint32 position = 11;
inline bool CorefChain_CorefMention::has_position() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CorefChain_CorefMention::set_has_position() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CorefChain_CorefMention::clear_has_position() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CorefChain_CorefMention::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 CorefChain_CorefMention::position() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.CorefMention.position)
  return position_;
}
inline void CorefChain_CorefMention::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.CorefMention.position)
}

// -------------------------------------------------------------------

// CorefChain

// required int32 chainID = 1;
inline bool CorefChain::has_chainid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CorefChain::set_has_chainid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CorefChain::clear_has_chainid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CorefChain::clear_chainid() {
  chainid_ = 0;
  clear_has_chainid();
}
inline ::google::protobuf::int32 CorefChain::chainid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.chainID)
  return chainid_;
}
inline void CorefChain::set_chainid(::google::protobuf::int32 value) {
  set_has_chainid();
  chainid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.chainID)
}

// repeated .edu.stanford.nlp.pipeline.CorefChain.CorefMention mention = 2;
inline int CorefChain::mention_size() const {
  return mention_.size();
}
inline void CorefChain::clear_mention() {
  mention_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::CorefChain_CorefMention& CorefChain::mention(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::CorefChain_CorefMention* CorefChain::mutable_mention(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::CorefChain_CorefMention* CorefChain::add_mention() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention >*
CorefChain::mutable_mention() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.CorefChain.mention)
  return &mention_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::CorefChain_CorefMention >&
CorefChain::mention() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.CorefChain.mention)
  return mention_;
}

// required uint32 representative = 3;
inline bool CorefChain::has_representative() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CorefChain::set_has_representative() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CorefChain::clear_has_representative() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CorefChain::clear_representative() {
  representative_ = 0u;
  clear_has_representative();
}
inline ::google::protobuf::uint32 CorefChain::representative() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.CorefChain.representative)
  return representative_;
}
inline void CorefChain::set_representative(::google::protobuf::uint32 value) {
  set_has_representative();
  representative_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.CorefChain.representative)
}

// -------------------------------------------------------------------

// Mention

// optional int32 mentionID = 1;
inline bool Mention::has_mentionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mention::set_has_mentionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mention::clear_has_mentionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mention::clear_mentionid() {
  mentionid_ = 0;
  clear_has_mentionid();
}
inline ::google::protobuf::int32 Mention::mentionid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.mentionID)
  return mentionid_;
}
inline void Mention::set_mentionid(::google::protobuf::int32 value) {
  set_has_mentionid();
  mentionid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.mentionID)
}

// optional string mentionType = 2;
inline bool Mention::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mention::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mention::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mention::clear_mentiontype() {
  mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mentiontype();
}
inline const ::std::string& Mention::mentiontype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.mentionType)
  return mentiontype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.mentionType)
}
inline void Mention::set_mentiontype(const char* value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.mentionType)
}
inline void Mention::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.mentionType)
}
inline ::std::string* Mention::mutable_mentiontype() {
  set_has_mentiontype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.mentionType)
  return mentiontype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_mentiontype() {
  clear_has_mentiontype();
  return mentiontype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype != NULL) {
    set_has_mentiontype();
  } else {
    clear_has_mentiontype();
  }
  mentiontype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mentiontype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.mentionType)
}

// optional string number = 3;
inline bool Mention::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mention::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mention::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mention::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_number();
}
inline const ::std::string& Mention::number() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.number)
  return number_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_number(const ::std::string& value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.number)
}
inline void Mention::set_number(const char* value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.number)
}
inline void Mention::set_number(const char* value, size_t size) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.number)
}
inline ::std::string* Mention::mutable_number() {
  set_has_number();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_number() {
  clear_has_number();
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    set_has_number();
  } else {
    clear_has_number();
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.number)
}

// optional string gender = 4;
inline bool Mention::has_gender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mention::set_has_gender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mention::clear_has_gender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mention::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
inline const ::std::string& Mention::gender() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.gender)
  return gender_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.gender)
}
inline void Mention::set_gender(const char* value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.gender)
}
inline void Mention::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.gender)
}
inline ::std::string* Mention::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_gender() {
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.gender)
}

// optional string animacy = 5;
inline bool Mention::has_animacy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mention::set_has_animacy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mention::clear_has_animacy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mention::clear_animacy() {
  animacy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_animacy();
}
inline const ::std::string& Mention::animacy() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.animacy)
  return animacy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_animacy(const ::std::string& value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.animacy)
}
inline void Mention::set_animacy(const char* value) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.animacy)
}
inline void Mention::set_animacy(const char* value, size_t size) {
  set_has_animacy();
  animacy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.animacy)
}
inline ::std::string* Mention::mutable_animacy() {
  set_has_animacy();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.animacy)
  return animacy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_animacy() {
  clear_has_animacy();
  return animacy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_animacy(::std::string* animacy) {
  if (animacy != NULL) {
    set_has_animacy();
  } else {
    clear_has_animacy();
  }
  animacy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), animacy);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.animacy)
}

// optional string person = 6;
inline bool Mention::has_person() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mention::set_has_person() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Mention::clear_has_person() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Mention::clear_person() {
  person_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_person();
}
inline const ::std::string& Mention::person() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.person)
  return person_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_person(const ::std::string& value) {
  set_has_person();
  person_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.person)
}
inline void Mention::set_person(const char* value) {
  set_has_person();
  person_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.person)
}
inline void Mention::set_person(const char* value, size_t size) {
  set_has_person();
  person_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.person)
}
inline ::std::string* Mention::mutable_person() {
  set_has_person();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.person)
  return person_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_person() {
  clear_has_person();
  return person_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_person(::std::string* person) {
  if (person != NULL) {
    set_has_person();
  } else {
    clear_has_person();
  }
  person_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), person);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.person)
}

// optional uint32 startIndex = 7;
inline bool Mention::has_startindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Mention::set_has_startindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Mention::clear_has_startindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Mention::clear_startindex() {
  startindex_ = 0u;
  clear_has_startindex();
}
inline ::google::protobuf::uint32 Mention::startindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.startIndex)
  return startindex_;
}
inline void Mention::set_startindex(::google::protobuf::uint32 value) {
  set_has_startindex();
  startindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.startIndex)
}

// optional uint32 endIndex = 9;
inline bool Mention::has_endindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Mention::set_has_endindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Mention::clear_has_endindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Mention::clear_endindex() {
  endindex_ = 0u;
  clear_has_endindex();
}
inline ::google::protobuf::uint32 Mention::endindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.endIndex)
  return endindex_;
}
inline void Mention::set_endindex(::google::protobuf::uint32 value) {
  set_has_endindex();
  endindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.endIndex)
}

// optional uint32 headIndex = 10;
inline bool Mention::has_headindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Mention::set_has_headindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Mention::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Mention::clear_headindex() {
  headindex_ = 0u;
  clear_has_headindex();
}
inline ::google::protobuf::uint32 Mention::headindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headIndex)
  return headindex_;
}
inline void Mention::set_headindex(::google::protobuf::uint32 value) {
  set_has_headindex();
  headindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.headIndex)
}

// optional string headString = 11;
inline bool Mention::has_headstring() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Mention::set_has_headstring() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Mention::clear_has_headstring() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Mention::clear_headstring() {
  headstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headstring();
}
inline const ::std::string& Mention::headstring() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headString)
  return headstring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_headstring(const ::std::string& value) {
  set_has_headstring();
  headstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.headString)
}
inline void Mention::set_headstring(const char* value) {
  set_has_headstring();
  headstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.headString)
}
inline void Mention::set_headstring(const char* value, size_t size) {
  set_has_headstring();
  headstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.headString)
}
inline ::std::string* Mention::mutable_headstring() {
  set_has_headstring();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.headString)
  return headstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_headstring() {
  clear_has_headstring();
  return headstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_headstring(::std::string* headstring) {
  if (headstring != NULL) {
    set_has_headstring();
  } else {
    clear_has_headstring();
  }
  headstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headstring);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.headString)
}

// optional string nerString = 12;
inline bool Mention::has_nerstring() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Mention::set_has_nerstring() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Mention::clear_has_nerstring() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Mention::clear_nerstring() {
  nerstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nerstring();
}
inline const ::std::string& Mention::nerstring() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.nerString)
  return nerstring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_nerstring(const ::std::string& value) {
  set_has_nerstring();
  nerstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.nerString)
}
inline void Mention::set_nerstring(const char* value) {
  set_has_nerstring();
  nerstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.nerString)
}
inline void Mention::set_nerstring(const char* value, size_t size) {
  set_has_nerstring();
  nerstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.nerString)
}
inline ::std::string* Mention::mutable_nerstring() {
  set_has_nerstring();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.nerString)
  return nerstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mention::release_nerstring() {
  clear_has_nerstring();
  return nerstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mention::set_allocated_nerstring(::std::string* nerstring) {
  if (nerstring != NULL) {
    set_has_nerstring();
  } else {
    clear_has_nerstring();
  }
  nerstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nerstring);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.nerString)
}

// optional uint32 originalRef = 13;
inline bool Mention::has_originalref() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Mention::set_has_originalref() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Mention::clear_has_originalref() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Mention::clear_originalref() {
  originalref_ = 0u;
  clear_has_originalref();
}
inline ::google::protobuf::uint32 Mention::originalref() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.originalRef)
  return originalref_;
}
inline void Mention::set_originalref(::google::protobuf::uint32 value) {
  set_has_originalref();
  originalref_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.originalRef)
}

// optional int32 goldCorefClusterID = 14;
inline bool Mention::has_goldcorefclusterid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Mention::set_has_goldcorefclusterid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Mention::clear_has_goldcorefclusterid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Mention::clear_goldcorefclusterid() {
  goldcorefclusterid_ = 0;
  clear_has_goldcorefclusterid();
}
inline ::google::protobuf::int32 Mention::goldcorefclusterid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.goldCorefClusterID)
  return goldcorefclusterid_;
}
inline void Mention::set_goldcorefclusterid(::google::protobuf::int32 value) {
  set_has_goldcorefclusterid();
  goldcorefclusterid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.goldCorefClusterID)
}

// optional int32 corefClusterID = 15;
inline bool Mention::has_corefclusterid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Mention::set_has_corefclusterid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Mention::clear_has_corefclusterid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Mention::clear_corefclusterid() {
  corefclusterid_ = 0;
  clear_has_corefclusterid();
}
inline ::google::protobuf::int32 Mention::corefclusterid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.corefClusterID)
  return corefclusterid_;
}
inline void Mention::set_corefclusterid(::google::protobuf::int32 value) {
  set_has_corefclusterid();
  corefclusterid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.corefClusterID)
}

// optional uint32 mentionNum = 16;
inline bool Mention::has_mentionnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Mention::set_has_mentionnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Mention::clear_has_mentionnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Mention::clear_mentionnum() {
  mentionnum_ = 0u;
  clear_has_mentionnum();
}
inline ::google::protobuf::uint32 Mention::mentionnum() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.mentionNum)
  return mentionnum_;
}
inline void Mention::set_mentionnum(::google::protobuf::uint32 value) {
  set_has_mentionnum();
  mentionnum_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.mentionNum)
}

// optional uint32 sentNum = 17;
inline bool Mention::has_sentnum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Mention::set_has_sentnum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Mention::clear_has_sentnum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Mention::clear_sentnum() {
  sentnum_ = 0u;
  clear_has_sentnum();
}
inline ::google::protobuf::uint32 Mention::sentnum() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.sentNum)
  return sentnum_;
}
inline void Mention::set_sentnum(::google::protobuf::uint32 value) {
  set_has_sentnum();
  sentnum_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.sentNum)
}

// optional uint32 utter = 18;
inline bool Mention::has_utter() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Mention::set_has_utter() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Mention::clear_has_utter() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Mention::clear_utter() {
  utter_ = 0u;
  clear_has_utter();
}
inline ::google::protobuf::uint32 Mention::utter() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.utter)
  return utter_;
}
inline void Mention::set_utter(::google::protobuf::uint32 value) {
  set_has_utter();
  utter_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.utter)
}

// optional uint32 paragraph = 19;
inline bool Mention::has_paragraph() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Mention::set_has_paragraph() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Mention::clear_has_paragraph() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Mention::clear_paragraph() {
  paragraph_ = 0u;
  clear_has_paragraph();
}
inline ::google::protobuf::uint32 Mention::paragraph() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.paragraph)
  return paragraph_;
}
inline void Mention::set_paragraph(::google::protobuf::uint32 value) {
  set_has_paragraph();
  paragraph_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.paragraph)
}

// optional bool isSubject = 20;
inline bool Mention::has_issubject() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Mention::set_has_issubject() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Mention::clear_has_issubject() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Mention::clear_issubject() {
  issubject_ = false;
  clear_has_issubject();
}
inline bool Mention::issubject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isSubject)
  return issubject_;
}
inline void Mention::set_issubject(bool value) {
  set_has_issubject();
  issubject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isSubject)
}

// optional bool isDirectObject = 21;
inline bool Mention::has_isdirectobject() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Mention::set_has_isdirectobject() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Mention::clear_has_isdirectobject() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Mention::clear_isdirectobject() {
  isdirectobject_ = false;
  clear_has_isdirectobject();
}
inline bool Mention::isdirectobject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isDirectObject)
  return isdirectobject_;
}
inline void Mention::set_isdirectobject(bool value) {
  set_has_isdirectobject();
  isdirectobject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isDirectObject)
}

// optional bool isIndirectObject = 22;
inline bool Mention::has_isindirectobject() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Mention::set_has_isindirectobject() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Mention::clear_has_isindirectobject() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Mention::clear_isindirectobject() {
  isindirectobject_ = false;
  clear_has_isindirectobject();
}
inline bool Mention::isindirectobject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isIndirectObject)
  return isindirectobject_;
}
inline void Mention::set_isindirectobject(bool value) {
  set_has_isindirectobject();
  isindirectobject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isIndirectObject)
}

// optional bool isPrepositionObject = 23;
inline bool Mention::has_isprepositionobject() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Mention::set_has_isprepositionobject() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Mention::clear_has_isprepositionobject() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Mention::clear_isprepositionobject() {
  isprepositionobject_ = false;
  clear_has_isprepositionobject();
}
inline bool Mention::isprepositionobject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isPrepositionObject)
  return isprepositionobject_;
}
inline void Mention::set_isprepositionobject(bool value) {
  set_has_isprepositionobject();
  isprepositionobject_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isPrepositionObject)
}

// optional bool hasTwin = 24;
inline bool Mention::has_hastwin() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Mention::set_has_hastwin() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Mention::clear_has_hastwin() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Mention::clear_hastwin() {
  hastwin_ = false;
  clear_has_hastwin();
}
inline bool Mention::hastwin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasTwin)
  return hastwin_;
}
inline void Mention::set_hastwin(bool value) {
  set_has_hastwin();
  hastwin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasTwin)
}

// optional bool generic = 25;
inline bool Mention::has_generic() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Mention::set_has_generic() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Mention::clear_has_generic() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Mention::clear_generic() {
  generic_ = false;
  clear_has_generic();
}
inline bool Mention::generic() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.generic)
  return generic_;
}
inline void Mention::set_generic(bool value) {
  set_has_generic();
  generic_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.generic)
}

// optional bool isSingleton = 26;
inline bool Mention::has_issingleton() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Mention::set_has_issingleton() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Mention::clear_has_issingleton() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Mention::clear_issingleton() {
  issingleton_ = false;
  clear_has_issingleton();
}
inline bool Mention::issingleton() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.isSingleton)
  return issingleton_;
}
inline void Mention::set_issingleton(bool value) {
  set_has_issingleton();
  issingleton_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.isSingleton)
}

// optional bool hasBasicDependency = 27;
inline bool Mention::has_hasbasicdependency() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Mention::set_has_hasbasicdependency() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Mention::clear_has_hasbasicdependency() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Mention::clear_hasbasicdependency() {
  hasbasicdependency_ = false;
  clear_has_hasbasicdependency();
}
inline bool Mention::hasbasicdependency() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasBasicDependency)
  return hasbasicdependency_;
}
inline void Mention::set_hasbasicdependency(bool value) {
  set_has_hasbasicdependency();
  hasbasicdependency_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasBasicDependency)
}

// optional bool hasCollapsedDependency = 28;
inline bool Mention::has_hascollapseddependency() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Mention::set_has_hascollapseddependency() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Mention::clear_has_hascollapseddependency() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Mention::clear_hascollapseddependency() {
  hascollapseddependency_ = false;
  clear_has_hascollapseddependency();
}
inline bool Mention::hascollapseddependency() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasCollapsedDependency)
  return hascollapseddependency_;
}
inline void Mention::set_hascollapseddependency(bool value) {
  set_has_hascollapseddependency();
  hascollapseddependency_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasCollapsedDependency)
}

// optional bool hasContextParseTree = 29;
inline bool Mention::has_hascontextparsetree() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Mention::set_has_hascontextparsetree() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Mention::clear_has_hascontextparsetree() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Mention::clear_hascontextparsetree() {
  hascontextparsetree_ = false;
  clear_has_hascontextparsetree();
}
inline bool Mention::hascontextparsetree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.hasContextParseTree)
  return hascontextparsetree_;
}
inline void Mention::set_hascontextparsetree(bool value) {
  set_has_hascontextparsetree();
  hascontextparsetree_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.hasContextParseTree)
}

// optional .edu.stanford.nlp.pipeline.IndexedWord headIndexedWord = 30;
inline bool Mention::has_headindexedword() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Mention::set_has_headindexedword() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Mention::clear_has_headindexedword() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Mention::clear_headindexedword() {
  if (headindexedword_ != NULL) headindexedword_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
  clear_has_headindexedword();
}
inline const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::headindexedword() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headIndexedWord)
  return headindexedword_ != NULL ? *headindexedword_ : *default_instance_->headindexedword_;
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_headindexedword() {
  set_has_headindexedword();
  if (headindexedword_ == NULL) {
    headindexedword_ = new ::edu::stanford::nlp::pipeline::IndexedWord;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.headIndexedWord)
  return headindexedword_;
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::release_headindexedword() {
  clear_has_headindexedword();
  ::edu::stanford::nlp::pipeline::IndexedWord* temp = headindexedword_;
  headindexedword_ = NULL;
  return temp;
}
inline void Mention::set_allocated_headindexedword(::edu::stanford::nlp::pipeline::IndexedWord* headindexedword) {
  delete headindexedword_;
  headindexedword_ = headindexedword;
  if (headindexedword) {
    set_has_headindexedword();
  } else {
    clear_has_headindexedword();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.headIndexedWord)
}

// optional .edu.stanford.nlp.pipeline.IndexedWord dependingVerb = 31;
inline bool Mention::has_dependingverb() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Mention::set_has_dependingverb() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Mention::clear_has_dependingverb() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Mention::clear_dependingverb() {
  if (dependingverb_ != NULL) dependingverb_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
  clear_has_dependingverb();
}
inline const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::dependingverb() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.dependingVerb)
  return dependingverb_ != NULL ? *dependingverb_ : *default_instance_->dependingverb_;
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_dependingverb() {
  set_has_dependingverb();
  if (dependingverb_ == NULL) {
    dependingverb_ = new ::edu::stanford::nlp::pipeline::IndexedWord;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.dependingVerb)
  return dependingverb_;
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::release_dependingverb() {
  clear_has_dependingverb();
  ::edu::stanford::nlp::pipeline::IndexedWord* temp = dependingverb_;
  dependingverb_ = NULL;
  return temp;
}
inline void Mention::set_allocated_dependingverb(::edu::stanford::nlp::pipeline::IndexedWord* dependingverb) {
  delete dependingverb_;
  dependingverb_ = dependingverb;
  if (dependingverb) {
    set_has_dependingverb();
  } else {
    clear_has_dependingverb();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.dependingVerb)
}

// optional .edu.stanford.nlp.pipeline.IndexedWord headWord = 32;
inline bool Mention::has_headword() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Mention::set_has_headword() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Mention::clear_has_headword() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Mention::clear_headword() {
  if (headword_ != NULL) headword_->::edu::stanford::nlp::pipeline::IndexedWord::Clear();
  clear_has_headword();
}
inline const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::headword() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.headWord)
  return headword_ != NULL ? *headword_ : *default_instance_->headword_;
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_headword() {
  set_has_headword();
  if (headword_ == NULL) {
    headword_ = new ::edu::stanford::nlp::pipeline::IndexedWord;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.headWord)
  return headword_;
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::release_headword() {
  clear_has_headword();
  ::edu::stanford::nlp::pipeline::IndexedWord* temp = headword_;
  headword_ = NULL;
  return temp;
}
inline void Mention::set_allocated_headword(::edu::stanford::nlp::pipeline::IndexedWord* headword) {
  delete headword_;
  headword_ = headword;
  if (headword) {
    set_has_headword();
  } else {
    clear_has_headword();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.headWord)
}

// optional .edu.stanford.nlp.pipeline.SpeakerInfo speakerInfo = 33;
inline bool Mention::has_speakerinfo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Mention::set_has_speakerinfo() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Mention::clear_has_speakerinfo() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Mention::clear_speakerinfo() {
  if (speakerinfo_ != NULL) speakerinfo_->::edu::stanford::nlp::pipeline::SpeakerInfo::Clear();
  clear_has_speakerinfo();
}
inline const ::edu::stanford::nlp::pipeline::SpeakerInfo& Mention::speakerinfo() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.speakerInfo)
  return speakerinfo_ != NULL ? *speakerinfo_ : *default_instance_->speakerinfo_;
}
inline ::edu::stanford::nlp::pipeline::SpeakerInfo* Mention::mutable_speakerinfo() {
  set_has_speakerinfo();
  if (speakerinfo_ == NULL) {
    speakerinfo_ = new ::edu::stanford::nlp::pipeline::SpeakerInfo;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.speakerInfo)
  return speakerinfo_;
}
inline ::edu::stanford::nlp::pipeline::SpeakerInfo* Mention::release_speakerinfo() {
  clear_has_speakerinfo();
  ::edu::stanford::nlp::pipeline::SpeakerInfo* temp = speakerinfo_;
  speakerinfo_ = NULL;
  return temp;
}
inline void Mention::set_allocated_speakerinfo(::edu::stanford::nlp::pipeline::SpeakerInfo* speakerinfo) {
  delete speakerinfo_;
  speakerinfo_ = speakerinfo;
  if (speakerinfo) {
    set_has_speakerinfo();
  } else {
    clear_has_speakerinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Mention.speakerInfo)
}

// repeated .edu.stanford.nlp.pipeline.IndexedWord sentenceWords = 50;
inline int Mention::sentencewords_size() const {
  return sentencewords_.size();
}
inline void Mention::clear_sentencewords() {
  sentencewords_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::sentencewords(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_sentencewords(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::add_sentencewords() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >*
Mention::mutable_sentencewords() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return &sentencewords_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >&
Mention::sentencewords() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.sentenceWords)
  return sentencewords_;
}

// repeated .edu.stanford.nlp.pipeline.IndexedWord originalSpan = 51;
inline int Mention::originalspan_size() const {
  return originalspan_.size();
}
inline void Mention::clear_originalspan() {
  originalspan_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::IndexedWord& Mention::originalspan(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::mutable_originalspan(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::IndexedWord* Mention::add_originalspan() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >*
Mention::mutable_originalspan() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return &originalspan_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::IndexedWord >&
Mention::originalspan() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.originalSpan)
  return originalspan_;
}

// repeated string dependents = 52;
inline int Mention::dependents_size() const {
  return dependents_.size();
}
inline void Mention::clear_dependents() {
  dependents_.Clear();
}
inline const ::std::string& Mention::dependents(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.dependents)
  return dependents_.Get(index);
}
inline ::std::string* Mention::mutable_dependents(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.dependents)
  return dependents_.Mutable(index);
}
inline void Mention::set_dependents(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.dependents)
  dependents_.Mutable(index)->assign(value);
}
inline void Mention::set_dependents(int index, const char* value) {
  dependents_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.dependents)
}
inline void Mention::set_dependents(int index, const char* value, size_t size) {
  dependents_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.dependents)
}
inline ::std::string* Mention::add_dependents() {
  return dependents_.Add();
}
inline void Mention::add_dependents(const ::std::string& value) {
  dependents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.dependents)
}
inline void Mention::add_dependents(const char* value) {
  dependents_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Mention.dependents)
}
inline void Mention::add_dependents(const char* value, size_t size) {
  dependents_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Mention.dependents)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mention::dependents() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.dependents)
  return dependents_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mention::mutable_dependents() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.dependents)
  return &dependents_;
}

// repeated string preprocessedTerms = 53;
inline int Mention::preprocessedterms_size() const {
  return preprocessedterms_.size();
}
inline void Mention::clear_preprocessedterms() {
  preprocessedterms_.Clear();
}
inline const ::std::string& Mention::preprocessedterms(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return preprocessedterms_.Get(index);
}
inline ::std::string* Mention::mutable_preprocessedterms(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return preprocessedterms_.Mutable(index);
}
inline void Mention::set_preprocessedterms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  preprocessedterms_.Mutable(index)->assign(value);
}
inline void Mention::set_preprocessedterms(int index, const char* value) {
  preprocessedterms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
inline void Mention::set_preprocessedterms(int index, const char* value, size_t size) {
  preprocessedterms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
inline ::std::string* Mention::add_preprocessedterms() {
  return preprocessedterms_.Add();
}
inline void Mention::add_preprocessedterms(const ::std::string& value) {
  preprocessedterms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
inline void Mention::add_preprocessedterms(const char* value) {
  preprocessedterms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
inline void Mention::add_preprocessedterms(const char* value, size_t size) {
  preprocessedterms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mention::preprocessedterms() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return preprocessedterms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mention::mutable_preprocessedterms() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.preprocessedTerms)
  return &preprocessedterms_;
}

// repeated int32 appositions = 54;
inline int Mention::appositions_size() const {
  return appositions_.size();
}
inline void Mention::clear_appositions() {
  appositions_.Clear();
}
inline ::google::protobuf::int32 Mention::appositions(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.appositions)
  return appositions_.Get(index);
}
inline void Mention::set_appositions(int index, ::google::protobuf::int32 value) {
  appositions_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.appositions)
}
inline void Mention::add_appositions(::google::protobuf::int32 value) {
  appositions_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.appositions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::appositions() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.appositions)
  return appositions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_appositions() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.appositions)
  return &appositions_;
}

// repeated int32 predicateNominatives = 55;
inline int Mention::predicatenominatives_size() const {
  return predicatenominatives_.size();
}
inline void Mention::clear_predicatenominatives() {
  predicatenominatives_.Clear();
}
inline ::google::protobuf::int32 Mention::predicatenominatives(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
  return predicatenominatives_.Get(index);
}
inline void Mention::set_predicatenominatives(int index, ::google::protobuf::int32 value) {
  predicatenominatives_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
}
inline void Mention::add_predicatenominatives(::google::protobuf::int32 value) {
  predicatenominatives_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::predicatenominatives() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
  return predicatenominatives_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_predicatenominatives() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.predicateNominatives)
  return &predicatenominatives_;
}

// repeated int32 relativePronouns = 56;
inline int Mention::relativepronouns_size() const {
  return relativepronouns_.size();
}
inline void Mention::clear_relativepronouns() {
  relativepronouns_.Clear();
}
inline ::google::protobuf::int32 Mention::relativepronouns(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.relativePronouns)
  return relativepronouns_.Get(index);
}
inline void Mention::set_relativepronouns(int index, ::google::protobuf::int32 value) {
  relativepronouns_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.relativePronouns)
}
inline void Mention::add_relativepronouns(::google::protobuf::int32 value) {
  relativepronouns_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.relativePronouns)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::relativepronouns() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.relativePronouns)
  return relativepronouns_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_relativepronouns() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.relativePronouns)
  return &relativepronouns_;
}

// repeated int32 listMembers = 57;
inline int Mention::listmembers_size() const {
  return listmembers_.size();
}
inline void Mention::clear_listmembers() {
  listmembers_.Clear();
}
inline ::google::protobuf::int32 Mention::listmembers(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.listMembers)
  return listmembers_.Get(index);
}
inline void Mention::set_listmembers(int index, ::google::protobuf::int32 value) {
  listmembers_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.listMembers)
}
inline void Mention::add_listmembers(::google::protobuf::int32 value) {
  listmembers_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.listMembers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::listmembers() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.listMembers)
  return listmembers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_listmembers() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.listMembers)
  return &listmembers_;
}

// repeated int32 belongToLists = 58;
inline int Mention::belongtolists_size() const {
  return belongtolists_.size();
}
inline void Mention::clear_belongtolists() {
  belongtolists_.Clear();
}
inline ::google::protobuf::int32 Mention::belongtolists(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Mention.belongToLists)
  return belongtolists_.Get(index);
}
inline void Mention::set_belongtolists(int index, ::google::protobuf::int32 value) {
  belongtolists_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Mention.belongToLists)
}
inline void Mention::add_belongtolists(::google::protobuf::int32 value) {
  belongtolists_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Mention.belongToLists)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Mention::belongtolists() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Mention.belongToLists)
  return belongtolists_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Mention::mutable_belongtolists() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Mention.belongToLists)
  return &belongtolists_;
}

// -------------------------------------------------------------------

// IndexedWord

// optional uint32 sentenceNum = 1;
inline bool IndexedWord::has_sentencenum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexedWord::set_has_sentencenum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexedWord::clear_has_sentencenum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexedWord::clear_sentencenum() {
  sentencenum_ = 0u;
  clear_has_sentencenum();
}
inline ::google::protobuf::uint32 IndexedWord::sentencenum() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.sentenceNum)
  return sentencenum_;
}
inline void IndexedWord::set_sentencenum(::google::protobuf::uint32 value) {
  set_has_sentencenum();
  sentencenum_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.sentenceNum)
}

// optional uint32 tokenIndex = 2;
inline bool IndexedWord::has_tokenindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexedWord::set_has_tokenindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexedWord::clear_has_tokenindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexedWord::clear_tokenindex() {
  tokenindex_ = 0u;
  clear_has_tokenindex();
}
inline ::google::protobuf::uint32 IndexedWord::tokenindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.tokenIndex)
  return tokenindex_;
}
inline void IndexedWord::set_tokenindex(::google::protobuf::uint32 value) {
  set_has_tokenindex();
  tokenindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.tokenIndex)
}

// optional uint32 docID = 3;
inline bool IndexedWord::has_docid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexedWord::set_has_docid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexedWord::clear_has_docid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexedWord::clear_docid() {
  docid_ = 0u;
  clear_has_docid();
}
inline ::google::protobuf::uint32 IndexedWord::docid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.docID)
  return docid_;
}
inline void IndexedWord::set_docid(::google::protobuf::uint32 value) {
  set_has_docid();
  docid_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.docID)
}

// optional uint32 copyCount = 4;
inline bool IndexedWord::has_copycount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IndexedWord::set_has_copycount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IndexedWord::clear_has_copycount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IndexedWord::clear_copycount() {
  copycount_ = 0u;
  clear_has_copycount();
}
inline ::google::protobuf::uint32 IndexedWord::copycount() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.IndexedWord.copyCount)
  return copycount_;
}
inline void IndexedWord::set_copycount(::google::protobuf::uint32 value) {
  set_has_copycount();
  copycount_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.IndexedWord.copyCount)
}

// -------------------------------------------------------------------

// SpeakerInfo

// optional string speakerName = 1;
inline bool SpeakerInfo::has_speakername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeakerInfo::set_has_speakername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeakerInfo::clear_has_speakername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeakerInfo::clear_speakername() {
  speakername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_speakername();
}
inline const ::std::string& SpeakerInfo::speakername() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
  return speakername_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeakerInfo::set_speakername(const ::std::string& value) {
  set_has_speakername();
  speakername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}
inline void SpeakerInfo::set_speakername(const char* value) {
  set_has_speakername();
  speakername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}
inline void SpeakerInfo::set_speakername(const char* value, size_t size) {
  set_has_speakername();
  speakername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}
inline ::std::string* SpeakerInfo::mutable_speakername() {
  set_has_speakername();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
  return speakername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeakerInfo::release_speakername() {
  clear_has_speakername();
  return speakername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeakerInfo::set_allocated_speakername(::std::string* speakername) {
  if (speakername != NULL) {
    set_has_speakername();
  } else {
    clear_has_speakername();
  }
  speakername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), speakername);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.SpeakerInfo.speakerName)
}

// repeated int32 mentions = 2;
inline int SpeakerInfo::mentions_size() const {
  return mentions_.size();
}
inline void SpeakerInfo::clear_mentions() {
  mentions_.Clear();
}
inline ::google::protobuf::int32 SpeakerInfo::mentions(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
  return mentions_.Get(index);
}
inline void SpeakerInfo::set_mentions(int index, ::google::protobuf::int32 value) {
  mentions_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
}
inline void SpeakerInfo::add_mentions(::google::protobuf::int32 value) {
  mentions_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SpeakerInfo::mentions() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
  return mentions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SpeakerInfo::mutable_mentions() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.SpeakerInfo.mentions)
  return &mentions_;
}

// -------------------------------------------------------------------

// Span

// required uint32 begin = 1;
inline bool Span::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Span::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Span::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Span::clear_begin() {
  begin_ = 0u;
  clear_has_begin();
}
inline ::google::protobuf::uint32 Span::begin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Span.begin)
  return begin_;
}
inline void Span::set_begin(::google::protobuf::uint32 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Span.begin)
}

// required uint32 end = 2;
inline bool Span::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Span::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Span::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Span::clear_end() {
  end_ = 0u;
  clear_has_end();
}
inline ::google::protobuf::uint32 Span::end() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Span.end)
  return end_;
}
inline void Span::set_end(::google::protobuf::uint32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Span.end)
}

// -------------------------------------------------------------------

// Timex

// optional string value = 1;
inline bool Timex::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timex::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timex::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timex::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Timex::value() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.value)
}
inline void Timex::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.value)
}
inline void Timex::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.value)
}
inline ::std::string* Timex::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Timex::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.value)
}

// optional string altValue = 2;
inline bool Timex::has_altvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timex::set_has_altvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timex::clear_has_altvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timex::clear_altvalue() {
  altvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_altvalue();
}
inline const ::std::string& Timex::altvalue() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.altValue)
  return altvalue_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_altvalue(const ::std::string& value) {
  set_has_altvalue();
  altvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.altValue)
}
inline void Timex::set_altvalue(const char* value) {
  set_has_altvalue();
  altvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.altValue)
}
inline void Timex::set_altvalue(const char* value, size_t size) {
  set_has_altvalue();
  altvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.altValue)
}
inline ::std::string* Timex::mutable_altvalue() {
  set_has_altvalue();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.altValue)
  return altvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Timex::release_altvalue() {
  clear_has_altvalue();
  return altvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_allocated_altvalue(::std::string* altvalue) {
  if (altvalue != NULL) {
    set_has_altvalue();
  } else {
    clear_has_altvalue();
  }
  altvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), altvalue);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.altValue)
}

// optional string text = 3;
inline bool Timex::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Timex::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Timex::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Timex::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Timex::text() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.text)
}
inline void Timex::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.text)
}
inline void Timex::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.text)
}
inline ::std::string* Timex::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Timex::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.text)
}

// optional string type = 4;
inline bool Timex::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Timex::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Timex::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Timex::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Timex::type() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.type)
}
inline void Timex::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.type)
}
inline void Timex::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.type)
}
inline ::std::string* Timex::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Timex::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.type)
}

// optional string tid = 5;
inline bool Timex::has_tid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Timex::set_has_tid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Timex::clear_has_tid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Timex::clear_tid() {
  tid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tid();
}
inline const ::std::string& Timex::tid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.tid)
  return tid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_tid(const ::std::string& value) {
  set_has_tid();
  tid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.tid)
}
inline void Timex::set_tid(const char* value) {
  set_has_tid();
  tid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Timex.tid)
}
inline void Timex::set_tid(const char* value, size_t size) {
  set_has_tid();
  tid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Timex.tid)
}
inline ::std::string* Timex::mutable_tid() {
  set_has_tid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Timex.tid)
  return tid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Timex::release_tid() {
  clear_has_tid();
  return tid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Timex::set_allocated_tid(::std::string* tid) {
  if (tid != NULL) {
    set_has_tid();
  } else {
    clear_has_tid();
  }
  tid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Timex.tid)
}

// optional uint32 beginPoint = 6;
inline bool Timex::has_beginpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Timex::set_has_beginpoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Timex::clear_has_beginpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Timex::clear_beginpoint() {
  beginpoint_ = 0u;
  clear_has_beginpoint();
}
inline ::google::protobuf::uint32 Timex::beginpoint() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.beginPoint)
  return beginpoint_;
}
inline void Timex::set_beginpoint(::google::protobuf::uint32 value) {
  set_has_beginpoint();
  beginpoint_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.beginPoint)
}

// optional uint32 endPoint = 7;
inline bool Timex::has_endpoint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Timex::set_has_endpoint() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Timex::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Timex::clear_endpoint() {
  endpoint_ = 0u;
  clear_has_endpoint();
}
inline ::google::protobuf::uint32 Timex::endpoint() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Timex.endPoint)
  return endpoint_;
}
inline void Timex::set_endpoint(::google::protobuf::uint32 value) {
  set_has_endpoint();
  endpoint_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Timex.endPoint)
}

// -------------------------------------------------------------------

// Entity

// optional uint32 headStart = 6;
inline bool Entity::has_headstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_headstart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_headstart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_headstart() {
  headstart_ = 0u;
  clear_has_headstart();
}
inline ::google::protobuf::uint32 Entity::headstart() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.headStart)
  return headstart_;
}
inline void Entity::set_headstart(::google::protobuf::uint32 value) {
  set_has_headstart();
  headstart_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.headStart)
}

// optional uint32 headEnd = 7;
inline bool Entity::has_headend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_headend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_headend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_headend() {
  headend_ = 0u;
  clear_has_headend();
}
inline ::google::protobuf::uint32 Entity::headend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.headEnd)
  return headend_;
}
inline void Entity::set_headend(::google::protobuf::uint32 value) {
  set_has_headend();
  headend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.headEnd)
}

// optional string mentionType = 8;
inline bool Entity::has_mentiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_mentiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_mentiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_mentiontype() {
  mentiontype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mentiontype();
}
inline const ::std::string& Entity::mentiontype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.mentionType)
  return mentiontype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_mentiontype(const ::std::string& value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.mentionType)
}
inline void Entity::set_mentiontype(const char* value) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.mentionType)
}
inline void Entity::set_mentiontype(const char* value, size_t size) {
  set_has_mentiontype();
  mentiontype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.mentionType)
}
inline ::std::string* Entity::mutable_mentiontype() {
  set_has_mentiontype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.mentionType)
  return mentiontype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_mentiontype() {
  clear_has_mentiontype();
  return mentiontype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_mentiontype(::std::string* mentiontype) {
  if (mentiontype != NULL) {
    set_has_mentiontype();
  } else {
    clear_has_mentiontype();
  }
  mentiontype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mentiontype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.mentionType)
}

// optional string normalizedName = 9;
inline bool Entity::has_normalizedname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_normalizedname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_normalizedname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_normalizedname() {
  normalizedname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_normalizedname();
}
inline const ::std::string& Entity::normalizedname() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.normalizedName)
  return normalizedname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_normalizedname(const ::std::string& value) {
  set_has_normalizedname();
  normalizedname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.normalizedName)
}
inline void Entity::set_normalizedname(const char* value) {
  set_has_normalizedname();
  normalizedname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.normalizedName)
}
inline void Entity::set_normalizedname(const char* value, size_t size) {
  set_has_normalizedname();
  normalizedname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.normalizedName)
}
inline ::std::string* Entity::mutable_normalizedname() {
  set_has_normalizedname();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.normalizedName)
  return normalizedname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_normalizedname() {
  clear_has_normalizedname();
  return normalizedname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_normalizedname(::std::string* normalizedname) {
  if (normalizedname != NULL) {
    set_has_normalizedname();
  } else {
    clear_has_normalizedname();
  }
  normalizedname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normalizedname);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.normalizedName)
}

// optional uint32 headTokenIndex = 10;
inline bool Entity::has_headtokenindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Entity::set_has_headtokenindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Entity::clear_has_headtokenindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Entity::clear_headtokenindex() {
  headtokenindex_ = 0u;
  clear_has_headtokenindex();
}
inline ::google::protobuf::uint32 Entity::headtokenindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.headTokenIndex)
  return headtokenindex_;
}
inline void Entity::set_headtokenindex(::google::protobuf::uint32 value) {
  set_has_headtokenindex();
  headtokenindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.headTokenIndex)
}

// optional string corefID = 11;
inline bool Entity::has_corefid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Entity::set_has_corefid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Entity::clear_has_corefid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Entity::clear_corefid() {
  corefid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_corefid();
}
inline const ::std::string& Entity::corefid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.corefID)
  return corefid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_corefid(const ::std::string& value) {
  set_has_corefid();
  corefid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.corefID)
}
inline void Entity::set_corefid(const char* value) {
  set_has_corefid();
  corefid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.corefID)
}
inline void Entity::set_corefid(const char* value, size_t size) {
  set_has_corefid();
  corefid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.corefID)
}
inline ::std::string* Entity::mutable_corefid() {
  set_has_corefid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.corefID)
  return corefid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_corefid() {
  clear_has_corefid();
  return corefid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_corefid(::std::string* corefid) {
  if (corefid != NULL) {
    set_has_corefid();
  } else {
    clear_has_corefid();
  }
  corefid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), corefid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.corefID)
}

// optional string objectID = 1;
inline bool Entity::has_objectid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Entity::set_has_objectid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Entity::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Entity::clear_objectid() {
  objectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_objectid();
}
inline const ::std::string& Entity::objectid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.objectID)
  return objectid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_objectid(const ::std::string& value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.objectID)
}
inline void Entity::set_objectid(const char* value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.objectID)
}
inline void Entity::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.objectID)
}
inline ::std::string* Entity::mutable_objectid() {
  set_has_objectid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.objectID)
  return objectid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_objectid() {
  clear_has_objectid();
  return objectid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_objectid(::std::string* objectid) {
  if (objectid != NULL) {
    set_has_objectid();
  } else {
    clear_has_objectid();
  }
  objectid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), objectid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.objectID)
}

// optional uint32 extentStart = 2;
inline bool Entity::has_extentstart() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Entity::set_has_extentstart() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Entity::clear_has_extentstart() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Entity::clear_extentstart() {
  extentstart_ = 0u;
  clear_has_extentstart();
}
inline ::google::protobuf::uint32 Entity::extentstart() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.extentStart)
  return extentstart_;
}
inline void Entity::set_extentstart(::google::protobuf::uint32 value) {
  set_has_extentstart();
  extentstart_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.extentStart)
}

// optional uint32 extentEnd = 3;
inline bool Entity::has_extentend() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Entity::set_has_extentend() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Entity::clear_has_extentend() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Entity::clear_extentend() {
  extentend_ = 0u;
  clear_has_extentend();
}
inline ::google::protobuf::uint32 Entity::extentend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.extentEnd)
  return extentend_;
}
inline void Entity::set_extentend(::google::protobuf::uint32 value) {
  set_has_extentend();
  extentend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.extentEnd)
}

// optional string type = 4;
inline bool Entity::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Entity::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Entity::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Entity::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Entity::type() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.type)
}
inline void Entity::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.type)
}
inline void Entity::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.type)
}
inline ::std::string* Entity::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.type)
}

// optional string subtype = 5;
inline bool Entity::has_subtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Entity::set_has_subtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Entity::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Entity::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subtype();
}
inline const ::std::string& Entity::subtype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Entity.subtype)
  return subtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_subtype(const ::std::string& value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Entity.subtype)
}
inline void Entity::set_subtype(const char* value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Entity.subtype)
}
inline void Entity::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Entity.subtype)
}
inline ::std::string* Entity::mutable_subtype() {
  set_has_subtype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Entity.subtype)
  return subtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_subtype() {
  clear_has_subtype();
  return subtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_subtype(::std::string* subtype) {
  if (subtype != NULL) {
    set_has_subtype();
  } else {
    clear_has_subtype();
  }
  subtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Entity.subtype)
}

// -------------------------------------------------------------------

// Relation

// repeated string argName = 6;
inline int Relation::argname_size() const {
  return argname_.size();
}
inline void Relation::clear_argname() {
  argname_.Clear();
}
inline const ::std::string& Relation::argname(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.argName)
  return argname_.Get(index);
}
inline ::std::string* Relation::mutable_argname(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.argName)
  return argname_.Mutable(index);
}
inline void Relation::set_argname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.argName)
  argname_.Mutable(index)->assign(value);
}
inline void Relation::set_argname(int index, const char* value) {
  argname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.argName)
}
inline void Relation::set_argname(int index, const char* value, size_t size) {
  argname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.argName)
}
inline ::std::string* Relation::add_argname() {
  return argname_.Add();
}
inline void Relation::add_argname(const ::std::string& value) {
  argname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Relation.argName)
}
inline void Relation::add_argname(const char* value) {
  argname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.Relation.argName)
}
inline void Relation::add_argname(const char* value, size_t size) {
  argname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.Relation.argName)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Relation::argname() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Relation.argName)
  return argname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Relation::mutable_argname() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Relation.argName)
  return &argname_;
}

// repeated .edu.stanford.nlp.pipeline.Entity arg = 7;
inline int Relation::arg_size() const {
  return arg_.size();
}
inline void Relation::clear_arg() {
  arg_.Clear();
}
inline const ::edu::stanford::nlp::pipeline::Entity& Relation::arg(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_.Get(index);
}
inline ::edu::stanford::nlp::pipeline::Entity* Relation::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_.Mutable(index);
}
inline ::edu::stanford::nlp::pipeline::Entity* Relation::add_arg() {
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >*
Relation::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.Relation.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::edu::stanford::nlp::pipeline::Entity >&
Relation::arg() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.Relation.arg)
  return arg_;
}

// optional string signature = 8;
inline bool Relation::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Relation::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Relation::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Relation::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& Relation::signature() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.signature)
}
inline void Relation::set_signature(const char* value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.signature)
}
inline void Relation::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.signature)
}
inline ::std::string* Relation::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Relation::release_signature() {
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.signature)
}

// optional string objectID = 1;
inline bool Relation::has_objectid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Relation::set_has_objectid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Relation::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Relation::clear_objectid() {
  objectid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_objectid();
}
inline const ::std::string& Relation::objectid() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.objectID)
  return objectid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_objectid(const ::std::string& value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.objectID)
}
inline void Relation::set_objectid(const char* value) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.objectID)
}
inline void Relation::set_objectid(const char* value, size_t size) {
  set_has_objectid();
  objectid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.objectID)
}
inline ::std::string* Relation::mutable_objectid() {
  set_has_objectid();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.objectID)
  return objectid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Relation::release_objectid() {
  clear_has_objectid();
  return objectid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_allocated_objectid(::std::string* objectid) {
  if (objectid != NULL) {
    set_has_objectid();
  } else {
    clear_has_objectid();
  }
  objectid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), objectid);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.objectID)
}

// optional uint32 extentStart = 2;
inline bool Relation::has_extentstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Relation::set_has_extentstart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Relation::clear_has_extentstart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Relation::clear_extentstart() {
  extentstart_ = 0u;
  clear_has_extentstart();
}
inline ::google::protobuf::uint32 Relation::extentstart() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.extentStart)
  return extentstart_;
}
inline void Relation::set_extentstart(::google::protobuf::uint32 value) {
  set_has_extentstart();
  extentstart_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.extentStart)
}

// optional uint32 extentEnd = 3;
inline bool Relation::has_extentend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Relation::set_has_extentend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Relation::clear_has_extentend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Relation::clear_extentend() {
  extentend_ = 0u;
  clear_has_extentend();
}
inline ::google::protobuf::uint32 Relation::extentend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.extentEnd)
  return extentend_;
}
inline void Relation::set_extentend(::google::protobuf::uint32 value) {
  set_has_extentend();
  extentend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.extentEnd)
}

// optional string type = 4;
inline bool Relation::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Relation::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Relation::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Relation::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& Relation::type() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.type)
}
inline void Relation::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.type)
}
inline void Relation::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.type)
}
inline ::std::string* Relation::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Relation::release_type() {
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.type)
}

// optional string subtype = 5;
inline bool Relation::has_subtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Relation::set_has_subtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Relation::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Relation::clear_subtype() {
  subtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subtype();
}
inline const ::std::string& Relation::subtype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Relation.subtype)
  return subtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_subtype(const ::std::string& value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Relation.subtype)
}
inline void Relation::set_subtype(const char* value) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Relation.subtype)
}
inline void Relation::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  subtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Relation.subtype)
}
inline ::std::string* Relation::mutable_subtype() {
  set_has_subtype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Relation.subtype)
  return subtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Relation::release_subtype() {
  clear_has_subtype();
  return subtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Relation::set_allocated_subtype(::std::string* subtype) {
  if (subtype != NULL) {
    set_has_subtype();
  } else {
    clear_has_subtype();
  }
  subtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subtype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Relation.subtype)
}

// -------------------------------------------------------------------

// Operator

// required string name = 1;
inline bool Operator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operator::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operator::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.name)
}
inline void Operator::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.Operator.name)
}
inline void Operator::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.Operator.name)
}
inline ::std::string* Operator::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.Operator.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operator::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operator::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.Operator.name)
}

// required int32 quantifierSpanBegin = 2;
inline bool Operator::has_quantifierspanbegin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operator::set_has_quantifierspanbegin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operator::clear_has_quantifierspanbegin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operator::clear_quantifierspanbegin() {
  quantifierspanbegin_ = 0;
  clear_has_quantifierspanbegin();
}
inline ::google::protobuf::int32 Operator::quantifierspanbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.quantifierSpanBegin)
  return quantifierspanbegin_;
}
inline void Operator::set_quantifierspanbegin(::google::protobuf::int32 value) {
  set_has_quantifierspanbegin();
  quantifierspanbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.quantifierSpanBegin)
}

// required int32 quantifierSpanEnd = 3;
inline bool Operator::has_quantifierspanend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operator::set_has_quantifierspanend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operator::clear_has_quantifierspanend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operator::clear_quantifierspanend() {
  quantifierspanend_ = 0;
  clear_has_quantifierspanend();
}
inline ::google::protobuf::int32 Operator::quantifierspanend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.quantifierSpanEnd)
  return quantifierspanend_;
}
inline void Operator::set_quantifierspanend(::google::protobuf::int32 value) {
  set_has_quantifierspanend();
  quantifierspanend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.quantifierSpanEnd)
}

// required int32 subjectSpanBegin = 4;
inline bool Operator::has_subjectspanbegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operator::set_has_subjectspanbegin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operator::clear_has_subjectspanbegin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operator::clear_subjectspanbegin() {
  subjectspanbegin_ = 0;
  clear_has_subjectspanbegin();
}
inline ::google::protobuf::int32 Operator::subjectspanbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.subjectSpanBegin)
  return subjectspanbegin_;
}
inline void Operator::set_subjectspanbegin(::google::protobuf::int32 value) {
  set_has_subjectspanbegin();
  subjectspanbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.subjectSpanBegin)
}

// required int32 subjectSpanEnd = 5;
inline bool Operator::has_subjectspanend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Operator::set_has_subjectspanend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Operator::clear_has_subjectspanend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Operator::clear_subjectspanend() {
  subjectspanend_ = 0;
  clear_has_subjectspanend();
}
inline ::google::protobuf::int32 Operator::subjectspanend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.subjectSpanEnd)
  return subjectspanend_;
}
inline void Operator::set_subjectspanend(::google::protobuf::int32 value) {
  set_has_subjectspanend();
  subjectspanend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.subjectSpanEnd)
}

// required int32 objectSpanBegin = 6;
inline bool Operator::has_objectspanbegin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Operator::set_has_objectspanbegin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Operator::clear_has_objectspanbegin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Operator::clear_objectspanbegin() {
  objectspanbegin_ = 0;
  clear_has_objectspanbegin();
}
inline ::google::protobuf::int32 Operator::objectspanbegin() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.objectSpanBegin)
  return objectspanbegin_;
}
inline void Operator::set_objectspanbegin(::google::protobuf::int32 value) {
  set_has_objectspanbegin();
  objectspanbegin_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.objectSpanBegin)
}

// required int32 objectSpanEnd = 7;
inline bool Operator::has_objectspanend() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Operator::set_has_objectspanend() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Operator::clear_has_objectspanend() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Operator::clear_objectspanend() {
  objectspanend_ = 0;
  clear_has_objectspanend();
}
inline ::google::protobuf::int32 Operator::objectspanend() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Operator.objectSpanEnd)
  return objectspanend_;
}
inline void Operator::set_objectspanend(::google::protobuf::int32 value) {
  set_has_objectspanend();
  objectspanend_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Operator.objectSpanEnd)
}

// -------------------------------------------------------------------

// Polarity

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectEquivalence = 1;
inline bool Polarity::has_projectequivalence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Polarity::set_has_projectequivalence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Polarity::clear_has_projectequivalence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Polarity::clear_projectequivalence() {
  projectequivalence_ = 0;
  clear_has_projectequivalence();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectequivalence() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectEquivalence)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectequivalence_);
}
inline void Polarity::set_projectequivalence(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectequivalence();
  projectequivalence_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectEquivalence)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectForwardEntailment = 2;
inline bool Polarity::has_projectforwardentailment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Polarity::set_has_projectforwardentailment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Polarity::clear_has_projectforwardentailment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Polarity::clear_projectforwardentailment() {
  projectforwardentailment_ = 0;
  clear_has_projectforwardentailment();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectforwardentailment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectForwardEntailment)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectforwardentailment_);
}
inline void Polarity::set_projectforwardentailment(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectforwardentailment();
  projectforwardentailment_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectForwardEntailment)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectReverseEntailment = 3;
inline bool Polarity::has_projectreverseentailment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Polarity::set_has_projectreverseentailment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Polarity::clear_has_projectreverseentailment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Polarity::clear_projectreverseentailment() {
  projectreverseentailment_ = 0;
  clear_has_projectreverseentailment();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectreverseentailment() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectReverseEntailment)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectreverseentailment_);
}
inline void Polarity::set_projectreverseentailment(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectreverseentailment();
  projectreverseentailment_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectReverseEntailment)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectNegation = 4;
inline bool Polarity::has_projectnegation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Polarity::set_has_projectnegation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Polarity::clear_has_projectnegation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Polarity::clear_projectnegation() {
  projectnegation_ = 0;
  clear_has_projectnegation();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectnegation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectNegation)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectnegation_);
}
inline void Polarity::set_projectnegation(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectnegation();
  projectnegation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectNegation)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectAlternation = 5;
inline bool Polarity::has_projectalternation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Polarity::set_has_projectalternation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Polarity::clear_has_projectalternation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Polarity::clear_projectalternation() {
  projectalternation_ = 0;
  clear_has_projectalternation();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectalternation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectAlternation)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectalternation_);
}
inline void Polarity::set_projectalternation(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectalternation();
  projectalternation_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectAlternation)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectCover = 6;
inline bool Polarity::has_projectcover() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Polarity::set_has_projectcover() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Polarity::clear_has_projectcover() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Polarity::clear_projectcover() {
  projectcover_ = 0;
  clear_has_projectcover();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectcover() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectCover)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectcover_);
}
inline void Polarity::set_projectcover(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectcover();
  projectcover_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectCover)
}

// required .edu.stanford.nlp.pipeline.NaturalLogicRelation projectIndependence = 7;
inline bool Polarity::has_projectindependence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Polarity::set_has_projectindependence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Polarity::clear_has_projectindependence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Polarity::clear_projectindependence() {
  projectindependence_ = 0;
  clear_has_projectindependence();
}
inline ::edu::stanford::nlp::pipeline::NaturalLogicRelation Polarity::projectindependence() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.Polarity.projectIndependence)
  return static_cast< ::edu::stanford::nlp::pipeline::NaturalLogicRelation >(projectindependence_);
}
inline void Polarity::set_projectindependence(::edu::stanford::nlp::pipeline::NaturalLogicRelation value) {
  assert(::edu::stanford::nlp::pipeline::NaturalLogicRelation_IsValid(value));
  set_has_projectindependence();
  projectindependence_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.Polarity.projectIndependence)
}

// -------------------------------------------------------------------

// NERMention

// optional uint32 sentenceIndex = 1;
inline bool NERMention::has_sentenceindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NERMention::set_has_sentenceindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NERMention::clear_has_sentenceindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NERMention::clear_sentenceindex() {
  sentenceindex_ = 0u;
  clear_has_sentenceindex();
}
inline ::google::protobuf::uint32 NERMention::sentenceindex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.sentenceIndex)
  return sentenceindex_;
}
inline void NERMention::set_sentenceindex(::google::protobuf::uint32 value) {
  set_has_sentenceindex();
  sentenceindex_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.sentenceIndex)
}

// required uint32 tokenStartInSentenceInclusive = 2;
inline bool NERMention::has_tokenstartinsentenceinclusive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NERMention::set_has_tokenstartinsentenceinclusive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NERMention::clear_has_tokenstartinsentenceinclusive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NERMention::clear_tokenstartinsentenceinclusive() {
  tokenstartinsentenceinclusive_ = 0u;
  clear_has_tokenstartinsentenceinclusive();
}
inline ::google::protobuf::uint32 NERMention::tokenstartinsentenceinclusive() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.tokenStartInSentenceInclusive)
  return tokenstartinsentenceinclusive_;
}
inline void NERMention::set_tokenstartinsentenceinclusive(::google::protobuf::uint32 value) {
  set_has_tokenstartinsentenceinclusive();
  tokenstartinsentenceinclusive_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.tokenStartInSentenceInclusive)
}

// required uint32 tokenEndInSentenceExclusive = 3;
inline bool NERMention::has_tokenendinsentenceexclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NERMention::set_has_tokenendinsentenceexclusive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NERMention::clear_has_tokenendinsentenceexclusive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NERMention::clear_tokenendinsentenceexclusive() {
  tokenendinsentenceexclusive_ = 0u;
  clear_has_tokenendinsentenceexclusive();
}
inline ::google::protobuf::uint32 NERMention::tokenendinsentenceexclusive() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.tokenEndInSentenceExclusive)
  return tokenendinsentenceexclusive_;
}
inline void NERMention::set_tokenendinsentenceexclusive(::google::protobuf::uint32 value) {
  set_has_tokenendinsentenceexclusive();
  tokenendinsentenceexclusive_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.tokenEndInSentenceExclusive)
}

// required string ner = 4;
inline bool NERMention::has_ner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NERMention::set_has_ner() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NERMention::clear_has_ner() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NERMention::clear_ner() {
  ner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ner();
}
inline const ::std::string& NERMention::ner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.ner)
  return ner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NERMention::set_ner(const ::std::string& value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.ner)
}
inline void NERMention::set_ner(const char* value) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.NERMention.ner)
}
inline void NERMention::set_ner(const char* value, size_t size) {
  set_has_ner();
  ner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.NERMention.ner)
}
inline ::std::string* NERMention::mutable_ner() {
  set_has_ner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.ner)
  return ner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NERMention::release_ner() {
  clear_has_ner();
  return ner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NERMention::set_allocated_ner(::std::string* ner) {
  if (ner != NULL) {
    set_has_ner();
  } else {
    clear_has_ner();
  }
  ner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.ner)
}

// optional string normalizedNER = 5;
inline bool NERMention::has_normalizedner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NERMention::set_has_normalizedner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NERMention::clear_has_normalizedner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NERMention::clear_normalizedner() {
  normalizedner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_normalizedner();
}
inline const ::std::string& NERMention::normalizedner() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
  return normalizedner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NERMention::set_normalizedner(const ::std::string& value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}
inline void NERMention::set_normalizedner(const char* value) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}
inline void NERMention::set_normalizedner(const char* value, size_t size) {
  set_has_normalizedner();
  normalizedner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}
inline ::std::string* NERMention::mutable_normalizedner() {
  set_has_normalizedner();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
  return normalizedner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NERMention::release_normalizedner() {
  clear_has_normalizedner();
  return normalizedner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NERMention::set_allocated_normalizedner(::std::string* normalizedner) {
  if (normalizedner != NULL) {
    set_has_normalizedner();
  } else {
    clear_has_normalizedner();
  }
  normalizedner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normalizedner);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.normalizedNER)
}

// optional string entityType = 6;
inline bool NERMention::has_entitytype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NERMention::set_has_entitytype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NERMention::clear_has_entitytype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NERMention::clear_entitytype() {
  entitytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entitytype();
}
inline const ::std::string& NERMention::entitytype() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.entityType)
  return entitytype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NERMention::set_entitytype(const ::std::string& value) {
  set_has_entitytype();
  entitytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.NERMention.entityType)
}
inline void NERMention::set_entitytype(const char* value) {
  set_has_entitytype();
  entitytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.NERMention.entityType)
}
inline void NERMention::set_entitytype(const char* value, size_t size) {
  set_has_entitytype();
  entitytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.NERMention.entityType)
}
inline ::std::string* NERMention::mutable_entitytype() {
  set_has_entitytype();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.entityType)
  return entitytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NERMention::release_entitytype() {
  clear_has_entitytype();
  return entitytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NERMention::set_allocated_entitytype(::std::string* entitytype) {
  if (entitytype != NULL) {
    set_has_entitytype();
  } else {
    clear_has_entitytype();
  }
  entitytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entitytype);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.entityType)
}

// optional .edu.stanford.nlp.pipeline.Timex timex = 7;
inline bool NERMention::has_timex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NERMention::set_has_timex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NERMention::clear_has_timex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NERMention::clear_timex() {
  if (timex_ != NULL) timex_->::edu::stanford::nlp::pipeline::Timex::Clear();
  clear_has_timex();
}
inline const ::edu::stanford::nlp::pipeline::Timex& NERMention::timex() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.NERMention.timex)
  return timex_ != NULL ? *timex_ : *default_instance_->timex_;
}
inline ::edu::stanford::nlp::pipeline::Timex* NERMention::mutable_timex() {
  set_has_timex();
  if (timex_ == NULL) {
    timex_ = new ::edu::stanford::nlp::pipeline::Timex;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.NERMention.timex)
  return timex_;
}
inline ::edu::stanford::nlp::pipeline::Timex* NERMention::release_timex() {
  clear_has_timex();
  ::edu::stanford::nlp::pipeline::Timex* temp = timex_;
  timex_ = NULL;
  return temp;
}
inline void NERMention::set_allocated_timex(::edu::stanford::nlp::pipeline::Timex* timex) {
  delete timex_;
  timex_ = timex;
  if (timex) {
    set_has_timex();
  } else {
    clear_has_timex();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.NERMention.timex)
}

// -------------------------------------------------------------------

// SentenceFragment

// repeated uint32 tokenIndex = 1;
inline int SentenceFragment::tokenindex_size() const {
  return tokenindex_.size();
}
inline void SentenceFragment::clear_tokenindex() {
  tokenindex_.Clear();
}
inline ::google::protobuf::uint32 SentenceFragment::tokenindex(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
  return tokenindex_.Get(index);
}
inline void SentenceFragment::set_tokenindex(int index, ::google::protobuf::uint32 value) {
  tokenindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
}
inline void SentenceFragment::add_tokenindex(::google::protobuf::uint32 value) {
  tokenindex_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SentenceFragment::tokenindex() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
  return tokenindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SentenceFragment::mutable_tokenindex() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.SentenceFragment.tokenIndex)
  return &tokenindex_;
}

// optional uint32 root = 2;
inline bool SentenceFragment::has_root() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SentenceFragment::set_has_root() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SentenceFragment::clear_has_root() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SentenceFragment::clear_root() {
  root_ = 0u;
  clear_has_root();
}
inline ::google::protobuf::uint32 SentenceFragment::root() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.root)
  return root_;
}
inline void SentenceFragment::set_root(::google::protobuf::uint32 value) {
  set_has_root();
  root_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.root)
}

// optional bool assumedTruth = 3;
inline bool SentenceFragment::has_assumedtruth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SentenceFragment::set_has_assumedtruth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SentenceFragment::clear_has_assumedtruth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SentenceFragment::clear_assumedtruth() {
  assumedtruth_ = false;
  clear_has_assumedtruth();
}
inline bool SentenceFragment::assumedtruth() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.assumedTruth)
  return assumedtruth_;
}
inline void SentenceFragment::set_assumedtruth(bool value) {
  set_has_assumedtruth();
  assumedtruth_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.assumedTruth)
}

// optional double score = 4;
inline bool SentenceFragment::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SentenceFragment::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SentenceFragment::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SentenceFragment::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double SentenceFragment::score() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.SentenceFragment.score)
  return score_;
}
inline void SentenceFragment::set_score(double value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.SentenceFragment.score)
}

// -------------------------------------------------------------------

// RelationTriple

// optional string subject = 1;
inline bool RelationTriple::has_subject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelationTriple::set_has_subject() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelationTriple::clear_has_subject() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelationTriple::clear_subject() {
  subject_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subject();
}
inline const ::std::string& RelationTriple::subject() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.subject)
  return subject_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelationTriple::set_subject(const ::std::string& value) {
  set_has_subject();
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.subject)
}
inline void RelationTriple::set_subject(const char* value) {
  set_has_subject();
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.RelationTriple.subject)
}
inline void RelationTriple::set_subject(const char* value, size_t size) {
  set_has_subject();
  subject_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.RelationTriple.subject)
}
inline ::std::string* RelationTriple::mutable_subject() {
  set_has_subject();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.subject)
  return subject_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelationTriple::release_subject() {
  clear_has_subject();
  return subject_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelationTriple::set_allocated_subject(::std::string* subject) {
  if (subject != NULL) {
    set_has_subject();
  } else {
    clear_has_subject();
  }
  subject_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subject);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.subject)
}

// optional string relation = 2;
inline bool RelationTriple::has_relation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelationTriple::set_has_relation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelationTriple::clear_has_relation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelationTriple::clear_relation() {
  relation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_relation();
}
inline const ::std::string& RelationTriple::relation() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.relation)
  return relation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelationTriple::set_relation(const ::std::string& value) {
  set_has_relation();
  relation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.relation)
}
inline void RelationTriple::set_relation(const char* value) {
  set_has_relation();
  relation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.RelationTriple.relation)
}
inline void RelationTriple::set_relation(const char* value, size_t size) {
  set_has_relation();
  relation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.RelationTriple.relation)
}
inline ::std::string* RelationTriple::mutable_relation() {
  set_has_relation();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.relation)
  return relation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelationTriple::release_relation() {
  clear_has_relation();
  return relation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelationTriple::set_allocated_relation(::std::string* relation) {
  if (relation != NULL) {
    set_has_relation();
  } else {
    clear_has_relation();
  }
  relation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relation);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.relation)
}

// optional string object = 3;
inline bool RelationTriple::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelationTriple::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelationTriple::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelationTriple::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
inline const ::std::string& RelationTriple::object() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.object)
  return object_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelationTriple::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.object)
}
inline void RelationTriple::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.RelationTriple.object)
}
inline void RelationTriple::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.RelationTriple.object)
}
inline ::std::string* RelationTriple::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelationTriple::release_object() {
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelationTriple::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.object)
}

// optional double confidence = 4;
inline bool RelationTriple::has_confidence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelationTriple::set_has_confidence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelationTriple::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelationTriple::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline double RelationTriple::confidence() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.confidence)
  return confidence_;
}
inline void RelationTriple::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.confidence)
}

// repeated uint32 subjectTokens = 5;
inline int RelationTriple::subjecttokens_size() const {
  return subjecttokens_.size();
}
inline void RelationTriple::clear_subjecttokens() {
  subjecttokens_.Clear();
}
inline ::google::protobuf::uint32 RelationTriple::subjecttokens(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
  return subjecttokens_.Get(index);
}
inline void RelationTriple::set_subjecttokens(int index, ::google::protobuf::uint32 value) {
  subjecttokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
}
inline void RelationTriple::add_subjecttokens(::google::protobuf::uint32 value) {
  subjecttokens_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RelationTriple::subjecttokens() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
  return subjecttokens_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RelationTriple::mutable_subjecttokens() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.RelationTriple.subjectTokens)
  return &subjecttokens_;
}

// repeated uint32 relationTokens = 6;
inline int RelationTriple::relationtokens_size() const {
  return relationtokens_.size();
}
inline void RelationTriple::clear_relationtokens() {
  relationtokens_.Clear();
}
inline ::google::protobuf::uint32 RelationTriple::relationtokens(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
  return relationtokens_.Get(index);
}
inline void RelationTriple::set_relationtokens(int index, ::google::protobuf::uint32 value) {
  relationtokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
}
inline void RelationTriple::add_relationtokens(::google::protobuf::uint32 value) {
  relationtokens_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RelationTriple::relationtokens() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
  return relationtokens_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RelationTriple::mutable_relationtokens() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.RelationTriple.relationTokens)
  return &relationtokens_;
}

// repeated uint32 objectTokens = 7;
inline int RelationTriple::objecttokens_size() const {
  return objecttokens_.size();
}
inline void RelationTriple::clear_objecttokens() {
  objecttokens_.Clear();
}
inline ::google::protobuf::uint32 RelationTriple::objecttokens(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
  return objecttokens_.Get(index);
}
inline void RelationTriple::set_objecttokens(int index, ::google::protobuf::uint32 value) {
  objecttokens_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
}
inline void RelationTriple::add_objecttokens(::google::protobuf::uint32 value) {
  objecttokens_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RelationTriple::objecttokens() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
  return objecttokens_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RelationTriple::mutable_objecttokens() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.RelationTriple.objectTokens)
  return &objecttokens_;
}

// optional .edu.stanford.nlp.pipeline.DependencyGraph tree = 8;
inline bool RelationTriple::has_tree() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RelationTriple::set_has_tree() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RelationTriple::clear_has_tree() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RelationTriple::clear_tree() {
  if (tree_ != NULL) tree_->::edu::stanford::nlp::pipeline::DependencyGraph::Clear();
  clear_has_tree();
}
inline const ::edu::stanford::nlp::pipeline::DependencyGraph& RelationTriple::tree() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.tree)
  return tree_ != NULL ? *tree_ : *default_instance_->tree_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* RelationTriple::mutable_tree() {
  set_has_tree();
  if (tree_ == NULL) {
    tree_ = new ::edu::stanford::nlp::pipeline::DependencyGraph;
  }
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.RelationTriple.tree)
  return tree_;
}
inline ::edu::stanford::nlp::pipeline::DependencyGraph* RelationTriple::release_tree() {
  clear_has_tree();
  ::edu::stanford::nlp::pipeline::DependencyGraph* temp = tree_;
  tree_ = NULL;
  return temp;
}
inline void RelationTriple::set_allocated_tree(::edu::stanford::nlp::pipeline::DependencyGraph* tree) {
  delete tree_;
  tree_ = tree;
  if (tree) {
    set_has_tree();
  } else {
    clear_has_tree();
  }
  // @@protoc_insertion_point(field_set_allocated:edu.stanford.nlp.pipeline.RelationTriple.tree)
}

// optional bool istmod = 9;
inline bool RelationTriple::has_istmod() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RelationTriple::set_has_istmod() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RelationTriple::clear_has_istmod() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RelationTriple::clear_istmod() {
  istmod_ = false;
  clear_has_istmod();
}
inline bool RelationTriple::istmod() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.istmod)
  return istmod_;
}
inline void RelationTriple::set_istmod(bool value) {
  set_has_istmod();
  istmod_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.istmod)
}

// optional bool prefixBe = 10;
inline bool RelationTriple::has_prefixbe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RelationTriple::set_has_prefixbe() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RelationTriple::clear_has_prefixbe() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RelationTriple::clear_prefixbe() {
  prefixbe_ = false;
  clear_has_prefixbe();
}
inline bool RelationTriple::prefixbe() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.prefixBe)
  return prefixbe_;
}
inline void RelationTriple::set_prefixbe(bool value) {
  set_has_prefixbe();
  prefixbe_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.prefixBe)
}

// optional bool suffixBe = 11;
inline bool RelationTriple::has_suffixbe() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RelationTriple::set_has_suffixbe() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RelationTriple::clear_has_suffixbe() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RelationTriple::clear_suffixbe() {
  suffixbe_ = false;
  clear_has_suffixbe();
}
inline bool RelationTriple::suffixbe() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.suffixBe)
  return suffixbe_;
}
inline void RelationTriple::set_suffixbe(bool value) {
  set_has_suffixbe();
  suffixbe_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.suffixBe)
}

// optional bool suffixOf = 12;
inline bool RelationTriple::has_suffixof() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RelationTriple::set_has_suffixof() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RelationTriple::clear_has_suffixof() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RelationTriple::clear_suffixof() {
  suffixof_ = false;
  clear_has_suffixof();
}
inline bool RelationTriple::suffixof() const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.RelationTriple.suffixOf)
  return suffixof_;
}
inline void RelationTriple::set_suffixof(bool value) {
  set_has_suffixof();
  suffixof_ = value;
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.RelationTriple.suffixOf)
}

// -------------------------------------------------------------------

// MapStringString

// repeated string key = 1;
inline int MapStringString::key_size() const {
  return key_.size();
}
inline void MapStringString::clear_key() {
  key_.Clear();
}
inline const ::std::string& MapStringString::key(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapStringString.key)
  return key_.Get(index);
}
inline ::std::string* MapStringString::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.MapStringString.key)
  return key_.Mutable(index);
}
inline void MapStringString::set_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapStringString.key)
  key_.Mutable(index)->assign(value);
}
inline void MapStringString::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.MapStringString.key)
}
inline void MapStringString::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.MapStringString.key)
}
inline ::std::string* MapStringString::add_key() {
  return key_.Add();
}
inline void MapStringString::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapStringString.key)
}
inline void MapStringString::add_key(const char* value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.MapStringString.key)
}
inline void MapStringString::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.MapStringString.key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapStringString::key() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapStringString.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapStringString::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapStringString.key)
  return &key_;
}

// repeated string value = 2;
inline int MapStringString::value_size() const {
  return value_.size();
}
inline void MapStringString::clear_value() {
  value_.Clear();
}
inline const ::std::string& MapStringString::value(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapStringString.value)
  return value_.Get(index);
}
inline ::std::string* MapStringString::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.MapStringString.value)
  return value_.Mutable(index);
}
inline void MapStringString::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapStringString.value)
  value_.Mutable(index)->assign(value);
}
inline void MapStringString::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.MapStringString.value)
}
inline void MapStringString::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.MapStringString.value)
}
inline ::std::string* MapStringString::add_value() {
  return value_.Add();
}
inline void MapStringString::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapStringString.value)
}
inline void MapStringString::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.MapStringString.value)
}
inline void MapStringString::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.MapStringString.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapStringString::value() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapStringString.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapStringString::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapStringString.value)
  return &value_;
}

// -------------------------------------------------------------------

// MapIntString

// repeated uint32 key = 1;
inline int MapIntString::key_size() const {
  return key_.size();
}
inline void MapIntString::clear_key() {
  key_.Clear();
}
inline ::google::protobuf::uint32 MapIntString::key(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapIntString.key)
  return key_.Get(index);
}
inline void MapIntString::set_key(int index, ::google::protobuf::uint32 value) {
  key_.Set(index, value);
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapIntString.key)
}
inline void MapIntString::add_key(::google::protobuf::uint32 value) {
  key_.Add(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapIntString.key)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MapIntString::key() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapIntString.key)
  return key_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MapIntString::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapIntString.key)
  return &key_;
}

// repeated string value = 2;
inline int MapIntString::value_size() const {
  return value_.size();
}
inline void MapIntString::clear_value() {
  value_.Clear();
}
inline const ::std::string& MapIntString::value(int index) const {
  // @@protoc_insertion_point(field_get:edu.stanford.nlp.pipeline.MapIntString.value)
  return value_.Get(index);
}
inline ::std::string* MapIntString::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:edu.stanford.nlp.pipeline.MapIntString.value)
  return value_.Mutable(index);
}
inline void MapIntString::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:edu.stanford.nlp.pipeline.MapIntString.value)
  value_.Mutable(index)->assign(value);
}
inline void MapIntString::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:edu.stanford.nlp.pipeline.MapIntString.value)
}
inline void MapIntString::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:edu.stanford.nlp.pipeline.MapIntString.value)
}
inline ::std::string* MapIntString::add_value() {
  return value_.Add();
}
inline void MapIntString::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:edu.stanford.nlp.pipeline.MapIntString.value)
}
inline void MapIntString::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:edu.stanford.nlp.pipeline.MapIntString.value)
}
inline void MapIntString::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:edu.stanford.nlp.pipeline.MapIntString.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapIntString::value() const {
  // @@protoc_insertion_point(field_list:edu.stanford.nlp.pipeline.MapIntString.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapIntString::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:edu.stanford.nlp.pipeline.MapIntString.value)
  return &value_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pipeline
}  // namespace nlp
}  // namespace stanford
}  // namespace edu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::edu::stanford::nlp::pipeline::Language> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::edu::stanford::nlp::pipeline::Language>() {
  return ::edu::stanford::nlp::pipeline::Language_descriptor();
}
template <> struct is_proto_enum< ::edu::stanford::nlp::pipeline::Sentiment> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::edu::stanford::nlp::pipeline::Sentiment>() {
  return ::edu::stanford::nlp::pipeline::Sentiment_descriptor();
}
template <> struct is_proto_enum< ::edu::stanford::nlp::pipeline::NaturalLogicRelation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::edu::stanford::nlp::pipeline::NaturalLogicRelation>() {
  return ::edu::stanford::nlp::pipeline::NaturalLogicRelation_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CoreNLP_2eproto__INCLUDED
